<!DOCTYPE html>
<html><head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lightningnetwork/lnd/lnwire/accept_channel.go (100.0%)</option>
				
				<option value="file1">github.com/lightningnetwork/lnd/lnwire/announcement_signatures.go (91.7%)</option>
				
				<option value="file2">github.com/lightningnetwork/lnd/lnwire/channel_announcement.go (64.7%)</option>
				
				<option value="file3">github.com/lightningnetwork/lnd/lnwire/channel_id.go (0.0%)</option>
				
				<option value="file4">github.com/lightningnetwork/lnd/lnwire/channel_reestablish.go (96.0%)</option>
				
				<option value="file5">github.com/lightningnetwork/lnd/lnwire/channel_update.go (55.9%)</option>
				
				<option value="file6">github.com/lightningnetwork/lnd/lnwire/closing_signed.go (88.9%)</option>
				
				<option value="file7">github.com/lightningnetwork/lnd/lnwire/commit_sig.go (66.7%)</option>
				
				<option value="file8">github.com/lightningnetwork/lnd/lnwire/error.go (21.1%)</option>
				
				<option value="file9">github.com/lightningnetwork/lnd/lnwire/features.go (44.4%)</option>
				
				<option value="file10">github.com/lightningnetwork/lnd/lnwire/funding_created.go (100.0%)</option>
				
				<option value="file11">github.com/lightningnetwork/lnd/lnwire/funding_locked.go (87.5%)</option>
				
				<option value="file12">github.com/lightningnetwork/lnd/lnwire/funding_signed.go (100.0%)</option>
				
				<option value="file13">github.com/lightningnetwork/lnd/lnwire/gossip_timestamp_range.go (80.0%)</option>
				
				<option value="file14">github.com/lightningnetwork/lnd/lnwire/init_message.go (80.0%)</option>
				
				<option value="file15" selected="selected">github.com/lightningnetwork/lnd/lnwire/lnwire.go (80.0%)</option>
				
				<option value="file16">github.com/lightningnetwork/lnd/lnwire/message.go (59.1%)</option>
				
				<option value="file17">github.com/lightningnetwork/lnd/lnwire/msat.go (0.0%)</option>
				
				<option value="file18">github.com/lightningnetwork/lnd/lnwire/netaddress.go (0.0%)</option>
				
				<option value="file19">github.com/lightningnetwork/lnd/lnwire/node_announcement.go (58.6%)</option>
				
				<option value="file20">github.com/lightningnetwork/lnd/lnwire/onion_error.go (0.0%)</option>
				
				<option value="file21">github.com/lightningnetwork/lnd/lnwire/open_channel.go (100.0%)</option>
				
				<option value="file22">github.com/lightningnetwork/lnd/lnwire/ping.go (80.0%)</option>
				
				<option value="file23">github.com/lightningnetwork/lnd/lnwire/pong.go (80.0%)</option>
				
				<option value="file24">github.com/lightningnetwork/lnd/lnwire/query_channel_range.go (80.0%)</option>
				
				<option value="file25">github.com/lightningnetwork/lnd/lnwire/query_short_chan_ids.go (86.5%)</option>
				
				<option value="file26">github.com/lightningnetwork/lnd/lnwire/reply_channel_range.go (80.0%)</option>
				
				<option value="file27">github.com/lightningnetwork/lnd/lnwire/reply_short_chan_ids_end.go (80.0%)</option>
				
				<option value="file28">github.com/lightningnetwork/lnd/lnwire/revoke_and_ack.go (66.7%)</option>
				
				<option value="file29">github.com/lightningnetwork/lnd/lnwire/short_channel_id.go (33.3%)</option>
				
				<option value="file30">github.com/lightningnetwork/lnd/lnwire/shutdown.go (88.9%)</option>
				
				<option value="file31">github.com/lightningnetwork/lnd/lnwire/signature.go (0.0%)</option>
				
				<option value="file32">github.com/lightningnetwork/lnd/lnwire/update_add_htlc.go (66.7%)</option>
				
				<option value="file33">github.com/lightningnetwork/lnd/lnwire/update_fail_htlc.go (90.0%)</option>
				
				<option value="file34">github.com/lightningnetwork/lnd/lnwire/update_fail_malformed_htlc.go (80.0%)</option>
				
				<option value="file35">github.com/lightningnetwork/lnd/lnwire/update_fee.go (66.7%)</option>
				
				<option value="file36">github.com/lightningnetwork/lnd/lnwire/update_fulfill_htlc.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none;">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcutil"
)

// AcceptChannel is the message Bob sends to Alice after she initiates the
// single funder channel workflow via an AcceptChannel message. Once Alice
// receives Bob's response, then she has all the items necessary to construct
// the funding transaction, and both commitment transactions.
type AcceptChannel struct {
        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // DustLimit is the specific dust limit the sender of this message
        // would like enforced on their version of the commitment transaction.
        // Any output below this value will be "trimmed" from the commitment
        // transaction, with the amount of the HTLC going to dust.
        DustLimit btcutil.Amount

        // MaxValueInFlight represents the maximum amount of coins that can be
        // pending within the channel at any given time. If the amount of funds
        // in limbo exceeds this amount, then the channel will be failed.
        MaxValueInFlight MilliSatoshi

        // ChannelReserve is the amount of BTC that the receiving party MUST
        // maintain a balance above at all times. This is a safety mechanism to
        // ensure that both sides always have skin in the game during the
        // channel's lifetime.
        ChannelReserve btcutil.Amount

        // HtlcMinimum is the smallest HTLC that the sender of this message
        // will accept.
        HtlcMinimum MilliSatoshi

        // MinAcceptDepth is the minimum depth that the initiator of the
        // channel should wait before considering the channel open.
        MinAcceptDepth uint32

        // CsvDelay is the number of blocks to use for the relative time lock
        // in the pay-to-self output of both commitment transactions.
        CsvDelay uint16

        // MaxAcceptedHTLCs is the total number of incoming HTLC's that the
        // sender of this channel will accept.
        //
        // TODO(roasbeef): acks the initiator's, same with max in flight?
        MaxAcceptedHTLCs uint16

        // FundingKey is the key that should be used on behalf of the sender
        // within the 2-of-2 multi-sig output that it contained within the
        // funding transaction.
        FundingKey *btcec.PublicKey

        // RevocationPoint is the base revocation point for the sending party.
        // Any commitment transaction belonging to the receiver of this message
        // should use this key and their per-commitment point to derive the
        // revocation key for the commitment transaction.
        RevocationPoint *btcec.PublicKey

        // PaymentPoint is the base payment point for the sending party. This
        // key should be combined with the per commitment point for a
        // particular commitment state in order to create the key that should
        // be used in any output that pays directly to the sending party, and
        // also within the HTLC covenant transactions.
        PaymentPoint *btcec.PublicKey

        // DelayedPaymentPoint is the delay point for the sending party. This
        // key should be combined with the per commitment point to derive the
        // keys that are used in outputs of the sender's commitment transaction
        // where they claim funds.
        DelayedPaymentPoint *btcec.PublicKey

        // HtlcPoint is the base point used to derive the set of keys for this
        // party that will be used within the HTLC public key scripts.  This
        // value is combined with the receiver's revocation base point in order
        // to derive the keys that are used within HTLC scripts.
        HtlcPoint *btcec.PublicKey

        // FirstCommitmentPoint is the first commitment point for the sending
        // party. This value should be combined with the receiver's revocation
        // base point in order to derive the revocation keys that are placed
        // within the commitment transaction of the sender.
        FirstCommitmentPoint *btcec.PublicKey

        // UpfrontShutdownScript is the script to which the channel funds should
        // be paid when mutually closing the channel. This field is optional, and
        // and has a length prefix, so a zero will be written if it is not set
        // and its length followed by the script will be written if it is set.
        UpfrontShutdownScript DeliveryAddress
}

// A compile time check to ensure AcceptChannel implements the lnwire.Message
// interface.
var _ Message = (*AcceptChannel)(nil)

// Encode serializes the target AcceptChannel into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) Encode(w io.Writer, pver uint32) error <span class="cov7" title="27">{
        return WriteElements(w,
                a.PendingChannelID[:],
                a.DustLimit,
                a.MaxValueInFlight,
                a.ChannelReserve,
                a.HtlcMinimum,
                a.MinAcceptDepth,
                a.CsvDelay,
                a.MaxAcceptedHTLCs,
                a.FundingKey,
                a.RevocationPoint,
                a.PaymentPoint,
                a.DelayedPaymentPoint,
                a.HtlcPoint,
                a.FirstCommitmentPoint,
                a.UpfrontShutdownScript,
        )
}</span>

// Decode deserializes the serialized AcceptChannel stored in the passed
// io.Reader into the target AcceptChannel using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error <span class="cov10" title="70">{
        // Read all the mandatory fields in the accept message.
        err := ReadElements(r,
                a.PendingChannelID[:],
                &amp;a.DustLimit,
                &amp;a.MaxValueInFlight,
                &amp;a.ChannelReserve,
                &amp;a.HtlcMinimum,
                &amp;a.MinAcceptDepth,
                &amp;a.CsvDelay,
                &amp;a.MaxAcceptedHTLCs,
                &amp;a.FundingKey,
                &amp;a.RevocationPoint,
                &amp;a.PaymentPoint,
                &amp;a.DelayedPaymentPoint,
                &amp;a.HtlcPoint,
                &amp;a.FirstCommitmentPoint,
        )
        if err != nil </span><span class="cov6" title="14">{
                return err
        }</span>

        // Check for the optional upfront shutdown script field. If it is not there,
        // silence the EOF error.
        <span class="cov9" title="56">err = ReadElement(r, &amp;a.UpfrontShutdownScript)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov2" title="2">{
                return err
        }</span>
        <span class="cov9" title="54">return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as an AcceptChannel on the wire.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) MsgType() MessageType <span class="cov7" title="27">{
        return MsgAcceptChannel
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// AcceptChannel message.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) MaxPayloadLength(uint32) uint32 <span class="cov10" title="70">{
        // 32 + (8 * 4) + (4 * 1) + (2 * 2) + (33 * 6)
        var length uint32 = 270 // base length

        // Upfront shutdown script max length.
        length += 2 + deliveryAddressMaxSize

        return length
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package lnwire

import (
        "io"
        "io/ioutil"
)

// AnnounceSignatures this is a direct message between two endpoints of a
// channel and serves as an opt-in mechanism to allow the announcement of
// the channel to the rest of the network. It contains the necessary
// signatures by the sender to construct the channel announcement message.
type AnnounceSignatures struct {
        // ChannelID is the unique description of the funding transaction.
        // Channel id is better for users and debugging and short channel id is
        // used for quick test on existence of the particular utxo inside the
        // block chain, because it contains information about block.
        ChannelID ChannelID

        // ShortChannelID is the unique description of the funding
        // transaction. It is constructed with the most significant 3 bytes
        // as the block height, the next 3 bytes indicating the transaction
        // index within the block, and the least significant two bytes
        // indicating the output index which pays to the channel.
        ShortChannelID ShortChannelID

        // NodeSignature is the signature which contains the signed announce
        // channel message, by this signature we proof that we possess of the
        // node pub key and creating the reference node_key -&gt; bitcoin_key.
        NodeSignature Sig

        // BitcoinSignature is the signature which contains the signed node
        // public key, by this signature we proof that we possess of the
        // bitcoin key and and creating the reverse reference bitcoin_key -&gt;
        // node_key.
        BitcoinSignature Sig

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// A compile time check to ensure AnnounceSignatures implements the
// lnwire.Message interface.
var _ Message = (*AnnounceSignatures)(nil)

// Decode deserializes a serialized AnnounceSignatures stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) Decode(r io.Reader, pver uint32) error <span class="cov10" title="23">{
        err := ReadElements(r,
                &amp;a.ChannelID,
                &amp;a.ShortChannelID,
                &amp;a.NodeSignature,
                &amp;a.BitcoinSignature,
        )
        if err != nil </span><span class="cov5" title="5">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov9" title="18">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="18">if len(a.ExtraOpaqueData) == 0 </span><span class="cov2" title="2">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov9" title="18">return nil</span>
}

// Encode serializes the target AnnounceSignatures into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) Encode(w io.Writer, pver uint32) error <span class="cov7" title="9">{
        return WriteElements(w,
                a.ChannelID,
                a.ShortChannelID,
                a.NodeSignature,
                a.BitcoinSignature,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) MsgType() MessageType <span class="cov7" title="9">{
        return MsgAnnounceSignatures
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="23">{
        return 65533
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package lnwire

import (
        "bytes"
        "io"
        "io/ioutil"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ChannelAnnouncement message is used to announce the existence of a channel
// between two peers in the overlay, which is propagated by the discovery
// service over broadcast handler.
type ChannelAnnouncement struct {
        // This signatures are used by nodes in order to create cross
        // references between node's channel and node. Requiring both nodes
        // to sign indicates they are both willing to route other payments via
        // this node.
        NodeSig1 Sig
        NodeSig2 Sig

        // This signatures are used by nodes in order to create cross
        // references between node's channel and node. Requiring the bitcoin
        // signatures proves they control the channel.
        BitcoinSig1 Sig
        BitcoinSig2 Sig

        // Features is the feature vector that encodes the features supported
        // by the target node. This field can be used to signal the type of the
        // channel, or modifications to the fields that would normally follow
        // this vector.
        Features *RawFeatureVector

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        ChainHash chainhash.Hash

        // ShortChannelID is the unique description of the funding transaction,
        // or where exactly it's located within the target blockchain.
        ShortChannelID ShortChannelID

        // The public keys of the two nodes who are operating the channel, such
        // that is NodeID1 the numerically-lesser than NodeID2 (ascending
        // numerical order).
        NodeID1 [33]byte
        NodeID2 [33]byte

        // Public keys which corresponds to the keys which was declared in
        // multisig funding transaction output.
        BitcoinKey1 [33]byte
        BitcoinKey2 [33]byte

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// A compile time check to ensure ChannelAnnouncement implements the
// lnwire.Message interface.
var _ Message = (*ChannelAnnouncement)(nil)

// Decode deserializes a serialized ChannelAnnouncement stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) Decode(r io.Reader, pver uint32) error <span class="cov10" title="32">{
        err := ReadElements(r,
                &amp;a.NodeSig1,
                &amp;a.NodeSig2,
                &amp;a.BitcoinSig1,
                &amp;a.BitcoinSig2,
                &amp;a.Features,
                a.ChainHash[:],
                &amp;a.ShortChannelID,
                &amp;a.NodeID1,
                &amp;a.NodeID2,
                &amp;a.BitcoinKey1,
                &amp;a.BitcoinKey2,
        )
        if err != nil </span><span class="cov6" title="8">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov9" title="24">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="24">if len(a.ExtraOpaqueData) == 0 </span><span class="cov5" title="6">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov9" title="24">return nil</span>
}

// Encode serializes the target ChannelAnnouncement into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) Encode(w io.Writer, pver uint32) error <span class="cov7" title="12">{
        return WriteElements(w,
                a.NodeSig1,
                a.NodeSig2,
                a.BitcoinSig1,
                a.BitcoinSig2,
                a.Features,
                a.ChainHash[:],
                a.ShortChannelID,
                a.NodeID1,
                a.NodeID2,
                a.BitcoinKey1,
                a.BitcoinKey2,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) MsgType() MessageType <span class="cov7" title="12">{
        return MsgChannelAnnouncement
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="32">{
        return 65533
}</span>

// DataToSign is used to retrieve part of the announcement message which should
// be signed.
func (a *ChannelAnnouncement) DataToSign() ([]byte, error) <span class="cov0" title="0">{
        // We should not include the signatures itself.
        var w bytes.Buffer
        err := WriteElements(&amp;w,
                a.Features,
                a.ChainHash[:],
                a.ShortChannelID,
                a.NodeID1,
                a.NodeID2,
                a.BitcoinKey1,
                a.BitcoinKey2,
                a.ExtraOpaqueData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package lnwire

import (
        "encoding/binary"
        "encoding/hex"
        "math"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
)

const (
        // MaxFundingTxOutputs is the maximum number of allowed outputs on a
        // funding transaction within the protocol. This is due to the fact
        // that we use 2-bytes to encode the index within the funding output
        // during the funding workflow. Funding transaction with more outputs
        // than this are considered invalid within the protocol.
        MaxFundingTxOutputs = math.MaxUint16
)

// ChannelID is a series of 32-bytes that uniquely identifies all channels
// within the network. The ChannelID is computed using the outpoint of the
// funding transaction (the txid, and output index). Given a funding output the
// ChannelID can be calculated by XOR'ing the big-endian serialization of the
// txid and the big-endian serialization of the output index, truncated to
// 2 bytes.
type ChannelID [32]byte

// ConnectionWideID is an all-zero ChannelID, which is used to represent a
// message intended for all channels to specific peer.
var ConnectionWideID = ChannelID{}

// String returns the string representation of the ChannelID. This is just the
// hex string encoding of the ChannelID itself.
func (c ChannelID) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(c[:])
}</span>

// NewChanIDFromOutPoint converts a target OutPoint into a ChannelID that is
// usable within the network. In order to convert the OutPoint into a ChannelID,
// we XOR the lower 2-bytes of the txid within the OutPoint with the big-endian
// serialization of the Index of the OutPoint, truncated to 2-bytes.
func NewChanIDFromOutPoint(op *wire.OutPoint) ChannelID <span class="cov0" title="0">{
        // First we'll copy the txid of the outpoint into our channel ID slice.
        var cid ChannelID
        copy(cid[:], op.Hash[:])

        // With the txid copied over, we'll now XOR the lower 2-bytes of the
        // partial channelID with big-endian serialization of output index.
        xorTxid(&amp;cid, uint16(op.Index))

        return cid
}</span>

// xorTxid performs the transformation needed to transform an OutPoint into a
// ChannelID. To do this, we expect the cid parameter to contain the txid
// unaltered and the outputIndex to be the output index
func xorTxid(cid *ChannelID, outputIndex uint16) <span class="cov0" title="0">{
        var buf [2]byte
        binary.BigEndian.PutUint16(buf[:], outputIndex)

        cid[30] ^= buf[0]
        cid[31] ^= buf[1]
}</span>

// GenPossibleOutPoints generates all the possible outputs given a channel ID.
// In order to generate these possible outpoints, we perform a brute-force
// search through the candidate output index space, performing a reverse
// mapping from channelID back to OutPoint.
func (c *ChannelID) GenPossibleOutPoints() [MaxFundingTxOutputs]wire.OutPoint <span class="cov0" title="0">{
        var possiblePoints [MaxFundingTxOutputs]wire.OutPoint
        for i := uint16(0); i &lt; MaxFundingTxOutputs; i++ </span><span class="cov0" title="0">{
                cidCopy := *c
                xorTxid(&amp;cidCopy, i)

                possiblePoints[i] = wire.OutPoint{
                        Hash:  chainhash.Hash(cidCopy),
                        Index: uint32(i),
                }
        }</span>

        <span class="cov0" title="0">return possiblePoints</span>
}

// IsChanPoint returns true if the OutPoint passed corresponds to the target
// ChannelID.
func (c ChannelID) IsChanPoint(op *wire.OutPoint) bool <span class="cov0" title="0">{
        candidateCid := NewChanIDFromOutPoint(op)

        return candidateCid == c
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
)

// ChannelReestablish is a message sent between peers that have an existing
// open channel upon connection reestablishment. This message allows both sides
// to report their local state, and their current knowledge of the state of the
// remote commitment chain. If a deviation is detected and can be recovered
// from, then the necessary messages will be retransmitted. If the level of
// desynchronization if irreconcilable, then the channel will be force closed.
type ChannelReestablish struct {
        // ChanID is the channel ID of the channel state we're attempting
        // synchronize with the remote party.
        ChanID ChannelID

        // NextLocalCommitHeight is the next local commitment height of the
        // sending party. If the height of the sender's commitment chain from
        // the receiver's Pov is one less that this number, then the sender
        // should re-send the *exact* same proposed commitment.
        //
        // In other words, the receiver should re-send their last sent
        // commitment iff:
        //
        //  * NextLocalCommitHeight == remoteCommitChain.Height
        //
        // This covers the case of a lost commitment which was sent by the
        // sender of this message, but never received by the receiver of this
        // message.
        NextLocalCommitHeight uint64

        // RemoteCommitTailHeight is the height of the receiving party's
        // unrevoked commitment from the PoV of the sender of this message. If
        // the height of the receiver's commitment is *one more* than this
        // value, then their prior RevokeAndAck message should be
        // retransmitted.
        //
        // In other words, the receiver should re-send their last sent
        // RevokeAndAck message iff:
        //
        //  * localCommitChain.tail().Height == RemoteCommitTailHeight + 1
        //
        // This covers the case of a lost revocation, wherein the receiver of
        // the message sent a revocation for a prior state, but the sender of
        // the message never fully processed it.
        RemoteCommitTailHeight uint64

        // LastRemoteCommitSecret is the last commitment secret that the
        // receiving node has sent to the sending party. This will be the
        // secret of the last revoked commitment transaction. Including this
        // provides proof that the sending node at least knows of this state,
        // as they couldn't have produced it if it wasn't sent, as the value
        // can be authenticated by querying the shachain or the receiving
        // party.
        LastRemoteCommitSecret [32]byte

        // LocalUnrevokedCommitPoint is the commitment point used in the
        // current un-revoked commitment transaction of the sending party.
        LocalUnrevokedCommitPoint *btcec.PublicKey
}

// A compile time check to ensure ChannelReestablish implements the
// lnwire.Message interface.
var _ Message = (*ChannelReestablish)(nil)

// Encode serializes the target ChannelReestablish into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) Encode(w io.Writer, pver uint32) error <span class="cov7" title="13">{
        err := WriteElements(w,
                a.ChanID,
                a.NextLocalCommitHeight,
                a.RemoteCommitTailHeight,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the commit point wasn't sent, then we won't write out any of the
        // remaining fields as they're optional.
        <span class="cov7" title="13">if a.LocalUnrevokedCommitPoint == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Otherwise, we'll write out the remaining elements.
        <span class="cov7" title="12">return WriteElements(w, a.LastRemoteCommitSecret[:],
                a.LocalUnrevokedCommitPoint)</span>
}

// Decode deserializes a serialized ChannelReestablish stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) Decode(r io.Reader, pver uint32) error <span class="cov10" title="34">{
        err := ReadElements(r,
                &amp;a.ChanID,
                &amp;a.NextLocalCommitHeight,
                &amp;a.RemoteCommitTailHeight,
        )
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        // This message has to currently defined optional fields. As a result,
        // we'll only proceed if there's still bytes remaining within the
        // reader.
        //
        // We'll manually parse out the optional fields in order to be able to
        // still utilize the io.Reader interface.

        // We'll first attempt to read the optional commit secret, if we're at
        // the EOF, then this means the field wasn't included so we can exit
        // early.
        <span class="cov9" title="32">var buf [32]byte
        _, err = io.ReadFull(r, buf[:32])
        if err == io.EOF </span><span class="cov2" title="2">{
                return nil
        }</span> else<span class="cov9" title="30"> if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // If the field is present, then we'll copy it over and proceed.
        <span class="cov9" title="29">copy(a.LastRemoteCommitSecret[:], buf[:])

        // We'll conclude by parsing out the commitment point. We don't check
        // the error in this case, as it hey included the commit secret, then
        // they MUST also include the commit point.
        return ReadElement(r, &amp;a.LocalUnrevokedCommitPoint)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) MsgType() MessageType <span class="cov7" title="13">{
        return MsgChannelReestablish
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="34">{
        var length uint32

        // ChanID - 32 bytes
        length += 32

        // NextLocalCommitHeight - 8 bytes
        length += 8

        // RemoteCommitTailHeight - 8 bytes
        length += 8

        // LastRemoteCommitSecret - 32 bytes
        length += 32

        // LocalUnrevokedCommitPoint - 33 bytes
        length += 33

        return length
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ChanUpdateMsgFlags is a bitfield that signals whether optional fields are
// present in the ChannelUpdate.
type ChanUpdateMsgFlags uint8

const (
        // ChanUpdateOptionMaxHtlc is a bit that indicates whether the
        // optional htlc_maximum_msat field is present in this ChannelUpdate.
        ChanUpdateOptionMaxHtlc ChanUpdateMsgFlags = 1 &lt;&lt; iota
)

// String returns the bitfield flags as a string.
func (c ChanUpdateMsgFlags) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%08b", c)
}</span>

// HasMaxHtlc returns true if the htlc_maximum_msat option bit is set in the
// message flags.
func (c ChanUpdateMsgFlags) HasMaxHtlc() bool <span class="cov10" title="31">{
        return c&amp;ChanUpdateOptionMaxHtlc != 0
}</span>

// ChanUpdateChanFlags is a bitfield that signals various options concerning a
// particular channel edge. Each bit is to be examined in order to determine
// how the ChannelUpdate message is to be interpreted.
type ChanUpdateChanFlags uint8

const (
        // ChanUpdateDirection indicates the direction of a channel update. If
        // this bit is set to 0 if Node1 (the node with the "smaller" Node ID)
        // is updating the channel, and to 1 otherwise.
        ChanUpdateDirection ChanUpdateChanFlags = 1 &lt;&lt; iota

        // ChanUpdateDisabled is a bit that indicates if the channel edge
        // selected by the ChanUpdateDirection bit is to be treated as being
        // disabled.
        ChanUpdateDisabled
)

// String returns the bitfield flags as a string.
func (c ChanUpdateChanFlags) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%08b", c)
}</span>

// ChannelUpdate message is used after channel has been initially announced.
// Each side independently announces its fees and minimum expiry for HTLCs and
// other parameters. Also this message is used to redeclare initially set
// channel parameters.
type ChannelUpdate struct {
        // Signature is used to validate the announced data and prove the
        // ownership of node id.
        Signature Sig

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        // Along with the short channel ID, this uniquely identifies the
        // channel globally in a blockchain.
        ChainHash chainhash.Hash

        // ShortChannelID is the unique description of the funding transaction.
        ShortChannelID ShortChannelID

        // Timestamp allows ordering in the case of multiple announcements.  We
        // should ignore the message if timestamp is not greater than
        // the last-received.
        Timestamp uint32

        // MessageFlags is a bitfield that describes whether optional fields
        // are present in this update. Currently, the least-significant bit
        // must be set to 1 if the optional field MaxHtlc is present.
        MessageFlags ChanUpdateMsgFlags

        // ChannelFlags is a bitfield that describes additional meta-data
        // concerning how the update is to be interpreted. Currently, the
        // least-significant bit must be set to 0 if the creating node
        // corresponds to the first node in the previously sent channel
        // announcement and 1 otherwise. If the second bit is set, then the
        // channel is set to be disabled.
        ChannelFlags ChanUpdateChanFlags

        // TimeLockDelta is the minimum number of blocks this node requires to
        // be added to the expiry of HTLCs. This is a security parameter
        // determined by the node operator. This value represents the required
        // gap between the time locks of the incoming and outgoing HTLC's set
        // to this node.
        TimeLockDelta uint16

        // HtlcMinimumMsat is the minimum HTLC value which will be accepted.
        HtlcMinimumMsat MilliSatoshi

        // BaseFee is the base fee that must be used for incoming HTLC's to
        // this particular channel. This value will be tacked onto the required
        // for a payment independent of the size of the payment.
        BaseFee uint32

        // FeeRate is the fee rate that will be charged per millionth of a
        // satoshi.
        FeeRate uint32

        // HtlcMaximumMsat is the maximum HTLC value which will be accepted.
        HtlcMaximumMsat MilliSatoshi

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// A compile time check to ensure ChannelUpdate implements the lnwire.Message
// interface.
var _ Message = (*ChannelUpdate)(nil)

// Decode deserializes a serialized ChannelUpdate stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) Decode(r io.Reader, pver uint32) error <span class="cov9" title="30">{
        err := ReadElements(r,
                &amp;a.Signature,
                a.ChainHash[:],
                &amp;a.ShortChannelID,
                &amp;a.Timestamp,
                &amp;a.MessageFlags,
                &amp;a.ChannelFlags,
                &amp;a.TimeLockDelta,
                &amp;a.HtlcMinimumMsat,
                &amp;a.BaseFee,
                &amp;a.FeeRate,
        )
        if err != nil </span><span class="cov6" title="9">{
                return err
        }</span>

        // Now check whether the max HTLC field is present and read it if so.
        <span class="cov8" title="21">if a.MessageFlags.HasMaxHtlc() </span><span class="cov6" title="9">{
                if err := ReadElements(r, &amp;a.HtlcMaximumMsat); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov8" title="20">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="20">if len(a.ExtraOpaqueData) == 0 </span><span class="cov4" title="4">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov8" title="20">return nil</span>
}

// Encode serializes the target ChannelUpdate into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) Encode(w io.Writer, pver uint32) error <span class="cov7" title="10">{
        err := WriteElements(w,
                a.Signature,
                a.ChainHash[:],
                a.ShortChannelID,
                a.Timestamp,
                a.MessageFlags,
                a.ChannelFlags,
                a.TimeLockDelta,
                a.HtlcMinimumMsat,
                a.BaseFee,
                a.FeeRate,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now append optional fields if they are set. Currently, the only
        // optional field is max HTLC.
        <span class="cov7" title="10">if a.MessageFlags.HasMaxHtlc() </span><span class="cov4" title="4">{
                if err := WriteElements(w, a.HtlcMaximumMsat); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Finally, append any extra opaque data.
        <span class="cov7" title="10">return WriteElements(w, a.ExtraOpaqueData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) MsgType() MessageType <span class="cov7" title="10">{
        return MsgChannelUpdate
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) MaxPayloadLength(pver uint32) uint32 <span class="cov9" title="30">{
        return 65533
}</span>

// DataToSign is used to retrieve part of the announcement message which should
// be signed.
func (a *ChannelUpdate) DataToSign() ([]byte, error) <span class="cov0" title="0">{

        // We should not include the signatures itself.
        var w bytes.Buffer
        err := WriteElements(&amp;w,
                a.ChainHash[:],
                a.ShortChannelID,
                a.Timestamp,
                a.MessageFlags,
                a.ChannelFlags,
                a.TimeLockDelta,
                a.HtlcMinimumMsat,
                a.BaseFee,
                a.FeeRate,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Now append optional fields if they are set. Currently, the only
        // optional field is max HTLC.
        <span class="cov0" title="0">if a.MessageFlags.HasMaxHtlc() </span><span class="cov0" title="0">{
                if err := WriteElements(&amp;w, a.HtlcMaximumMsat); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Finally, append any extra opaque data.
        <span class="cov0" title="0">if err := WriteElements(&amp;w, a.ExtraOpaqueData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcutil"
)

// ClosingSigned is sent by both parties to a channel once the channel is clear
// of HTLCs, and is primarily concerned with negotiating fees for the close
// transaction. Each party provides a signature for a transaction with a fee
// that they believe is fair. The process terminates when both sides agree on
// the same fee, or when one side force closes the channel.
//
// NOTE: The responder is able to send a signature without any additional
// messages as all transactions are assembled observing BIP 69 which defines a
// canonical ordering for input/outputs. Therefore, both sides are able to
// arrive at an identical closure transaction as they know the order of the
// inputs/outputs.
type ClosingSigned struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // FeeSatoshis is the total fee in satoshis that the party to the
        // channel would like to propose for the close transaction.
        FeeSatoshis btcutil.Amount

        // Signature is for the proposed channel close transaction.
        Signature Sig
}

// NewClosingSigned creates a new empty ClosingSigned message.
func NewClosingSigned(cid ChannelID, fs btcutil.Amount,
        sig Sig) *ClosingSigned <span class="cov0" title="0">{

        return &amp;ClosingSigned{
                ChannelID:   cid,
                FeeSatoshis: fs,
                Signature:   sig,
        }
}</span>

// A compile time check to ensure ClosingSigned implements the lnwire.Message
// interface.
var _ Message = (*ClosingSigned)(nil)

// Decode deserializes a serialized ClosingSigned message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) Decode(r io.Reader, pver uint32) error <span class="cov10" title="5">{
        return ReadElements(r, &amp;c.ChannelID, &amp;c.FeeSatoshis, &amp;c.Signature)
}</span>

// Encode serializes the target ClosingSigned into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, c.ChannelID, c.FeeSatoshis, c.Signature)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) MsgType() MessageType <span class="cov1" title="1">{
        return MsgClosingSigned
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// ClosingSigned complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) MaxPayloadLength(uint32) uint32 <span class="cov10" title="5">{
        var length uint32

        // ChannelID - 32 bytes
        length += 32

        // FeeSatoshis - 8 bytes
        length += 8

        // Signature - 64 bytes
        length += 64

        return length
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package lnwire

import (
        "io"
)

// CommitSig is sent by either side to stage any pending HTLC's in the
// receiver's pending set into a new commitment state.  Implicitly, the new
// commitment transaction constructed which has been signed by CommitSig
// includes all HTLC's in the remote node's pending set. A CommitSig message
// may be sent after a series of UpdateAddHTLC/UpdateFulfillHTLC messages in
// order to batch add several HTLC's with a single signature covering all
// implicitly accepted HTLC's.
type CommitSig struct {
        // ChanID uniquely identifies to which currently active channel this
        // CommitSig applies to.
        ChanID ChannelID

        // CommitSig is Alice's signature for Bob's new commitment transaction.
        // Alice is able to send this signature without requesting any
        // additional data due to the piggybacking of Bob's next revocation
        // hash in his prior RevokeAndAck message, as well as the canonical
        // ordering used for all inputs/outputs within commitment transactions.
        // If initiating a new commitment state, this signature should ONLY
        // cover all of the sending party's pending log updates, and the log
        // updates of the remote party that have been ACK'd.
        CommitSig Sig

        // HtlcSigs is a signature for each relevant HTLC output within the
        // created commitment. The order of the signatures is expected to be
        // identical to the placement of the HTLC's within the BIP 69 sorted
        // commitment transaction. For each outgoing HTLC (from the PoV of the
        // sender of this message), a signature for an HTLC timeout transaction
        // should be signed, for each incoming HTLC the HTLC timeout
        // transaction should be signed.
        HtlcSigs []Sig
}

// NewCommitSig creates a new empty CommitSig message.
func NewCommitSig() *CommitSig <span class="cov0" title="0">{
        return &amp;CommitSig{}
}</span>

// A compile time check to ensure CommitSig implements the lnwire.Message
// interface.
var _ Message = (*CommitSig)(nil)

// Decode deserializes a serialized CommitSig message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) Decode(r io.Reader, pver uint32) error <span class="cov10" title="9">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.CommitSig,
                &amp;c.HtlcSigs,
        )
}</span>

// Encode serializes the target CommitSig into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) Encode(w io.Writer, pver uint32) error <span class="cov5" title="3">{
        return WriteElements(w,
                c.ChanID,
                c.CommitSig,
                c.HtlcSigs,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) MsgType() MessageType <span class="cov5" title="3">{
        return MsgCommitSig
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// CommitSig complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) MaxPayloadLength(uint32) uint32 <span class="cov10" title="9">{
        // 32 + 64 + 2 + max_allowed_htlcs
        return MaxMessagePayload
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *CommitSig) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package lnwire

import (
        "fmt"
        "io"
)

// FundingError represents a set of errors that can be encountered and sent
// during the funding workflow.
type FundingError uint8

const (
        // ErrMaxPendingChannels is returned by remote peer when the number of
        // active pending channels exceeds their maximum policy limit.
        ErrMaxPendingChannels FundingError = 1

        // ErrSynchronizingChain is returned by a remote peer that receives a
        // channel update or a funding request while their still syncing to the
        // latest state of the blockchain.
        ErrSynchronizingChain FundingError = 2

        // ErrChanTooLarge is returned by a remote peer that receives a
        // FundingOpen request for a channel that is above their current
        // soft-limit.
        ErrChanTooLarge FundingError = 3
)

// String returns a human readable version of the target FundingError.
func (e FundingError) String() string <span class="cov0" title="0">{
        switch e </span>{
        case ErrMaxPendingChannels:<span class="cov0" title="0">
                return "Number of pending channels exceed maximum"</span>
        case ErrSynchronizingChain:<span class="cov0" title="0">
                return "Synchronizing blockchain"</span>
        case ErrChanTooLarge:<span class="cov0" title="0">
                return "channel too large"</span>
        default:<span class="cov0" title="0">
                return "unknown error"</span>
        }
}

// Error returns the human redable version of the target FundingError.
//
// NOTE: Satisfies the Error interface.
func (e FundingError) Error() string <span class="cov0" title="0">{
        return e.String()
}</span>

// ErrorData is a set of bytes associated with a particular sent error. A
// receiving node SHOULD only print out data verbatim if the string is composed
// solely of printable ASCII characters. For reference, the printable character
// set includes byte values 32 through 127 inclusive.
type ErrorData []byte

// Error represents a generic error bound to an exact channel. The message
// format is purposefully general in order to allow expression of a wide array
// of possible errors. Each Error message is directed at a particular open
// channel referenced by ChannelPoint.
type Error struct {
        // ChanID references the active channel in which the error occurred
        // within. If the ChanID is all zeros, then this error applies to the
        // entire established connection.
        ChanID ChannelID

        // Data is the attached error data that describes the exact failure
        // which caused the error message to be sent.
        Data ErrorData
}

// NewError creates a new Error message.
func NewError() *Error <span class="cov0" title="0">{
        return &amp;Error{}
}</span>

// A compile time check to ensure Error implements the lnwire.Message
// interface.
var _ Message = (*Error)(nil)

// Error returns the string representation to Error.
//
// NOTE: Satisfies the error interface.
func (c *Error) Error() string <span class="cov0" title="0">{
        errMsg := "non-ascii data"
        if isASCII(c.Data) </span><span class="cov0" title="0">{
                errMsg = string(c.Data)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("chan_id=%v, err=%v", c.ChanID, errMsg)</span>
}

// Decode deserializes a serialized Error message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *Error) Decode(r io.Reader, pver uint32) error <span class="cov10" title="13">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.Data,
        )
}</span>

// Encode serializes the target Error into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *Error) Encode(w io.Writer, pver uint32) error <span class="cov6" title="5">{
        return WriteElements(w,
                c.ChanID,
                c.Data,
        )
}</span>

// MsgType returns the integer uniquely identifying an Error message on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *Error) MsgType() MessageType <span class="cov6" title="5">{
        return MsgError
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an Error
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *Error) MaxPayloadLength(uint32) uint32 <span class="cov10" title="13">{
        // 32 + 2 + 65501
        return 65535
}</span>

// isASCII is a helper method that checks whether all bytes in `data` would be
// printable ASCII characters if interpreted as a string.
func isASCII(data []byte) bool <span class="cov0" title="0">{
        for _, c := range data </span><span class="cov0" title="0">{
                if c &lt; 32 || c &gt; 126 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package lnwire

import (
        "encoding/binary"
        "errors"
        "io"
)

var (
        // ErrFeaturePairExists signals an error in feature vector construction
        // where the opposing bit in a feature pair has already been set.
        ErrFeaturePairExists = errors.New("feature pair exists")
)

// FeatureBit represents a feature that can be enabled in either a local or
// global feature vector at a specific bit position. Feature bits follow the
// "it's OK to be odd" rule, where features at even bit positions must be known
// to a node receiving them from a peer while odd bits do not. In accordance,
// feature bits are usually assigned in pairs, first being assigned an odd bit
// position which may later be changed to the preceding even position once
// knowledge of the feature becomes required on the network.
type FeatureBit uint16

const (
        // DataLossProtectRequired is a feature bit that indicates that a peer
        // *requires* the other party know about the data-loss-protect optional
        // feature. If the remote peer does not know of such a feature, then
        // the sending peer SHOLUD disconnect them. The data-loss-protect
        // feature allows a peer that's lost partial data to recover their
        // settled funds of the latest commitment state.
        DataLossProtectRequired FeatureBit = 0

        // DataLossProtectOptional is an optional feature bit that indicates
        // that the sending peer knows of this new feature and can activate it
        // it. The data-loss-protect feature allows a peer that's lost partial
        // data to recover their settled funds of the latest commitment state.
        DataLossProtectOptional FeatureBit = 1

        // InitialRoutingSync is a local feature bit meaning that the receiving
        // node should send a complete dump of routing information when a new
        // connection is established.
        InitialRoutingSync FeatureBit = 3

        // UpfrontShutdownScriptRequired is a feature bit which indicates that a
        // peer *requires* that the remote peer accept an upfront shutdown script to
        // which payout is enforced on cooperative closes.
        UpfrontShutdownScriptRequired FeatureBit = 4

        // UpfrontShutdownScriptOptional is an optional feature bit which indicates
        // that the peer will accept an upfront shutdown script to which payout is
        // enforced on cooperative closes.
        UpfrontShutdownScriptOptional FeatureBit = 5

        // GossipQueriesRequired is a feature bit that indicates that the
        // receiving peer MUST know of the set of features that allows nodes to
        // more efficiently query the network view of peers on the network for
        // reconciliation purposes.
        GossipQueriesRequired FeatureBit = 6

        // GossipQueriesOptional is an optional feature bit that signals that
        // the setting peer knows of the set of features that allows more
        // efficient network view reconciliation.
        GossipQueriesOptional FeatureBit = 7

        // TLVOnionPayloadRequired is a feature bit that indicates a node is
        // able to decode the new TLV information included in the onion packet.
        TLVOnionPayloadRequired FeatureBit = 8

        // TLVOnionPayloadRequired is an optional feature bit that indicates a
        // node is able to decode the new TLV information included in the onion
        // packet.
        TLVOnionPayloadOptional FeatureBit = 9

        // StaticRemoteKeyRequired is a required feature bit that signals that
        // within one's commitment transaction, the key used for the remote
        // party's non-delay output should not be tweaked.
        StaticRemoteKeyRequired FeatureBit = 12

        // StaticRemoteKeyOptional is an optional feature bit that signals that
        // within one's commitment transaction, the key used for the remote
        // party's non-delay output should not be tweaked.
        StaticRemoteKeyOptional FeatureBit = 13

        // PaymentAddrRequired is a required feature bit that signals that a
        // node requires payment addresses, which are used to mitigate probing
        // attacks on the receiver of a payment.
        PaymentAddrRequired FeatureBit = 14

        // PaymentAddrOptional is an optional feature bit that signals that a
        // node supports payment addresses, which are used to mitigate probing
        // attacks on the receiver of a payment.
        PaymentAddrOptional FeatureBit = 15

        // MPPOptional is a required feature bit that signals that the receiver
        // of a payment requires settlement of an invoice with more than one
        // HTLC.
        MPPRequired FeatureBit = 16

        // MPPOptional is an optional feature bit that signals that the receiver
        // of a payment supports settlement of an invoice with more than one
        // HTLC.
        MPPOptional FeatureBit = 17

        // maxAllowedSize is a maximum allowed size of feature vector.
        //
        // NOTE: Within the protocol, the maximum allowed message size is 65535
        // bytes for all messages. Accounting for the overhead within the feature
        // message to signal the type of message, that leaves us with 65533 bytes
        // for the init message itself.  Next, we reserve 4 bytes to encode the
        // lengths of both the local and global feature vectors, so 65529 bytes
        // for the local and global features.  Knocking off one byte for the sake
        // of the calculation, that leads us to 32764 bytes for each feature
        // vector, or 131056 different features.
        maxAllowedSize = 32764
)

// IsRequired returns true if the feature bit is even, and false otherwise.
func (b FeatureBit) IsRequired() bool <span class="cov0" title="0">{
        return b&amp;0x01 == 0x00
}</span>

// Features is a mapping of known feature bits to a descriptive name. All known
// feature bits must be assigned a name in this mapping, and feature bit pairs
// must be assigned together for correct behavior.
var Features = map[FeatureBit]string{
        DataLossProtectRequired:       "data-loss-protect",
        DataLossProtectOptional:       "data-loss-protect",
        InitialRoutingSync:            "initial-routing-sync",
        UpfrontShutdownScriptRequired: "upfront-shutdown-script",
        UpfrontShutdownScriptOptional: "upfront-shutdown-script",
        GossipQueriesRequired:         "gossip-queries",
        GossipQueriesOptional:         "gossip-queries",
        TLVOnionPayloadRequired:       "tlv-onion",
        TLVOnionPayloadOptional:       "tlv-onion",
        StaticRemoteKeyOptional:       "static-remote-key",
        StaticRemoteKeyRequired:       "static-remote-key",
        PaymentAddrOptional:           "payment-addr",
        PaymentAddrRequired:           "payment-addr",
        MPPOptional:                   "multi-path-payments",
        MPPRequired:                   "multi-path-payments",
}

// RawFeatureVector represents a set of feature bits as defined in BOLT-09.  A
// RawFeatureVector itself just stores a set of bit flags but can be used to
// construct a FeatureVector which binds meaning to each bit. Feature vectors
// can be serialized and deserialized to/from a byte representation that is
// transmitted in Lightning network messages.
type RawFeatureVector struct {
        features map[FeatureBit]bool
}

// NewRawFeatureVector creates a feature vector with all of the feature bits
// given as arguments enabled.
func NewRawFeatureVector(bits ...FeatureBit) *RawFeatureVector <span class="cov4" title="141">{
        fv := &amp;RawFeatureVector{features: make(map[FeatureBit]bool)}
        for _, bit := range bits </span><span class="cov0" title="0">{
                fv.Set(bit)
        }</span>
        <span class="cov4" title="141">return fv</span>
}

// Merges sets all feature bits in other on the receiver's feature vector.
func (fv *RawFeatureVector) Merge(other *RawFeatureVector) error <span class="cov0" title="0">{
        for bit := range other.features </span><span class="cov0" title="0">{
                err := fv.SafeSet(bit)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Clone makes a copy of a feature vector.
func (fv *RawFeatureVector) Clone() *RawFeatureVector <span class="cov0" title="0">{
        newFeatures := NewRawFeatureVector()
        for bit := range fv.features </span><span class="cov0" title="0">{
                newFeatures.Set(bit)
        }</span>
        <span class="cov0" title="0">return newFeatures</span>
}

// IsSet returns whether a particular feature bit is enabled in the vector.
func (fv *RawFeatureVector) IsSet(feature FeatureBit) bool <span class="cov0" title="0">{
        return fv.features[feature]
}</span>

// Set marks a feature as enabled in the vector.
func (fv *RawFeatureVector) Set(feature FeatureBit) <span class="cov9" title="426670">{
        fv.features[feature] = true
}</span>

// SafeSet sets the chosen feature bit in the feature vector, but returns an
// error if the opposing feature bit is already set. This ensures both that we
// are creating properly structured feature vectors, and in some cases, that
// peers are sending properly encoded ones, i.e. it can't be both optional and
// required.
func (fv *RawFeatureVector) SafeSet(feature FeatureBit) error <span class="cov0" title="0">{
        if _, ok := fv.features[feature^1]; ok </span><span class="cov0" title="0">{
                return ErrFeaturePairExists
        }</span>

        <span class="cov0" title="0">fv.Set(feature)
        return nil</span>
}

// Unset marks a feature as disabled in the vector.
func (fv *RawFeatureVector) Unset(feature FeatureBit) <span class="cov0" title="0">{
        delete(fv.features, feature)
}</span>

// SerializeSize returns the number of bytes needed to represent feature vector
// in byte format.
func (fv *RawFeatureVector) SerializeSize() int <span class="cov3" title="45">{
        // We calculate byte-length via the largest bit index.
        return fv.serializeSize(8)
}</span>

// SerializeSize32 returns the number of bytes needed to represent feature
// vector in base32 format.
func (fv *RawFeatureVector) SerializeSize32() int <span class="cov0" title="0">{
        // We calculate base32-length via the largest bit index.
        return fv.serializeSize(5)
}</span>

// serializeSize returns the number of bytes required to encode the feature
// vector using at most width bits per encoded byte.
func (fv *RawFeatureVector) serializeSize(width int) int <span class="cov3" title="45">{
        // Find the largest feature bit index
        max := -1
        for feature := range fv.features </span><span class="cov8" title="146552">{
                index := int(feature)
                if index &gt; max </span><span class="cov4" title="406">{
                        max = index
                }</span>
        }
        <span class="cov3" title="45">if max == -1 </span><span class="cov1" title="3">{
                return 0
        }</span>

        <span class="cov3" title="42">return max/width + 1</span>
}

// Encode writes the feature vector in byte representation. Every feature
// encoded as a bit, and the bit vector is serialized using the least number of
// bytes. Since the bit vector length is variable, the first two bytes of the
// serialization represent the length.
func (fv *RawFeatureVector) Encode(w io.Writer) error <span class="cov3" title="45">{
        // Write length of feature vector.
        var l [2]byte
        length := fv.SerializeSize()
        binary.BigEndian.PutUint16(l[:], uint16(length))
        if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="45">return fv.encode(w, length, 8)</span>
}

// EncodeBase256 writes the feature vector in base256 representation. Every
// feature is encoded as a bit, and the bit vector is serialized using the least
// number of bytes.
func (fv *RawFeatureVector) EncodeBase256(w io.Writer) error <span class="cov0" title="0">{
        length := fv.SerializeSize()
        return fv.encode(w, length, 8)
}</span>

// EncodeBase32 writes the feature vector in base32 representation. Every feature
// is encoded as a bit, and the bit vector is serialized using the least number of
// bytes.
func (fv *RawFeatureVector) EncodeBase32(w io.Writer) error <span class="cov0" title="0">{
        length := fv.SerializeSize32()
        return fv.encode(w, length, 5)
}</span>

// encode writes the feature vector
func (fv *RawFeatureVector) encode(w io.Writer, length, width int) error <span class="cov3" title="45">{
        // Generate the data and write it.
        data := make([]byte, length)
        for feature := range fv.features </span><span class="cov8" title="146552">{
                byteIndex := int(feature) / width
                bitIndex := int(feature) % width
                data[length-byteIndex-1] |= 1 &lt;&lt; uint(bitIndex)
        }</span>

        <span class="cov3" title="45">_, err := w.Write(data)
        return err</span>
}

// Decode reads the feature vector from its byte representation. Every feature
// is encoded as a bit, and the bit vector is serialized using the least number
// of bytes. Since the bit vector length is variable, the first two bytes of the
// serialization represent the length.
func (fv *RawFeatureVector) Decode(r io.Reader) error <span class="cov4" title="141">{
        // Read the length of the feature vector.
        var l [2]byte
        if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov1" title="3">{
                return err
        }</span>
        <span class="cov4" title="138">length := binary.BigEndian.Uint16(l[:])

        return fv.decode(r, int(length), 8)</span>
}

// DecodeBase256 reads the feature vector from its base256 representation. Every
// feature encoded as a bit, and the bit vector is serialized using the least
// number of bytes.
func (fv *RawFeatureVector) DecodeBase256(r io.Reader, length int) error <span class="cov0" title="0">{
        return fv.decode(r, length, 8)
}</span>

// DecodeBase32 reads the feature vector from its base32 representation. Every
// feature encoded as a bit, and the bit vector is serialized using the least
// number of bytes.
func (fv *RawFeatureVector) DecodeBase32(r io.Reader, length int) error <span class="cov0" title="0">{
        return fv.decode(r, length, 5)
}</span>

// decode reads a feature vector from the next length bytes of the io.Reader,
// assuming each byte has width feature bits encoded per byte.
func (fv *RawFeatureVector) decode(r io.Reader, length, width int) error <span class="cov4" title="138">{
        // Read the feature vector data.
        data := make([]byte, length)
        if _, err := io.ReadFull(r, data); err != nil </span><span class="cov1" title="3">{
                return err
        }</span>

        // Set feature bits from parsed data.
        <span class="cov4" title="135">bitsNumber := len(data) * width
        for i := 0; i &lt; bitsNumber; i++ </span><span class="cov10" title="857432">{
                byteIndex := int(i / width)
                bitIndex := uint(i % width)
                if (data[length-byteIndex-1]&gt;&gt;bitIndex)&amp;1 == 1 </span><span class="cov9" title="426670">{
                        fv.Set(FeatureBit(i))
                }</span>
        }

        <span class="cov4" title="135">return nil</span>
}

// FeatureVector represents a set of enabled features. The set stores
// information on enabled flags and metadata about the feature names. A feature
// vector is serializable to a compact byte representation that is included in
// Lightning network messages.
type FeatureVector struct {
        *RawFeatureVector
        featureNames map[FeatureBit]string
}

// NewFeatureVector constructs a new FeatureVector from a raw feature vector
// and mapping of feature definitions. If the feature vector argument is nil, a
// new one will be constructed with no enabled features.
func NewFeatureVector(featureVector *RawFeatureVector,
        featureNames map[FeatureBit]string) *FeatureVector <span class="cov0" title="0">{

        if featureVector == nil </span><span class="cov0" title="0">{
                featureVector = NewRawFeatureVector()
        }</span>
        <span class="cov0" title="0">return &amp;FeatureVector{
                RawFeatureVector: featureVector,
                featureNames:     featureNames,
        }</span>
}

// EmptyFeatureVector returns a feature vector with no bits set.
func EmptyFeatureVector() *FeatureVector <span class="cov0" title="0">{
        return NewFeatureVector(nil, Features)
}</span>

// HasFeature returns whether a particular feature is included in the set. The
// feature can be seen as set either if the bit is set directly OR the queried
// bit has the same meaning as its corresponding even/odd bit, which is set
// instead. The second case is because feature bits are generally assigned in
// pairs where both the even and odd position represent the same feature.
func (fv *FeatureVector) HasFeature(feature FeatureBit) bool <span class="cov0" title="0">{
        return fv.IsSet(feature) ||
                (fv.isFeatureBitPair(feature) &amp;&amp; fv.IsSet(feature^1))
}</span>

// UnknownRequiredFeatures returns a list of feature bits set in the vector
// that are unknown and in an even bit position. Feature bits with an even
// index must be known to a node receiving the feature vector in a message.
func (fv *FeatureVector) UnknownRequiredFeatures() []FeatureBit <span class="cov0" title="0">{
        var unknown []FeatureBit
        for feature := range fv.features </span><span class="cov0" title="0">{
                if feature%2 == 0 &amp;&amp; !fv.IsKnown(feature) </span><span class="cov0" title="0">{
                        unknown = append(unknown, feature)
                }</span>
        }
        <span class="cov0" title="0">return unknown</span>
}

// Name returns a string identifier for the feature represented by this bit. If
// the bit does not represent a known feature, this returns a string indicating
// as much.
func (fv *FeatureVector) Name(bit FeatureBit) string <span class="cov0" title="0">{
        name, known := fv.featureNames[bit]
        if !known </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return name</span>
}

// IsKnown returns whether this feature bit represents a known feature.
func (fv *FeatureVector) IsKnown(bit FeatureBit) bool <span class="cov0" title="0">{
        _, known := fv.featureNames[bit]
        return known
}</span>

// isFeatureBitPair returns whether this feature bit and its corresponding
// even/odd bit both represent the same feature. This may often be the case as
// bits are generally assigned in pairs, first being assigned an odd bit
// position then being promoted to an even bit position once the network is
// ready.
func (fv *FeatureVector) isFeatureBitPair(bit FeatureBit) bool <span class="cov0" title="0">{
        name1, known1 := fv.featureNames[bit]
        name2, known2 := fv.featureNames[bit^1]
        return known1 &amp;&amp; known2 &amp;&amp; name1 == name2
}</span>

// Features returns the set of raw features contained in the feature vector.
func (fv *FeatureVector) Features() map[FeatureBit]struct{} <span class="cov0" title="0">{
        fs := make(map[FeatureBit]struct{}, len(fv.RawFeatureVector.features))
        for b := range fv.RawFeatureVector.features </span><span class="cov0" title="0">{
                fs[b] = struct{}{}
        }</span>
        <span class="cov0" title="0">return fs</span>
}

// Clone copies a feature vector, carrying over its feature bits. The feature
// names are not copied.
func (fv *FeatureVector) Clone() *FeatureVector <span class="cov0" title="0">{
        features := fv.RawFeatureVector.Clone()
        return NewFeatureVector(features, fv.featureNames)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/wire"
)

// FundingCreated is sent from Alice (the initiator) to Bob (the responder),
// once Alice receives Bob's contributions as well as his channel constraints.
// Once bob receives this message, he'll gain access to an immediately
// broadcastable commitment transaction and will reply with a signature for
// Alice's version of the commitment transaction.
type FundingCreated struct {
        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // FundingPoint is the outpoint of the funding transaction created by
        // Alice. With this, Bob is able to generate both his version and
        // Alice's version of the commitment transaction.
        FundingPoint wire.OutPoint

        // CommitSig is Alice's signature from Bob's version of the commitment
        // transaction.
        CommitSig Sig
}

// A compile time check to ensure FundingCreated implements the lnwire.Message
// interface.
var _ Message = (*FundingCreated)(nil)

// Encode serializes the target FundingCreated into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, f.PendingChannelID[:], f.FundingPoint, f.CommitSig)
}</span>

// Decode deserializes the serialized FundingCreated stored in the passed
// io.Reader into the target FundingCreated using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) Decode(r io.Reader, pver uint32) error <span class="cov10" title="6">{
        return ReadElements(r, f.PendingChannelID[:], &amp;f.FundingPoint, &amp;f.CommitSig)
}</span>

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingCreated on the wire.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) MsgType() MessageType <span class="cov1" title="1">{
        return MsgFundingCreated
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// FundingCreated message.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) MaxPayloadLength(uint32) uint32 <span class="cov10" title="6">{
        // 32 + 32 + 2 + 64
        return 130
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
)

// FundingLocked is the message that both parties to a new channel creation
// send once they have observed the funding transaction being confirmed on the
// blockchain. FundingLocked contains the signatures necessary for the channel
// participants to advertise the existence of the channel to the rest of the
// network.
type FundingLocked struct {
        // ChanID is the outpoint of the channel's funding transaction. This
        // can be used to query for the channel in the database.
        ChanID ChannelID

        // NextPerCommitmentPoint is the secret that can be used to revoke the
        // next commitment transaction for the channel.
        NextPerCommitmentPoint *btcec.PublicKey
}

// NewFundingLocked creates a new FundingLocked message, populating it with the
// necessary IDs and revocation secret.
func NewFundingLocked(cid ChannelID, npcp *btcec.PublicKey) *FundingLocked <span class="cov0" title="0">{
        return &amp;FundingLocked{
                ChanID:                 cid,
                NextPerCommitmentPoint: npcp,
        }
}</span>

// A compile time check to ensure FundingLocked implements the lnwire.Message
// interface.
var _ Message = (*FundingLocked)(nil)

// Decode deserializes the serialized FundingLocked message stored in the
// passed io.Reader into the target FundingLocked using the deserialization
// rules defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) Decode(r io.Reader, pver uint32) error <span class="cov10" title="32">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.NextPerCommitmentPoint)
}</span>

// Encode serializes the target FundingLocked message into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) Encode(w io.Writer, pver uint32) error <span class="cov7" title="12">{
        return WriteElements(w,
                c.ChanID,
                c.NextPerCommitmentPoint)
}</span>

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingLocked message on the wire.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) MsgType() MessageType <span class="cov7" title="12">{
        return MsgFundingLocked
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// FundingLocked message. This is calculated by summing the max length of all
// the fields within a FundingLocked message.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) MaxPayloadLength(uint32) uint32 <span class="cov10" title="32">{
        var length uint32

        // ChanID - 32 bytes
        length += 32

        // NextPerCommitmentPoint - 33 bytes
        length += 33

        // 65 bytes
        return length
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package lnwire

import "io"

// FundingSigned is sent from Bob (the responder) to Alice (the initiator)
// after receiving the funding outpoint and her signature for Bob's version of
// the commitment transaction.
type FundingSigned struct {
        // ChannelPoint is the particular active channel that this
        // FundingSigned is bound to.
        ChanID ChannelID

        // CommitSig is Bob's signature for Alice's version of the commitment
        // transaction.
        CommitSig Sig
}

// A compile time check to ensure FundingSigned implements the lnwire.Message
// interface.
var _ Message = (*FundingSigned)(nil)

// Encode serializes the target FundingSigned into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, f.ChanID, f.CommitSig)
}</span>

// Decode deserializes the serialized FundingSigned stored in the passed
// io.Reader into the target FundingSigned using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        return ReadElements(r, &amp;f.ChanID, &amp;f.CommitSig)
}</span>

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingSigned on the wire.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) MsgType() MessageType <span class="cov1" title="1">{
        return MsgFundingSigned
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// FundingSigned message.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) MaxPayloadLength(uint32) uint32 <span class="cov10" title="4">{
        // 32 + 64
        return 96
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// GossipTimestampRange is a message that allows the sender to restrict the set
// of future gossip announcements sent by the receiver. Nodes should send this
// if they have the gossip-queries feature bit active. Nodes are able to send
// new GossipTimestampRange messages to replace the prior window.
type GossipTimestampRange struct {
        // ChainHash denotes the chain that the sender wishes to restrict the
        // set of received announcements of.
        ChainHash chainhash.Hash

        // FirstTimestamp is the timestamp of the earliest announcement message
        // that should be sent by the receiver.
        FirstTimestamp uint32

        // TimestampRange is the horizon beyond the FirstTimestamp that any
        // announcement messages should be sent for. The receiving node MUST
        // NOT send any announcements that have a timestamp greater than
        // FirstTimestamp + TimestampRange.
        TimestampRange uint32
}

// NewGossipTimestampRange creates a new empty GossipTimestampRange message.
func NewGossipTimestampRange() *GossipTimestampRange <span class="cov0" title="0">{
        return &amp;GossipTimestampRange{}
}</span>

// A compile time check to ensure GossipTimestampRange implements the
// lnwire.Message interface.
var _ Message = (*GossipTimestampRange)(nil)

// Decode deserializes a serialized GossipTimestampRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        return ReadElements(r,
                g.ChainHash[:],
                &amp;g.FirstTimestamp,
                &amp;g.TimestampRange,
        )
}</span>

// Encode serializes the target GossipTimestampRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                g.ChainHash[:],
                g.FirstTimestamp,
                g.TimestampRange,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) MsgType() MessageType <span class="cov1" title="1">{
        return MsgGossipTimestampRange
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// GossipTimestampRange complete message observing the specified protocol
// version.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) MaxPayloadLength(uint32) uint32 <span class="cov10" title="4">{
        // 32 + 4 + 4
        //
        // TODO(roasbeef): update to 8 byte timestmaps?
        return 40
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package lnwire

import "io"

// Init is the first message reveals the features supported or required by this
// node. Nodes wait for receipt of the other's features to simplify error
// diagnosis where features are incompatible. Each node MUST wait to receive
// init before sending any other messages.
type Init struct {
        // GlobalFeatures is a legacy feature vector used for backwards
        // compatibility with older nodes. Any features defined here should be
        // merged with those presented in Features.
        GlobalFeatures *RawFeatureVector

        // Features is a feature vector containing a the features supported by
        // the remote node.
        //
        // NOTE: Older nodes may place some features in GlobalFeatures, but all
        // new features are to be added in Features. When handling an Init
        // message, any GlobalFeatures should be merged into the unified
        // Features field.
        Features *RawFeatureVector
}

// NewInitMessage creates new instance of init message object.
func NewInitMessage(gf *RawFeatureVector, f *RawFeatureVector) *Init <span class="cov0" title="0">{
        return &amp;Init{
                GlobalFeatures: gf,
                Features:       f,
        }
}</span>

// A compile time check to ensure Init implements the lnwire.Message
// interface.
var _ Message = (*Init)(nil)

// Decode deserializes a serialized Init message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (msg *Init) Decode(r io.Reader, pver uint32) error <span class="cov10" title="10">{
        return ReadElements(r,
                &amp;msg.GlobalFeatures,
                &amp;msg.Features,
        )
}</span>

// Encode serializes the target Init into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (msg *Init) Encode(w io.Writer, pver uint32) error <span class="cov6" title="4">{
        return WriteElements(w,
                msg.GlobalFeatures,
                msg.Features,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (msg *Init) MsgType() MessageType <span class="cov6" title="4">{
        return MsgInit
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an Init
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (msg *Init) MaxPayloadLength(uint32) uint32 <span class="cov10" title="10">{
        return 2 + 2 + maxAllowedSize + 2 + maxAllowedSize
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: block;">package lnwire

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "image/color"
        "io"
        "math"

        "net"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
        "github.com/btcsuite/btcutil"
        "github.com/go-errors/errors"
        "github.com/lightningnetwork/lnd/tor"
)

// MaxSliceLength is the maximum allowed length for any opaque byte slices in
// the wire protocol.
const MaxSliceLength = 65535

// PkScript is simple type definition which represents a raw serialized public
// key script.
type PkScript []byte

// addressType specifies the network protocol and version that should be used
// when connecting to a node at a particular address.
type addressType uint8

const (
        // noAddr denotes a blank address. An address of this type indicates
        // that a node doesn't have any advertised addresses.
        noAddr addressType = 0

        // tcp4Addr denotes an IPv4 TCP address.
        tcp4Addr addressType = 1

        // tcp6Addr denotes an IPv6 TCP address.
        tcp6Addr addressType = 2

        // v2OnionAddr denotes a version 2 Tor onion service address.
        v2OnionAddr addressType = 3

        // v3OnionAddr denotes a version 3 Tor (prop224) onion service address.
        v3OnionAddr addressType = 4
)

// AddrLen returns the number of bytes that it takes to encode the target
// address.
func (a addressType) AddrLen() uint16 <span class="cov5" title="135">{
        switch a </span>{
        case noAddr:<span class="cov3" title="30">
                return 0</span>
        case tcp4Addr:<span class="cov3" title="36">
                return 6</span>
        case tcp6Addr:<span class="cov3" title="29">
                return 18</span>
        case v2OnionAddr:<span class="cov2" title="4">
                return 12</span>
        case v3OnionAddr:<span class="cov3" title="36">
                return 37</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// WriteElement is a one-stop shop to write the big endian representation of
// any element which is to be serialized for the wire protocol. The passed
// io.Writer should be backed by an appropriately sized byte slice, or be able
// to dynamically expand to accommodate additional data.
//
// TODO(roasbeef): this should eventually draw from a buffer pool for
// serialization.
func WriteElement(w io.Writer, element interface{}) error <span class="cov9" title="26732">{
        switch e := element.(type) </span>{
        case NodeAlias:<span class="cov3" title="25">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ShortChanIDEncoding:<span class="cov6" title="561">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint8:<span class="cov5" title="361">
                var b [1]byte
                b[0] = e
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case FundingFlag:<span class="cov3" title="26">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint16:<span class="cov6" title="708">
                var b [2]byte
                binary.BigEndian.PutUint16(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ChanUpdateMsgFlags:<span class="cov2" title="10">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ChanUpdateChanFlags:<span class="cov2" title="10">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case MilliSatoshi:<span class="cov5" title="147">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], uint64(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case btcutil.Amount:<span class="cov5" title="133">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], uint64(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint32:<span class="cov6" title="684">
                var b [4]byte
                binary.BigEndian.PutUint32(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint64:<span class="cov3" title="33">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *btcec.PublicKey:<span class="cov5" title="354">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil pubkey")
                }</span>

                <span class="cov5" title="354">var b [33]byte
                serializedPubkey := e.SerializeCompressed()
                copy(b[:], serializedPubkey)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case []Sig:<span class="cov1" title="3">
                var b [2]byte
                numSigs := uint16(len(e))
                binary.BigEndian.PutUint16(b[:], numSigs)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="3">for _, sig := range e </span><span class="cov6" title="555">{
                        if err := WriteElement(w, sig); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case Sig:<span class="cov6" title="662">
                // Write buffer
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case PingPayload:<span class="cov2" title="5">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="5">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case PongPayload:<span class="cov2" title="4">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="4">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ErrorData:<span class="cov2" title="5">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="5">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case OpaqueReason:<span class="cov2" title="4">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="4">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case [33]byte:<span class="cov4" title="73">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case []byte:<span class="cov6" title="750">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case PkScript:<span class="cov0" title="0">
                // The largest script we'll accept is a p2wsh which is exactly
                // 34 bytes long.
                scriptLength := len(e)
                if scriptLength &gt; 34 </span><span class="cov0" title="0">{
                        return fmt.Errorf("'PkScript' too long")
                }</span>

                <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *RawFeatureVector:<span class="cov4" title="45">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil feature vector")
                }</span>

                <span class="cov4" title="45">if err := e.Encode(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case wire.OutPoint:<span class="cov1" title="1">
                var h [32]byte
                copy(h[:], e.Hash[:])
                if _, err := w.Write(h[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if e.Index &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                        return fmt.Errorf("index for outpoint (%v) is "+
                                "greater than max index of %v", e.Index,
                                math.MaxUint16)
                }</span>

                <span class="cov1" title="1">var idx [2]byte
                binary.BigEndian.PutUint16(idx[:], uint16(e.Index))
                if _, err := w.Write(idx[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ChannelID:<span class="cov4" title="71">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case FailCode:<span class="cov1" title="1">
                if err := WriteElement(w, uint16(e)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ShortChannelID:<span class="cov9" title="21897">
                // Check that field fit in 3 bytes and write the blockHeight
                if e.BlockHeight &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                        return errors.New("block height should fit in 3 bytes")
                }</span>

                <span class="cov9" title="21897">var blockHeight [4]byte
                binary.BigEndian.PutUint32(blockHeight[:], e.BlockHeight)

                if _, err := w.Write(blockHeight[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check that field fit in 3 bytes and write the txIndex
                <span class="cov9" title="21897">if e.TxIndex &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                        return errors.New("tx index should fit in 3 bytes")
                }</span>

                <span class="cov9" title="21897">var txIndex [4]byte
                binary.BigEndian.PutUint32(txIndex[:], e.TxIndex)
                if _, err := w.Write(txIndex[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write the txPosition
                <span class="cov9" title="21897">var txPosition [2]byte
                binary.BigEndian.PutUint16(txPosition[:], e.TxPosition)
                if _, err := w.Write(txPosition[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *net.TCPAddr:<span class="cov3" title="31">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil TCPAddr")
                }</span>

                <span class="cov3" title="31">if e.IP.To4() != nil </span><span class="cov3" title="17">{
                        var descriptor [1]byte
                        descriptor[0] = uint8(tcp4Addr)
                        if _, err := w.Write(descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov3" title="17">var ip [4]byte
                        copy(ip[:], e.IP.To4())
                        if _, err := w.Write(ip[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov3" title="14"> {
                        var descriptor [1]byte
                        descriptor[0] = uint8(tcp6Addr)
                        if _, err := w.Write(descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="14">var ip [16]byte
                        copy(ip[:], e.IP.To16())
                        if _, err := w.Write(ip[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov3" title="31">var port [2]byte
                binary.BigEndian.PutUint16(port[:], uint16(e.Port))
                if _, err := w.Write(port[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *tor.OnionAddr:<span class="cov3" title="18">
                if e == nil </span><span class="cov0" title="0">{
                        return errors.New("cannot write nil onion address")
                }</span>

                <span class="cov3" title="18">var suffixIndex int
                switch len(e.OnionService) </span>{
                case tor.V2Len:<span class="cov1" title="2">
                        descriptor := []byte{byte(v2OnionAddr)}
                        if _, err := w.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov1" title="2">suffixIndex = tor.V2Len - tor.OnionSuffixLen</span>
                case tor.V3Len:<span class="cov3" title="16">
                        descriptor := []byte{byte(v3OnionAddr)}
                        if _, err := w.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="16">suffixIndex = tor.V3Len - tor.OnionSuffixLen</span>
                default:<span class="cov0" title="0">
                        return errors.New("unknown onion service length")</span>
                }

                <span class="cov3" title="18">host, err := tor.Base32Encoding.DecodeString(
                        e.OnionService[:suffixIndex],
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="18">if _, err := w.Write(host); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="18">var port [2]byte
                binary.BigEndian.PutUint16(port[:], uint16(e.Port))
                if _, err := w.Write(port[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case []net.Addr:<span class="cov3" title="25">
                // First, we'll encode all the addresses into an intermediate
                // buffer. We need to do this in order to compute the total
                // length of the addresses.
                var addrBuf bytes.Buffer
                for _, address := range e </span><span class="cov4" title="49">{
                        if err := WriteElement(&amp;addrBuf, address); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // With the addresses fully encoded, we can now write out the
                // number of bytes needed to encode them.
                <span class="cov3" title="25">addrLen := addrBuf.Len()
                if err := WriteElement(w, uint16(addrLen)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Finally, we'll write out the raw addresses themselves, but
                // only if we have any bytes to write.
                <span class="cov3" title="25">if addrLen &gt; 0 </span><span class="cov3" title="19">{
                        if _, err := w.Write(addrBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case color.RGBA:<span class="cov3" title="25">
                if err := WriteElements(w, e.R, e.G, e.B); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case DeliveryAddress:<span class="cov4" title="60">
                var length [2]byte
                binary.BigEndian.PutUint16(length[:], uint16(len(e)))
                if _, err := w.Write(length[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="60">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case bool:<span class="cov0" title="0">
                var b [1]byte
                if e </span><span class="cov0" title="0">{
                        b[0] = 1
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("Unknown type in WriteElement: %T", e)</span>
        }

        <span class="cov9" title="26732">return nil</span>
}

// WriteElements is writes each element in the elements slice to the passed
// io.Writer using WriteElement.
func WriteElements(w io.Writer, elements ...interface{}) error <span class="cov9" title="24073">{
        for _, element := range elements </span><span class="cov9" title="26102">{
                err := WriteElement(w, element)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov9" title="24073">return nil</span>
}

// ReadElement is a one-stop utility function to deserialize any datastructure
// encoded using the serialization format of lnwire.
func ReadElement(r io.Reader, element interface{}) error <span class="cov10" title="57298">{
        var err error
        switch e := element.(type) </span>{
        case *bool:<span class="cov0" title="0">
                var b [1]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if b[0] == 1 </span><span class="cov0" title="0">{
                        *e = true
                }</span>

        case *NodeAlias:<span class="cov4" title="86">
                var a [32]byte
                if _, err := io.ReadFull(r, a[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov4" title="85">alias, err := NewNodeAlias(string(a[:]))
                if err != nil </span><span class="cov3" title="19">{
                        return err
                }</span>

                <span class="cov4" title="66">*e = alias</span>
        case *ShortChanIDEncoding:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = ShortChanIDEncoding(b[0])</span>
        case *uint8:<span class="cov6" title="1057">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov1" title="3">{
                        return err
                }</span>
                <span class="cov6" title="1054">*e = b[0]</span>
        case *FundingFlag:<span class="cov4" title="54">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="53">*e = FundingFlag(b[0])</span>
        case *uint16:<span class="cov7" title="1813">
                var b [2]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov2" title="7">{
                        return err
                }</span>
                <span class="cov7" title="1806">*e = binary.BigEndian.Uint16(b[:])</span>
        case *ChanUpdateMsgFlags:<span class="cov3" title="24">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="23">*e = ChanUpdateMsgFlags(b[0])</span>
        case *ChanUpdateChanFlags:<span class="cov3" title="23">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="22">*e = ChanUpdateChanFlags(b[0])</span>
        case *uint32:<span class="cov7" title="1893">
                var b [4]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov2" title="9">{
                        return err
                }</span>
                <span class="cov7" title="1884">*e = binary.BigEndian.Uint32(b[:])</span>
        case *uint64:<span class="cov4" title="91">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov2" title="5">{
                        return err
                }</span>
                <span class="cov4" title="86">*e = binary.BigEndian.Uint64(b[:])</span>
        case *MilliSatoshi:<span class="cov5" title="355">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov2" title="4">{
                        return err
                }</span>
                <span class="cov5" title="351">*e = MilliSatoshi(int64(binary.BigEndian.Uint64(b[:])))</span>
        case *btcutil.Amount:<span class="cov5" title="326">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov1" title="3">{
                        return err
                }</span>
                <span class="cov5" title="323">*e = btcutil.Amount(int64(binary.BigEndian.Uint64(b[:])))</span>
        case **btcec.PublicKey:<span class="cov6" title="769">
                var b [btcec.PubKeyBytesLenCompressed]byte
                if _, err = io.ReadFull(r, b[:]); err != nil </span><span class="cov2" title="9">{
                        return err
                }</span>

                <span class="cov6" title="760">pubKey, err := btcec.ParsePubKey(b[:], btcec.S256())
                if err != nil </span><span class="cov3" title="24">{
                        return err
                }</span>
                <span class="cov6" title="736">*e = pubKey</span>
        case **RawFeatureVector:<span class="cov5" title="141">
                f := NewRawFeatureVector()
                err = f.Decode(r)
                if err != nil </span><span class="cov2" title="6">{
                        return err
                }</span>

                <span class="cov5" title="135">*e = f</span>

        case *[]Sig:<span class="cov2" title="8">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="7">numSigs := binary.BigEndian.Uint16(l[:])

                var sigs []Sig
                if numSigs &gt; 0 </span><span class="cov2" title="5">{
                        sigs = make([]Sig, numSigs)
                        for i := 0; i &lt; int(numSigs); i++ </span><span class="cov6" title="1111">{
                                if err := ReadElement(r, &amp;sigs[i]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov2" title="6">*e = sigs</span>

        case *Sig:<span class="cov6" title="1412">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov2" title="8">{
                        return err
                }</span>
        case *OpaqueReason:<span class="cov2" title="10">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="9">reasonLen := binary.BigEndian.Uint16(l[:])

                *e = OpaqueReason(make([]byte, reasonLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        case *ErrorData:<span class="cov3" title="12">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="11">errorLen := binary.BigEndian.Uint16(l[:])

                *e = ErrorData(make([]byte, errorLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        case *PingPayload:<span class="cov3" title="12">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="11">pingLen := binary.BigEndian.Uint16(l[:])

                *e = PingPayload(make([]byte, pingLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        case *PongPayload:<span class="cov2" title="10">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="9">pongLen := binary.BigEndian.Uint16(l[:])

                *e = PongPayload(make([]byte, pongLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        case *[33]byte:<span class="cov5" title="185">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov1" title="2">{
                        return err
                }</span>
        case []byte:<span class="cov7" title="1851">
                if _, err := io.ReadFull(r, e); err != nil </span><span class="cov3" title="17">{
                        return err
                }</span>
        case *PkScript:<span class="cov0" title="0">
                pkScript, err := wire.ReadVarBytes(r, 0, 34, "pkscript")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = pkScript</span>
        case *wire.OutPoint:<span class="cov2" title="5">
                var h [32]byte
                if _, err = io.ReadFull(r, h[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="4">hash, err := chainhash.NewHash(h[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="4">var idxBytes [2]byte
                _, err = io.ReadFull(r, idxBytes[:])
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="3">index := binary.BigEndian.Uint16(idxBytes[:])

                *e = wire.OutPoint{
                        Hash:  *hash,
                        Index: uint32(index),
                }</span>
        case *FailCode:<span class="cov1" title="3">
                if err := ReadElement(r, (*uint16)(e)); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        case *ChannelID:<span class="cov5" title="205">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov3" title="14">{
                        return err
                }</span>

        case *ShortChannelID:<span class="cov9" title="46674">
                var blockHeight [4]byte
                if _, err = io.ReadFull(r, blockHeight[1:]); err != nil </span><span class="cov6" title="912">{
                        return err
                }</span>

                <span class="cov9" title="45762">var txIndex [4]byte
                if _, err = io.ReadFull(r, txIndex[1:]); err != nil </span><span class="cov5" title="169">{
                        return err
                }</span>

                <span class="cov9" title="45593">var txPosition [2]byte
                if _, err = io.ReadFull(r, txPosition[:]); err != nil </span><span class="cov4" title="68">{
                        return err
                }</span>

                <span class="cov9" title="45525">*e = ShortChannelID{
                        BlockHeight: binary.BigEndian.Uint32(blockHeight[:]),
                        TxIndex:     binary.BigEndian.Uint32(txIndex[:]),
                        TxPosition:  binary.BigEndian.Uint16(txPosition[:]),
                }</span>

        case *[]net.Addr:<span class="cov4" title="66">
                // First, we'll read the number of total bytes that have been
                // used to encode the set of addresses.
                var numAddrsBytes [2]byte
                if _, err = io.ReadFull(r, numAddrsBytes[:]); err != nil </span><span class="cov1" title="3">{
                        return err
                }</span>
                <span class="cov4" title="63">addrsLen := binary.BigEndian.Uint16(numAddrsBytes[:])

                // With the number of addresses, read, we'll now pull in the
                // buffer of the encoded addresses into memory.
                addrs := make([]byte, addrsLen)
                if _, err := io.ReadFull(r, addrs[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="62">addrBuf := bytes.NewReader(addrs)

                // Finally, we'll parse the remaining address payload in
                // series, using the first byte to denote how to decode the
                // address itself.
                var (
                        addresses     []net.Addr
                        addrBytesRead uint16
                )

                for addrBytesRead &lt; addrsLen </span><span class="cov5" title="147">{
                        var descriptor [1]byte
                        if _, err = io.ReadFull(addrBuf, descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov5" title="147">addrBytesRead++

                        var address net.Addr
                        switch aType := addressType(descriptor[0]); aType </span>{
                        case noAddr:<span class="cov3" title="30">
                                addrBytesRead += aType.AddrLen()
                                continue</span>

                        case tcp4Addr:<span class="cov3" title="38">
                                var ip [4]byte
                                if _, err := io.ReadFull(addrBuf, ip[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov3" title="37">var port [2]byte
                                if _, err := io.ReadFull(addrBuf, port[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov3" title="36">address = &amp;net.TCPAddr{
                                        IP:   net.IP(ip[:]),
                                        Port: int(binary.BigEndian.Uint16(port[:])),
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case tcp6Addr:<span class="cov3" title="31">
                                var ip [16]byte
                                if _, err := io.ReadFull(addrBuf, ip[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov3" title="30">var port [2]byte
                                if _, err := io.ReadFull(addrBuf, port[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov3" title="29">address = &amp;net.TCPAddr{
                                        IP:   net.IP(ip[:]),
                                        Port: int(binary.BigEndian.Uint16(port[:])),
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case v2OnionAddr:<span class="cov2" title="6">
                                var h [tor.V2DecodedLen]byte
                                if _, err := io.ReadFull(addrBuf, h[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov2" title="5">var p [2]byte
                                if _, err := io.ReadFull(addrBuf, p[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov2" title="4">onionService := tor.Base32Encoding.EncodeToString(h[:])
                                onionService += tor.OnionSuffix
                                port := int(binary.BigEndian.Uint16(p[:]))

                                address = &amp;tor.OnionAddr{
                                        OnionService: onionService,
                                        Port:         port,
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case v3OnionAddr:<span class="cov3" title="38">
                                var h [tor.V3DecodedLen]byte
                                if _, err := io.ReadFull(addrBuf, h[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov3" title="37">var p [2]byte
                                if _, err := io.ReadFull(addrBuf, p[:]); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>

                                <span class="cov3" title="36">onionService := tor.Base32Encoding.EncodeToString(h[:])
                                onionService += tor.OnionSuffix
                                port := int(binary.BigEndian.Uint16(p[:]))

                                address = &amp;tor.OnionAddr{
                                        OnionService: onionService,
                                        Port:         port,
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        default:<span class="cov2" title="4">
                                return &amp;ErrUnknownAddrType{aType}</span>
                        }

                        <span class="cov4" title="105">addresses = append(addresses, address)</span>
                }

                <span class="cov4" title="50">*e = addresses</span>
        case *color.RGBA:<span class="cov4" title="87">
                err := ReadElements(r,
                        &amp;e.R,
                        &amp;e.G,
                        &amp;e.B,
                )
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        case *DeliveryAddress:<span class="cov4" title="126">
                var addrLen [2]byte
                if _, err = io.ReadFull(r, addrLen[:]); err != nil </span><span class="cov4" title="48">{
                        return err
                }</span>
                <span class="cov4" title="78">length := binary.BigEndian.Uint16(addrLen[:])

                var addrBytes [deliveryAddressMaxSize]byte
                if length &gt; deliveryAddressMaxSize </span><span class="cov1" title="3">{
                        return fmt.Errorf("Cannot read %d bytes into addrBytes", length)
                }</span>
                <span class="cov4" title="75">if _, err = io.ReadFull(r, addrBytes[:length]); err != nil </span><span class="cov2" title="4">{
                        return err
                }</span>
                <span class="cov4" title="71">*e = addrBytes[:length]</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("Unknown type in ReadElement: %T", e)</span>
        }

        <span class="cov9" title="55930">return nil</span>
}

// ReadElements deserializes a variable number of elements into the passed
// io.Reader, with each element being deserialized according to the ReadElement
// function.
func ReadElements(r io.Reader, elements ...interface{}) error <span class="cov9" title="51088">{
        for _, element := range elements </span><span class="cov9" title="56046">{
                err := ReadElement(r, element)
                if err != nil </span><span class="cov6" title="1309">{
                        return err
                }</span>
        }
        <span class="cov9" title="49779">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2013-2017 The btcsuite developers
// Copyright (c) 2015-2016 The Decred developers
// code derived from https://github .com/btcsuite/btcd/blob/master/wire/message.go
// Copyright (C) 2015-2017 The Lightning Network Developers

package lnwire

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// MaxMessagePayload is the maximum bytes a message can be regardless of other
// individual limits imposed by messages themselves.
const MaxMessagePayload = 65535 // 65KB

// MessageType is the unique 2 byte big-endian integer that indicates the type
// of message on the wire. All messages have a very simple header which
// consists simply of 2-byte message type. We omit a length field, and checksum
// as the Lightning Protocol is intended to be encapsulated within a
// confidential+authenticated cryptographic messaging protocol.
type MessageType uint16

// The currently defined message types within this current version of the
// Lightning protocol.
const (
        MsgInit                    MessageType = 16
        MsgError                               = 17
        MsgPing                                = 18
        MsgPong                                = 19
        MsgOpenChannel                         = 32
        MsgAcceptChannel                       = 33
        MsgFundingCreated                      = 34
        MsgFundingSigned                       = 35
        MsgFundingLocked                       = 36
        MsgShutdown                            = 38
        MsgClosingSigned                       = 39
        MsgUpdateAddHTLC                       = 128
        MsgUpdateFulfillHTLC                   = 130
        MsgUpdateFailHTLC                      = 131
        MsgCommitSig                           = 132
        MsgRevokeAndAck                        = 133
        MsgUpdateFee                           = 134
        MsgUpdateFailMalformedHTLC             = 135
        MsgChannelReestablish                  = 136
        MsgChannelAnnouncement                 = 256
        MsgNodeAnnouncement                    = 257
        MsgChannelUpdate                       = 258
        MsgAnnounceSignatures                  = 259
        MsgQueryShortChanIDs                   = 261
        MsgReplyShortChanIDsEnd                = 262
        MsgQueryChannelRange                   = 263
        MsgReplyChannelRange                   = 264
        MsgGossipTimestampRange                = 265
)

// String return the string representation of message type.
func (t MessageType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case MsgInit:<span class="cov0" title="0">
                return "Init"</span>
        case MsgOpenChannel:<span class="cov0" title="0">
                return "MsgOpenChannel"</span>
        case MsgAcceptChannel:<span class="cov0" title="0">
                return "MsgAcceptChannel"</span>
        case MsgFundingCreated:<span class="cov0" title="0">
                return "MsgFundingCreated"</span>
        case MsgFundingSigned:<span class="cov0" title="0">
                return "MsgFundingSigned"</span>
        case MsgFundingLocked:<span class="cov0" title="0">
                return "FundingLocked"</span>
        case MsgShutdown:<span class="cov0" title="0">
                return "Shutdown"</span>
        case MsgClosingSigned:<span class="cov0" title="0">
                return "ClosingSigned"</span>
        case MsgUpdateAddHTLC:<span class="cov0" title="0">
                return "UpdateAddHTLC"</span>
        case MsgUpdateFailHTLC:<span class="cov0" title="0">
                return "UpdateFailHTLC"</span>
        case MsgUpdateFulfillHTLC:<span class="cov0" title="0">
                return "UpdateFulfillHTLC"</span>
        case MsgCommitSig:<span class="cov0" title="0">
                return "CommitSig"</span>
        case MsgRevokeAndAck:<span class="cov0" title="0">
                return "RevokeAndAck"</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov0" title="0">
                return "UpdateFailMalformedHTLC"</span>
        case MsgChannelReestablish:<span class="cov0" title="0">
                return "ChannelReestablish"</span>
        case MsgError:<span class="cov0" title="0">
                return "Error"</span>
        case MsgChannelAnnouncement:<span class="cov0" title="0">
                return "ChannelAnnouncement"</span>
        case MsgChannelUpdate:<span class="cov0" title="0">
                return "ChannelUpdate"</span>
        case MsgNodeAnnouncement:<span class="cov0" title="0">
                return "NodeAnnouncement"</span>
        case MsgPing:<span class="cov0" title="0">
                return "Ping"</span>
        case MsgAnnounceSignatures:<span class="cov0" title="0">
                return "AnnounceSignatures"</span>
        case MsgPong:<span class="cov0" title="0">
                return "Pong"</span>
        case MsgUpdateFee:<span class="cov0" title="0">
                return "UpdateFee"</span>
        case MsgQueryShortChanIDs:<span class="cov0" title="0">
                return "QueryShortChanIDs"</span>
        case MsgReplyShortChanIDsEnd:<span class="cov0" title="0">
                return "ReplyShortChanIDsEnd"</span>
        case MsgQueryChannelRange:<span class="cov0" title="0">
                return "QueryChannelRange"</span>
        case MsgReplyChannelRange:<span class="cov0" title="0">
                return "ReplyChannelRange"</span>
        case MsgGossipTimestampRange:<span class="cov0" title="0">
                return "GossipTimestampRange"</span>
        default:<span class="cov0" title="0">
                return "&lt;unknown&gt;"</span>
        }
}

// UnknownMessage is an implementation of the error interface that allows the
// creation of an error in response to an unknown message.
type UnknownMessage struct {
        messageType MessageType
}

// Error returns a human readable string describing the error.
//
// This is part of the error interface.
func (u *UnknownMessage) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unable to parse message of unknown type: %v",
                u.messageType)
}</span>

// Serializable is an interface which defines a lightning wire serializable
// object.
type Serializable interface {
        // Decode reads the bytes stream and converts it to the object.
        Decode(io.Reader, uint32) error

        // Encode converts object to the bytes stream and write it into the
        // writer.
        Encode(io.Writer, uint32) error
}

// Message is an interface that defines a lightning wire protocol message. The
// interface is general in order to allow implementing types full control over
// the representation of its data.
type Message interface {
        Serializable
        MsgType() MessageType
        MaxPayloadLength(uint32) uint32
}

// makeEmptyMessage creates a new empty message of the proper concrete type
// based on the passed message type.
func makeEmptyMessage(msgType MessageType) (Message, error) <span class="cov10" title="2076">{
        var msg Message

        switch msgType </span>{
        case MsgInit:<span class="cov3" title="10">
                msg = &amp;Init{}</span>
        case MsgOpenChannel:<span class="cov5" title="66">
                msg = &amp;OpenChannel{}</span>
        case MsgAcceptChannel:<span class="cov6" title="70">
                msg = &amp;AcceptChannel{}</span>
        case MsgFundingCreated:<span class="cov3" title="6">
                msg = &amp;FundingCreated{}</span>
        case MsgFundingSigned:<span class="cov2" title="4">
                msg = &amp;FundingSigned{}</span>
        case MsgFundingLocked:<span class="cov5" title="32">
                msg = &amp;FundingLocked{}</span>
        case MsgShutdown:<span class="cov4" title="18">
                msg = &amp;Shutdown{}</span>
        case MsgClosingSigned:<span class="cov2" title="5">
                msg = &amp;ClosingSigned{}</span>
        case MsgUpdateAddHTLC:<span class="cov3" title="7">
                msg = &amp;UpdateAddHTLC{}</span>
        case MsgUpdateFailHTLC:<span class="cov3" title="12">
                msg = &amp;UpdateFailHTLC{}</span>
        case MsgUpdateFulfillHTLC:<span class="cov2" title="5">
                msg = &amp;UpdateFulfillHTLC{}</span>
        case MsgCommitSig:<span class="cov3" title="9">
                msg = &amp;CommitSig{}</span>
        case MsgRevokeAndAck:<span class="cov5" title="33">
                msg = &amp;RevokeAndAck{}</span>
        case MsgUpdateFee:<span class="cov2" title="4">
                msg = &amp;UpdateFee{}</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov3" title="6">
                msg = &amp;UpdateFailMalformedHTLC{}</span>
        case MsgChannelReestablish:<span class="cov5" title="34">
                msg = &amp;ChannelReestablish{}</span>
        case MsgError:<span class="cov4" title="13">
                msg = &amp;Error{}</span>
        case MsgChannelAnnouncement:<span class="cov5" title="32">
                msg = &amp;ChannelAnnouncement{}</span>
        case MsgChannelUpdate:<span class="cov5" title="30">
                msg = &amp;ChannelUpdate{}</span>
        case MsgNodeAnnouncement:<span class="cov6" title="92">
                msg = &amp;NodeAnnouncement{}</span>
        case MsgPing:<span class="cov4" title="13">
                msg = &amp;Ping{}</span>
        case MsgAnnounceSignatures:<span class="cov4" title="23">
                msg = &amp;AnnounceSignatures{}</span>
        case MsgPong:<span class="cov3" title="10">
                msg = &amp;Pong{}</span>
        case MsgQueryShortChanIDs:<span class="cov8" title="732">
                msg = &amp;QueryShortChanIDs{}</span>
        case MsgReplyShortChanIDsEnd:<span class="cov2" title="5">
                msg = &amp;ReplyShortChanIDsEnd{}</span>
        case MsgQueryChannelRange:<span class="cov2" title="4">
                msg = &amp;QueryChannelRange{}</span>
        case MsgReplyChannelRange:<span class="cov8" title="797">
                msg = &amp;ReplyChannelRange{}</span>
        case MsgGossipTimestampRange:<span class="cov2" title="4">
                msg = &amp;GossipTimestampRange{}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;UnknownMessage{msgType}</span>
        }

        <span class="cov10" title="2076">return msg, nil</span>
}

// WriteMessage writes a lightning Message to w including the necessary header
// information and returns the number of bytes written.
func WriteMessage(w io.Writer, msg Message, pver uint32) (int, error) <span class="cov8" title="749">{
        totalBytes := 0

        // Encode the message payload itself into a temporary buffer.
        // TODO(roasbeef): create buffer pool
        var bw bytes.Buffer
        if err := msg.Encode(&amp;bw, pver); err != nil </span><span class="cov0" title="0">{
                return totalBytes, err
        }</span>
        <span class="cov8" title="749">payload := bw.Bytes()
        lenp := len(payload)

        // Enforce maximum overall message payload.
        if lenp &gt; MaxMessagePayload </span><span class="cov0" title="0">{
                return totalBytes, fmt.Errorf("message payload is too large - "+
                        "encoded %d bytes, but maximum message payload is %d bytes",
                        lenp, MaxMessagePayload)
        }</span>

        // Enforce maximum message payload on the message type.
        <span class="cov8" title="749">mpl := msg.MaxPayloadLength(pver)
        if uint32(lenp) &gt; mpl </span><span class="cov0" title="0">{
                return totalBytes, fmt.Errorf("message payload is too large - "+
                        "encoded %d bytes, but maximum message payload of "+
                        "type %v is %d bytes", lenp, msg.MsgType(), mpl)
        }</span>

        // With the initial sanity checks complete, we'll now write out the
        // message type itself.
        <span class="cov8" title="749">var mType [2]byte
        binary.BigEndian.PutUint16(mType[:], uint16(msg.MsgType()))
        n, err := w.Write(mType[:])
        totalBytes += n
        if err != nil </span><span class="cov0" title="0">{
                return totalBytes, err
        }</span>

        // With the message type written, we'll now write out the raw payload
        // itself.
        <span class="cov8" title="749">n, err = w.Write(payload)
        totalBytes += n

        return totalBytes, err</span>
}

// ReadMessage reads, validates, and parses the next Lightning message from r
// for the provided protocol version.
func ReadMessage(r io.Reader, pver uint32) (Message, error) <span class="cov10" title="2076">{
        // First, we'll read out the first two bytes of the message so we can
        // create the proper empty message.
        var mType [2]byte
        if _, err := io.ReadFull(r, mType[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2076">msgType := MessageType(binary.BigEndian.Uint16(mType[:]))

        // Now that we know the target message type, we can create the proper
        // empty message type and decode the message into it.
        msg, err := makeEmptyMessage(msgType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2076">if err := msg.Decode(r, pver); err != nil </span><span class="cov8" title="578">{
                return nil, err
        }</span>

        <span class="cov9" title="1498">return msg, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package lnwire

import (
        "fmt"

        "github.com/btcsuite/btcutil"
)

const (
        // mSatScale is a value that's used to scale satoshis to milli-satoshis, and
        // the other way around.
        mSatScale uint64 = 1000

        // MaxMilliSatoshi is the maximum number of msats that can be expressed
        // in this data type.
        MaxMilliSatoshi = ^MilliSatoshi(0)
)

// MilliSatoshi are the native unit of the Lightning Network. A milli-satoshi
// is simply 1/1000th of a satoshi. There are 1000 milli-satoshis in a single
// satoshi. Within the network, all HTLC payments are denominated in
// milli-satoshis. As milli-satoshis aren't deliverable on the native
// blockchain, before settling to broadcasting, the values are rounded down to
// the nearest satoshi.
type MilliSatoshi uint64

// NewMSatFromSatoshis creates a new MilliSatoshi instance from a target amount
// of satoshis.
func NewMSatFromSatoshis(sat btcutil.Amount) MilliSatoshi <span class="cov0" title="0">{
        return MilliSatoshi(uint64(sat) * mSatScale)
}</span>

// ToBTC converts the target MilliSatoshi amount to its corresponding value
// when expressed in BTC.
func (m MilliSatoshi) ToBTC() float64 <span class="cov0" title="0">{
        sat := m.ToSatoshis()
        return sat.ToBTC()
}</span>

// ToSatoshis converts the target MilliSatoshi amount to satoshis. Simply, this
// sheds a factor of 1000 from the mSAT amount in order to convert it to SAT.
func (m MilliSatoshi) ToSatoshis() btcutil.Amount <span class="cov0" title="0">{
        return btcutil.Amount(uint64(m) / mSatScale)
}</span>

// String returns the string representation of the mSAT amount.
func (m MilliSatoshi) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v mSAT", uint64(m))
}</span>

// TODO(roasbeef): extend with arithmetic operations?
</pre>
		
		<pre class="file" id="file18" style="display: none">package lnwire

import (
        "fmt"
        "net"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/wire"
)

// NetAddress represents information pertaining to the identity and network
// reachability of a peer. Information stored includes the node's identity
// public key for establishing a confidential+authenticated connection, the
// service bits it supports, and a TCP address the node is reachable at.
//
// TODO(roasbeef): merge with LinkNode in some fashion
type NetAddress struct {
        // IdentityKey is the long-term static public key for a node. This node is
        // used throughout the network as a node's identity key. It is used to
        // authenticate any data sent to the network on behalf of the node, and
        // additionally to establish a confidential+authenticated connection with
        // the node.
        IdentityKey *btcec.PublicKey

        // Address is the IP address and port of the node. This is left
        // general so that multiple implementations can be used.
        Address net.Addr

        // ChainNet is the Bitcoin network this node is associated with.
        // TODO(roasbeef): make a slice in the future for multi-chain
        ChainNet wire.BitcoinNet
}

// A compile time assertion to ensure that NetAddress meets the net.Addr
// interface.
var _ net.Addr = (*NetAddress)(nil)

// String returns a human readable string describing the target NetAddress. The
// current string format is: &lt;pubkey&gt;@host.
//
// This part of the net.Addr interface.
func (n *NetAddress) String() string <span class="cov0" title="0">{
        // TODO(roasbeef): use base58?
        pubkey := n.IdentityKey.SerializeCompressed()

        return fmt.Sprintf("%x@%v", pubkey, n.Address)
}</span>

// Network returns the name of the network this address is bound to.
//
// This part of the net.Addr interface.
func (n *NetAddress) Network() string <span class="cov0" title="0">{
        return n.Address.Network()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none;">package lnwire

import (
        "bytes"
        "fmt"
        "image/color"
        "io"
        "io/ioutil"
        "net"
        "unicode/utf8"
)

// ErrUnknownAddrType is an error returned if we encounter an unknown address type
// when parsing addresses.
type ErrUnknownAddrType struct {
        addrType addressType
}

// Error returns a human readable string describing the error.
//
// NOTE: implements the error interface.
func (e ErrUnknownAddrType) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unknown address type: %v", e.addrType)
}</span>

// ErrInvalidNodeAlias is an error returned if a node alias we parse on the
// wire is invalid, as in it has non UTF-8 characters.
type ErrInvalidNodeAlias struct{}

// Error returns a human readable string describing the error.
//
// NOTE: implements the error interface.
func (e ErrInvalidNodeAlias) Error() string <span class="cov0" title="0">{
        return "node alias has non-utf8 characters"
}</span>

// NodeAlias a hex encoded UTF-8 string that may be displayed as an alternative
// to the node's ID. Notice that aliases are not unique and may be freely
// chosen by the node operators.
type NodeAlias [32]byte

// NewNodeAlias creates a new instance of a NodeAlias. Verification is
// performed on the passed string to ensure it meets the alias requirements.
func NewNodeAlias(s string) (NodeAlias, error) <span class="cov9" title="85">{
        var n NodeAlias

        if len(s) &gt; 32 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("alias too large: max is %v, got %v", 32,
                        len(s))
        }</span>

        <span class="cov9" title="85">if !utf8.ValidString(s) </span><span class="cov6" title="19">{
                return n, &amp;ErrInvalidNodeAlias{}
        }</span>

        <span class="cov9" title="66">copy(n[:], []byte(s))
        return n, nil</span>
}

// String returns a utf8 string representation of the alias bytes.
func (n NodeAlias) String() string <span class="cov0" title="0">{
        // Trim trailing zero-bytes for presentation
        return string(bytes.Trim(n[:], "\x00"))
}</span>

// NodeAnnouncement message is used to announce the presence of a Lightning
// node and also to signal that the node is accepting incoming connections.
// Each NodeAnnouncement authenticating the advertised information within the
// announcement via a signature using the advertised node pubkey.
type NodeAnnouncement struct {
        // Signature is used to prove the ownership of node id.
        Signature Sig

        // Features is the list of protocol features this node supports.
        Features *RawFeatureVector

        // Timestamp allows ordering in the case of multiple announcements.
        Timestamp uint32

        // NodeID is a public key which is used as node identification.
        NodeID [33]byte

        // RGBColor is used to customize their node's appearance in maps and
        // graphs
        RGBColor color.RGBA

        // Alias is used to customize their node's appearance in maps and
        // graphs
        Alias NodeAlias

        // Address includes two specification fields: 'ipv6' and 'port' on
        // which the node is accepting incoming connections.
        Addresses []net.Addr

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// UpdateNodeAnnAddrs is a functional option that allows updating the addresses
// of the given node announcement.
func UpdateNodeAnnAddrs(addrs []net.Addr) func(*NodeAnnouncement) <span class="cov0" title="0">{
        return func(nodeAnn *NodeAnnouncement) </span><span class="cov0" title="0">{
                nodeAnn.Addresses = addrs
        }</span>
}

// A compile time check to ensure NodeAnnouncement implements the
// lnwire.Message interface.
var _ Message = (*NodeAnnouncement)(nil)

// Decode deserializes a serialized NodeAnnouncement stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) Decode(r io.Reader, pver uint32) error <span class="cov10" title="92">{
        err := ReadElements(r,
                &amp;a.Signature,
                &amp;a.Features,
                &amp;a.Timestamp,
                &amp;a.NodeID,
                &amp;a.RGBColor,
                &amp;a.Alias,
                &amp;a.Addresses,
        )
        if err != nil </span><span class="cov8" title="42">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov8" title="50">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="50">if len(a.ExtraOpaqueData) == 0 </span><span class="cov7" title="26">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov8" title="50">return nil</span>
}

// Encode serializes the target NodeAnnouncement into the passed io.Writer
// observing the protocol version specified.
//
func (a *NodeAnnouncement) Encode(w io.Writer, pver uint32) error <span class="cov7" title="25">{
        return WriteElements(w,
                a.Signature,
                a.Features,
                a.Timestamp,
                a.NodeID,
                a.RGBColor,
                a.Alias,
                a.Addresses,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) MsgType() MessageType <span class="cov7" title="25">{
        return MsgNodeAnnouncement
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="92">{
        return 65533
}</span>

// DataToSign returns the part of the message that should be signed.
func (a *NodeAnnouncement) DataToSign() ([]byte, error) <span class="cov0" title="0">{

        // We should not include the signatures itself.
        var w bytes.Buffer
        err := WriteElements(&amp;w,
                a.Features,
                a.Timestamp,
                a.NodeID,
                a.RGBColor,
                a.Alias[:],
                a.Addresses,
                a.ExtraOpaqueData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package lnwire

import (
        "bufio"
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "io"

        "bytes"

        "github.com/davecgh/go-spew/spew"
        "github.com/go-errors/errors"
        "github.com/lightningnetwork/lnd/tlv"
)

// FailureMessage represents the onion failure object identified by its unique
// failure code.
type FailureMessage interface {
        // Code returns a failure code describing the exact nature of the
        // error.
        Code() FailCode

        // Error returns a human readable string describing the error. With
        // this method, the FailureMessage interface meets the built-in error
        // interface.
        Error() string
}

// FailureMessageLength is the size of the failure message plus the size of
// padding. The FailureMessage message should always be EXACTLY this size.
const FailureMessageLength = 256

const (
        // FlagBadOnion error flag describes an unparsable, encrypted by
        // previous node.
        FlagBadOnion FailCode = 0x8000

        // FlagPerm error flag indicates a permanent failure.
        FlagPerm FailCode = 0x4000

        // FlagNode error flag indicates anode failure.
        FlagNode FailCode = 0x2000

        // FlagUpdate error flag indicates a new channel update is enclosed
        // within the error.
        FlagUpdate FailCode = 0x1000
)

// FailCode specifies the precise reason that an upstream HTLC was canceled.
// Each UpdateFailHTLC message carries a FailCode which is to be passed
// backwards, encrypted at each step back to the source of the HTLC within the
// route.
type FailCode uint16

// The currently defined onion failure types within this current version of the
// Lightning protocol.
const (
        CodeNone                             FailCode = 0
        CodeInvalidRealm                              = FlagBadOnion | 1
        CodeTemporaryNodeFailure                      = FlagNode | 2
        CodePermanentNodeFailure                      = FlagPerm | FlagNode | 2
        CodeRequiredNodeFeatureMissing                = FlagPerm | FlagNode | 3
        CodeInvalidOnionVersion                       = FlagBadOnion | FlagPerm | 4
        CodeInvalidOnionHmac                          = FlagBadOnion | FlagPerm | 5
        CodeInvalidOnionKey                           = FlagBadOnion | FlagPerm | 6
        CodeTemporaryChannelFailure                   = FlagUpdate | 7
        CodePermanentChannelFailure                   = FlagPerm | 8
        CodeRequiredChannelFeatureMissing             = FlagPerm | 9
        CodeUnknownNextPeer                           = FlagPerm | 10
        CodeAmountBelowMinimum                        = FlagUpdate | 11
        CodeFeeInsufficient                           = FlagUpdate | 12
        CodeIncorrectCltvExpiry                       = FlagUpdate | 13
        CodeExpiryTooSoon                             = FlagUpdate | 14
        CodeChannelDisabled                           = FlagUpdate | 20
        CodeIncorrectOrUnknownPaymentDetails          = FlagPerm | 15
        CodeIncorrectPaymentAmount                    = FlagPerm | 16
        CodeFinalExpiryTooSoon               FailCode = 17
        CodeFinalIncorrectCltvExpiry         FailCode = 18
        CodeFinalIncorrectHtlcAmount         FailCode = 19
        CodeExpiryTooFar                     FailCode = 21
        CodeInvalidOnionPayload                       = FlagPerm | 22
        CodeMPPTimeout                       FailCode = 23
)

// String returns the string representation of the failure code.
func (c FailCode) String() string <span class="cov0" title="0">{
        switch c </span>{
        case CodeInvalidRealm:<span class="cov0" title="0">
                return "InvalidRealm"</span>

        case CodeTemporaryNodeFailure:<span class="cov0" title="0">
                return "TemporaryNodeFailure"</span>

        case CodePermanentNodeFailure:<span class="cov0" title="0">
                return "PermanentNodeFailure"</span>

        case CodeRequiredNodeFeatureMissing:<span class="cov0" title="0">
                return "RequiredNodeFeatureMissing"</span>

        case CodeInvalidOnionVersion:<span class="cov0" title="0">
                return "InvalidOnionVersion"</span>

        case CodeInvalidOnionHmac:<span class="cov0" title="0">
                return "InvalidOnionHmac"</span>

        case CodeInvalidOnionKey:<span class="cov0" title="0">
                return "InvalidOnionKey"</span>

        case CodeTemporaryChannelFailure:<span class="cov0" title="0">
                return "TemporaryChannelFailure"</span>

        case CodePermanentChannelFailure:<span class="cov0" title="0">
                return "PermanentChannelFailure"</span>

        case CodeRequiredChannelFeatureMissing:<span class="cov0" title="0">
                return "RequiredChannelFeatureMissing"</span>

        case CodeUnknownNextPeer:<span class="cov0" title="0">
                return "UnknownNextPeer"</span>

        case CodeAmountBelowMinimum:<span class="cov0" title="0">
                return "AmountBelowMinimum"</span>

        case CodeFeeInsufficient:<span class="cov0" title="0">
                return "FeeInsufficient"</span>

        case CodeIncorrectCltvExpiry:<span class="cov0" title="0">
                return "IncorrectCltvExpiry"</span>

        case CodeIncorrectPaymentAmount:<span class="cov0" title="0">
                return "IncorrectPaymentAmount"</span>

        case CodeExpiryTooSoon:<span class="cov0" title="0">
                return "ExpiryTooSoon"</span>

        case CodeChannelDisabled:<span class="cov0" title="0">
                return "ChannelDisabled"</span>

        case CodeIncorrectOrUnknownPaymentDetails:<span class="cov0" title="0">
                return "IncorrectOrUnknownPaymentDetails"</span>

        case CodeFinalExpiryTooSoon:<span class="cov0" title="0">
                return "FinalExpiryTooSoon"</span>

        case CodeFinalIncorrectCltvExpiry:<span class="cov0" title="0">
                return "FinalIncorrectCltvExpiry"</span>

        case CodeFinalIncorrectHtlcAmount:<span class="cov0" title="0">
                return "FinalIncorrectHtlcAmount"</span>

        case CodeExpiryTooFar:<span class="cov0" title="0">
                return "ExpiryTooFar"</span>

        case CodeInvalidOnionPayload:<span class="cov0" title="0">
                return "InvalidOnionPayload"</span>

        case CodeMPPTimeout:<span class="cov0" title="0">
                return "MPPTimeout"</span>

        default:<span class="cov0" title="0">
                return "&lt;unknown&gt;"</span>
        }
}

// FailInvalidRealm is returned if the realm byte is unknown.
//
// NOTE: May be returned by any node in the payment route.
type FailInvalidRealm struct{}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidRealm) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidRealm) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidRealm
}</span>

// FailTemporaryNodeFailure is returned if an otherwise unspecified transient
// error occurs for the entire node.
//
// NOTE: May be returned by any node in the payment route.
type FailTemporaryNodeFailure struct{}

// Code returns the failure unique code.
// NOTE: Part of the FailureMessage interface.
func (f *FailTemporaryNodeFailure) Code() FailCode <span class="cov0" title="0">{
        return CodeTemporaryNodeFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailTemporaryNodeFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailPermanentNodeFailure is returned if an otherwise unspecified permanent
// error occurs for the entire node.
//
// NOTE: May be returned by any node in the payment route.
type FailPermanentNodeFailure struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailPermanentNodeFailure) Code() FailCode <span class="cov0" title="0">{
        return CodePermanentNodeFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailPermanentNodeFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailRequiredNodeFeatureMissing is returned if a node has requirement
// advertised in its node_announcement features which were not present in the
// onion.
//
// NOTE: May be returned by any node in the payment route.
type FailRequiredNodeFeatureMissing struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailRequiredNodeFeatureMissing) Code() FailCode <span class="cov0" title="0">{
        return CodeRequiredNodeFeatureMissing
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailRequiredNodeFeatureMissing) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailPermanentChannelFailure is return if an otherwise unspecified permanent
// error occurs for the outgoing channel (eg. channel (recently).
//
// NOTE: May be returned by any node in the payment route.
type FailPermanentChannelFailure struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailPermanentChannelFailure) Code() FailCode <span class="cov0" title="0">{
        return CodePermanentChannelFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailPermanentChannelFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailRequiredChannelFeatureMissing is returned if the outgoing channel has a
// requirement advertised in its channel announcement features which were not
// present in the onion.
//
// NOTE: May only be returned by intermediate nodes.
type FailRequiredChannelFeatureMissing struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailRequiredChannelFeatureMissing) Code() FailCode <span class="cov0" title="0">{
        return CodeRequiredChannelFeatureMissing
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailRequiredChannelFeatureMissing) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailUnknownNextPeer is returned if the next peer specified by the onion is
// not known.
//
// NOTE: May only be returned by intermediate nodes.
type FailUnknownNextPeer struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailUnknownNextPeer) Code() FailCode <span class="cov0" title="0">{
        return CodeUnknownNextPeer
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailUnknownNextPeer) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailIncorrectPaymentAmount is returned if the amount paid is less than the
// amount expected, the final node MUST fail the HTLC. If the amount paid is
// more than twice the amount expected, the final node SHOULD fail the HTLC.
// This allows the sender to reduce information leakage by altering the amount,
// without allowing accidental gross overpayment.
//
// NOTE: May only be returned by the final node in the path.
type FailIncorrectPaymentAmount struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectPaymentAmount) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectPaymentAmount
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailIncorrectPaymentAmount) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailIncorrectDetails is returned for two reasons:
//
// 1) if the payment hash has already been paid, the final node MAY treat the
// payment hash as unknown, or may succeed in accepting the HTLC. If the
// payment hash is unknown, the final node MUST fail the HTLC.
//
// 2) if the amount paid is less than the amount expected, the final node MUST
// fail the HTLC. If the amount paid is more than twice the amount expected,
// the final node SHOULD fail the HTLC. This allows the sender to reduce
// information leakage by altering the amount, without allowing accidental
// gross overpayment.
//
// NOTE: May only be returned by the final node in the path.
type FailIncorrectDetails struct {
        // amount is the value of the extended HTLC.
        amount MilliSatoshi

        // height is the block height when the htlc was received.
        height uint32
}

// NewFailIncorrectDetails makes a new instance of the FailIncorrectDetails
// error bound to the specified HTLC amount and acceptance height.
func NewFailIncorrectDetails(amt MilliSatoshi,
        height uint32) *FailIncorrectDetails <span class="cov0" title="0">{

        return &amp;FailIncorrectDetails{
                amount: amt,
                height: height,
        }
}</span>

// Amount is the value of the extended HTLC.
func (f *FailIncorrectDetails) Amount() MilliSatoshi <span class="cov0" title="0">{
        return f.amount
}</span>

// Height is the block height when the htlc was received.
func (f *FailIncorrectDetails) Height() uint32 <span class="cov0" title="0">{
        return f.height
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectDetails) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectOrUnknownPaymentDetails
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailIncorrectDetails) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "%v(amt=%v, height=%v)", CodeIncorrectOrUnknownPaymentDetails,
                f.amount, f.height,
        )
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectDetails) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElement(r, &amp;f.amount)
        switch </span>{
        // This is an optional tack on that was added later in the protocol. As
        // a result, older nodes may not include this value. We'll account for
        // this by checking for io.EOF here which means that no bytes were read
        // at all.
        case err == io.EOF:<span class="cov0" title="0">
                return nil</span>

        case err != nil:<span class="cov0" title="0">
                return err</span>
        }

        // At a later stage, the height field was also tacked on. We need to
        // check for io.EOF here as well.
        <span class="cov0" title="0">err = ReadElement(r, &amp;f.height)
        switch </span>{
        case err == io.EOF:<span class="cov0" title="0">
                return nil</span>

        case err != nil:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectDetails) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElements(w, f.amount, f.height)
}</span>

// FailFinalExpiryTooSoon is returned if the cltv_expiry is too low, the final
// node MUST fail the HTLC.
//
// NOTE: May only be returned by the final node in the path.
type FailFinalExpiryTooSoon struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalExpiryTooSoon) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalExpiryTooSoon
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFinalExpiryTooSoon) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// NewFinalExpiryTooSoon creates new instance of the FailFinalExpiryTooSoon.
func NewFinalExpiryTooSoon() *FailFinalExpiryTooSoon <span class="cov0" title="0">{
        return &amp;FailFinalExpiryTooSoon{}
}</span>

// FailInvalidOnionVersion is returned if the onion version byte is unknown.
//
// NOTE: May be returned only by intermediate nodes.
type FailInvalidOnionVersion struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidOnionVersion) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionVersion(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// NewInvalidOnionVersion creates new instance of the FailInvalidOnionVersion.
func NewInvalidOnionVersion(onion []byte) *FailInvalidOnionVersion <span class="cov0" title="0">{
        return &amp;FailInvalidOnionVersion{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionVersion) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionVersion
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionVersion) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionVersion) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.OnionSHA256[:])
}</span>

// FailInvalidOnionHmac is return if the onion HMAC is incorrect.
//
// NOTE: May only be returned by intermediate nodes.
type FailInvalidOnionHmac struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// NewInvalidOnionHmac creates new instance of the FailInvalidOnionHmac.
func NewInvalidOnionHmac(onion []byte) *FailInvalidOnionHmac <span class="cov0" title="0">{
        return &amp;FailInvalidOnionHmac{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionHmac) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionHmac
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionHmac) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionHmac) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.OnionSHA256[:])
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidOnionHmac) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionHMAC(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// FailInvalidOnionKey is return if the ephemeral key in the onion is
// unparsable.
//
// NOTE: May only be returned by intermediate nodes.
type FailInvalidOnionKey struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// NewInvalidOnionKey creates new instance of the FailInvalidOnionKey.
func NewInvalidOnionKey(onion []byte) *FailInvalidOnionKey <span class="cov0" title="0">{
        return &amp;FailInvalidOnionKey{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionKey) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionKey
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionKey) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionKey) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.OnionSHA256[:])
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidOnionKey) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionKey(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// parseChannelUpdateCompatabilityMode will attempt to parse a channel updated
// encoded into an onion error payload in two ways. First, we'll try the
// compatibility oriented version wherein we'll _skip_ the length prefixing on
// the channel update message. Older versions of c-lighting do this so we'll
// attempt to parse these messages in order to retain compatibility. If we're
// unable to pull out a fully valid version, then we'll fall back to the
// regular parsing mechanism which includes the length prefix an NO type byte.
func parseChannelUpdateCompatabilityMode(r *bufio.Reader,
        chanUpdate *ChannelUpdate, pver uint32) error <span class="cov0" title="0">{

        // We'll peek out two bytes from the buffer without advancing the
        // buffer so we can decide how to parse the remainder of it.
        maybeTypeBytes, err := r.Peek(2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Some nodes well prefix an additional set of bytes in front of their
        // channel updates. These bytes will _almost_ always be 258 or the type
        // of the ChannelUpdate message.
        <span class="cov0" title="0">typeInt := binary.BigEndian.Uint16(maybeTypeBytes)
        if typeInt == MsgChannelUpdate </span><span class="cov0" title="0">{
                // At this point it's likely the case that this is a channel
                // update message with its type prefixed, so we'll snip off the
                // first two bytes and parse it as normal.
                var throwAwayTypeBytes [2]byte
                _, err := r.Read(throwAwayTypeBytes[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // At this pint, we've either decided to keep the entire thing, or snip
        // off the first two bytes. In either case, we can just read it as
        // normal.
        <span class="cov0" title="0">return chanUpdate.Decode(r, pver)</span>
}

// FailTemporaryChannelFailure is if an otherwise unspecified transient error
// occurs for the outgoing channel (eg. channel capacity reached, too many
// in-flight htlcs)
//
// NOTE: May only be returned by intermediate nodes.
type FailTemporaryChannelFailure struct {
        // Update is used to update information about state of the channel
        // which caused the failure.
        //
        // NOTE: This field is optional.
        Update *ChannelUpdate
}

// NewTemporaryChannelFailure creates new instance of the FailTemporaryChannelFailure.
func NewTemporaryChannelFailure(update *ChannelUpdate) *FailTemporaryChannelFailure <span class="cov0" title="0">{
        return &amp;FailTemporaryChannelFailure{Update: update}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailTemporaryChannelFailure) Code() FailCode <span class="cov0" title="0">{
        return CodeTemporaryChannelFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailTemporaryChannelFailure) Error() string <span class="cov0" title="0">{
        if f.Update == nil </span><span class="cov0" title="0">{
                return f.Code().String()
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("TemporaryChannelFailure(update=%v)",
                spew.Sdump(f.Update))</span>
}

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailTemporaryChannelFailure) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var length uint16
        err := ReadElement(r, &amp;length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if length != 0 </span><span class="cov0" title="0">{
                f.Update = &amp;ChannelUpdate{}
                return parseChannelUpdateCompatabilityMode(
                        bufio.NewReader(r), f.Update, pver,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailTemporaryChannelFailure) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        var payload []byte
        if f.Update != nil </span><span class="cov0" title="0">{
                var bw bytes.Buffer
                if err := f.Update.Encode(&amp;bw, pver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">payload = bw.Bytes()</span>
        }

        <span class="cov0" title="0">if err := WriteElement(w, uint16(len(payload))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err := w.Write(payload)
        return err</span>
}

// FailAmountBelowMinimum is returned if the HTLC does not reach the current
// minimum amount, we tell them the amount of the incoming HTLC and the current
// channel setting for the outgoing channel.
//
// NOTE: May only be returned by the intermediate nodes in the path.
type FailAmountBelowMinimum struct {
        // HtlcMsat is the wrong amount of the incoming HTLC.
        HtlcMsat MilliSatoshi

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewAmountBelowMinimum creates new instance of the FailAmountBelowMinimum.
func NewAmountBelowMinimum(htlcMsat MilliSatoshi,
        update ChannelUpdate) *FailAmountBelowMinimum <span class="cov0" title="0">{

        return &amp;FailAmountBelowMinimum{
                HtlcMsat: htlcMsat,
                Update:   update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailAmountBelowMinimum) Code() FailCode <span class="cov0" title="0">{
        return CodeAmountBelowMinimum
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailAmountBelowMinimum) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("AmountBelowMinimum(amt=%v, update=%v", f.HtlcMsat,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailAmountBelowMinimum) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailAmountBelowMinimum) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailFeeInsufficient is returned if the HTLC does not pay sufficient fee, we
// tell them the amount of the incoming HTLC and the current channel setting
// for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailFeeInsufficient struct {
        // HtlcMsat is the wrong amount of the incoming HTLC.
        HtlcMsat MilliSatoshi

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewFeeInsufficient creates new instance of the FailFeeInsufficient.
func NewFeeInsufficient(htlcMsat MilliSatoshi,
        update ChannelUpdate) *FailFeeInsufficient <span class="cov0" title="0">{
        return &amp;FailFeeInsufficient{
                HtlcMsat: htlcMsat,
                Update:   update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFeeInsufficient) Code() FailCode <span class="cov0" title="0">{
        return CodeFeeInsufficient
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFeeInsufficient) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FeeInsufficient(htlc_amt==%v, update=%v", f.HtlcMsat,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFeeInsufficient) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFeeInsufficient) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailIncorrectCltvExpiry is returned if outgoing cltv value does not match
// the update add htlc's cltv expiry minus cltv expiry delta for the outgoing
// channel, we tell them the cltv expiry and the current channel setting for
// the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailIncorrectCltvExpiry struct {
        // CltvExpiry is the wrong absolute timeout in blocks, after which
        // outgoing HTLC expires.
        CltvExpiry uint32

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewIncorrectCltvExpiry creates new instance of the FailIncorrectCltvExpiry.
func NewIncorrectCltvExpiry(cltvExpiry uint32,
        update ChannelUpdate) *FailIncorrectCltvExpiry <span class="cov0" title="0">{

        return &amp;FailIncorrectCltvExpiry{
                CltvExpiry: cltvExpiry,
                Update:     update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectCltvExpiry) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectCltvExpiry
}</span>

func (f *FailIncorrectCltvExpiry) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("IncorrectCltvExpiry(expiry=%v, update=%v",
                f.CltvExpiry, spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectCltvExpiry) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.CltvExpiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectCltvExpiry) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.CltvExpiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailExpiryTooSoon is returned if the ctlv-expiry is too near, we tell them
// the current channel setting for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailExpiryTooSoon struct {
        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewExpiryTooSoon creates new instance of the FailExpiryTooSoon.
func NewExpiryTooSoon(update ChannelUpdate) *FailExpiryTooSoon <span class="cov0" title="0">{
        return &amp;FailExpiryTooSoon{
                Update: update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailExpiryTooSoon) Code() FailCode <span class="cov0" title="0">{
        return CodeExpiryTooSoon
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailExpiryTooSoon) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ExpiryTooSoon(update=%v", spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from l stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailExpiryTooSoon) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailExpiryTooSoon) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)
}</span>

// FailChannelDisabled is returned if the channel is disabled, we tell them the
// current channel setting for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailChannelDisabled struct {
        // Flags least-significant bit must be set to 0 if the creating node
        // corresponds to the first node in the previously sent channel
        // announcement and 1 otherwise.
        Flags uint16

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewChannelDisabled creates new instance of the FailChannelDisabled.
func NewChannelDisabled(flags uint16, update ChannelUpdate) *FailChannelDisabled <span class="cov0" title="0">{
        return &amp;FailChannelDisabled{
                Flags:  flags,
                Update: update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailChannelDisabled) Code() FailCode <span class="cov0" title="0">{
        return CodeChannelDisabled
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailChannelDisabled) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ChannelDisabled(flags=%v, update=%v", f.Flags,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailChannelDisabled) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailChannelDisabled) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailFinalIncorrectCltvExpiry is returned if the outgoing_cltv_value does not
// match the ctlv_expiry of the HTLC at the final hop.
//
// NOTE: might be returned by final node only.
type FailFinalIncorrectCltvExpiry struct {
        // CltvExpiry is the wrong absolute timeout in blocks, after which
        // outgoing HTLC expires.
        CltvExpiry uint32
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFinalIncorrectCltvExpiry) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FinalIncorrectCltvExpiry(expiry=%v)", f.CltvExpiry)
}</span>

// NewFinalIncorrectCltvExpiry creates new instance of the
// FailFinalIncorrectCltvExpiry.
func NewFinalIncorrectCltvExpiry(cltvExpiry uint32) *FailFinalIncorrectCltvExpiry <span class="cov0" title="0">{
        return &amp;FailFinalIncorrectCltvExpiry{
                CltvExpiry: cltvExpiry,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalIncorrectCltvExpiry) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalIncorrectCltvExpiry
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectCltvExpiry) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, &amp;f.CltvExpiry)
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectCltvExpiry) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.CltvExpiry)
}</span>

// FailFinalIncorrectHtlcAmount is returned if the amt_to_forward is higher
// than incoming_htlc_amt of the HTLC at the final hop.
//
// NOTE: May only be returned by the final node.
type FailFinalIncorrectHtlcAmount struct {
        // IncomingHTLCAmount is the wrong forwarded htlc amount.
        IncomingHTLCAmount MilliSatoshi
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFinalIncorrectHtlcAmount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FinalIncorrectHtlcAmount(amt=%v)",
                f.IncomingHTLCAmount)
}</span>

// NewFinalIncorrectHtlcAmount creates new instance of the
// FailFinalIncorrectHtlcAmount.
func NewFinalIncorrectHtlcAmount(amount MilliSatoshi) *FailFinalIncorrectHtlcAmount <span class="cov0" title="0">{
        return &amp;FailFinalIncorrectHtlcAmount{
                IncomingHTLCAmount: amount,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalIncorrectHtlcAmount) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalIncorrectHtlcAmount
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectHtlcAmount) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, &amp;f.IncomingHTLCAmount)
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectHtlcAmount) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.IncomingHTLCAmount)
}</span>

// FailExpiryTooFar is returned if the CLTV expiry in the HTLC is too far in the
// future.
//
// NOTE: May be returned by any node in the payment route.
type FailExpiryTooFar struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailExpiryTooFar) Code() FailCode <span class="cov0" title="0">{
        return CodeExpiryTooFar
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailExpiryTooFar) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// InvalidOnionPayload is returned if the hop could not process the TLV payload
// enclosed in the onion.
type InvalidOnionPayload struct {
        // Type is the TLV type that caused the specific failure.
        Type uint64

        // Offset is the byte offset within the payload where the failure
        // occurred.
        Offset uint16
}

// NewInvalidOnionPayload initializes a new InvalidOnionPayload failure.
func NewInvalidOnionPayload(typ uint64, offset uint16) *InvalidOnionPayload <span class="cov0" title="0">{
        return &amp;InvalidOnionPayload{
                Type:   typ,
                Offset: offset,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *InvalidOnionPayload) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionPayload
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *InvalidOnionPayload) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v(type=%v, offset=%d)",
                f.Code(), f.Type, f.Offset)
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *InvalidOnionPayload) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var buf [8]byte
        typ, err := tlv.ReadVarInt(r, &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.Type = typ

        return ReadElements(r, &amp;f.Offset)</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *InvalidOnionPayload) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        var buf [8]byte
        if err := tlv.WriteVarInt(w, f.Type, &amp;buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteElements(w, f.Offset)</span>
}

// FailMPPTimeout is returned if the complete amount for a multi part payment
// was not received within a reasonable time.
//
// NOTE: May only be returned by the final node in the path.
type FailMPPTimeout struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailMPPTimeout) Code() FailCode <span class="cov0" title="0">{
        return CodeMPPTimeout
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailMPPTimeout) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// DecodeFailure decodes, validates, and parses the lnwire onion failure, for
// the provided protocol version.
func DecodeFailure(r io.Reader, pver uint32) (FailureMessage, error) <span class="cov0" title="0">{
        // First, we'll parse out the encapsulated failure message itself. This
        // is a 2 byte length followed by the payload itself.
        var failureLength uint16
        if err := ReadElement(r, &amp;failureLength); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read error len: %v", err)
        }</span>
        <span class="cov0" title="0">if failureLength &gt; FailureMessageLength </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure message is too "+
                        "long: %v", failureLength)
        }</span>
        <span class="cov0" title="0">failureData := make([]byte, failureLength)
        if _, err := io.ReadFull(r, failureData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to full read payload of "+
                        "%v: %v", failureLength, err)
        }</span>

        <span class="cov0" title="0">dataReader := bytes.NewReader(failureData)

        return DecodeFailureMessage(dataReader, pver)</span>
}

// DecodeFailureMessage decodes just the failure message, ignoring any padding
// that may be present at the end.
func DecodeFailureMessage(r io.Reader, pver uint32) (FailureMessage, error) <span class="cov0" title="0">{
        // Once we have the failure data, we can obtain the failure code from
        // the first two bytes of the buffer.
        var codeBytes [2]byte
        if _, err := io.ReadFull(r, codeBytes[:]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read failure code: %v", err)
        }</span>
        <span class="cov0" title="0">failCode := FailCode(binary.BigEndian.Uint16(codeBytes[:]))

        // Create the empty failure by given code and populate the failure with
        // additional data if needed.
        failure, err := makeEmptyOnionError(failCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to make empty error: %v", err)
        }</span>

        // Finally, if this failure has a payload, then we'll read that now as
        // well.
        <span class="cov0" title="0">switch f := failure.(type) </span>{
        case Serializable:<span class="cov0" title="0">
                if err := f.Decode(r, pver); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to decode error "+
                                "update (type=%T): %v", failure, err)
                }</span>
        }

        <span class="cov0" title="0">return failure, nil</span>
}

// EncodeFailure encodes, including the necessary onion failure header
// information.
func EncodeFailure(w io.Writer, failure FailureMessage, pver uint32) error <span class="cov0" title="0">{
        var failureMessageBuffer bytes.Buffer

        err := EncodeFailureMessage(&amp;failureMessageBuffer, failure, pver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // The combined size of this message must be below the max allowed
        // failure message length.
        <span class="cov0" title="0">failureMessage := failureMessageBuffer.Bytes()
        if len(failureMessage) &gt; FailureMessageLength </span><span class="cov0" title="0">{
                return fmt.Errorf("failure message exceed max "+
                        "available size: %v", len(failureMessage))
        }</span>

        // Finally, we'll add some padding in order to ensure that all failure
        // messages are fixed size.
        <span class="cov0" title="0">pad := make([]byte, FailureMessageLength-len(failureMessage))

        return WriteElements(w,
                uint16(len(failureMessage)),
                failureMessage,
                uint16(len(pad)),
                pad,
        )</span>
}

// EncodeFailureMessage encodes just the failure message without adding a length
// and padding the message for the onion protocol.
func EncodeFailureMessage(w io.Writer, failure FailureMessage, pver uint32) error <span class="cov0" title="0">{
        // First, we'll write out the error code itself into the failure
        // buffer.
        var codeBytes [2]byte
        code := uint16(failure.Code())
        binary.BigEndian.PutUint16(codeBytes[:], code)
        _, err := w.Write(codeBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next, some message have an additional message payload, if this is
        // one of those types, then we'll also encode the error payload as
        // well.
        <span class="cov0" title="0">switch failure := failure.(type) </span>{
        case Serializable:<span class="cov0" title="0">
                if err := failure.Encode(w, pver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// makeEmptyOnionError creates a new empty onion error  of the proper concrete
// type based on the passed failure code.
func makeEmptyOnionError(code FailCode) (FailureMessage, error) <span class="cov0" title="0">{
        switch code </span>{
        case CodeInvalidRealm:<span class="cov0" title="0">
                return &amp;FailInvalidRealm{}, nil</span>

        case CodeTemporaryNodeFailure:<span class="cov0" title="0">
                return &amp;FailTemporaryNodeFailure{}, nil</span>

        case CodePermanentNodeFailure:<span class="cov0" title="0">
                return &amp;FailPermanentNodeFailure{}, nil</span>

        case CodeRequiredNodeFeatureMissing:<span class="cov0" title="0">
                return &amp;FailRequiredNodeFeatureMissing{}, nil</span>

        case CodePermanentChannelFailure:<span class="cov0" title="0">
                return &amp;FailPermanentChannelFailure{}, nil</span>

        case CodeRequiredChannelFeatureMissing:<span class="cov0" title="0">
                return &amp;FailRequiredChannelFeatureMissing{}, nil</span>

        case CodeUnknownNextPeer:<span class="cov0" title="0">
                return &amp;FailUnknownNextPeer{}, nil</span>

        case CodeIncorrectOrUnknownPaymentDetails:<span class="cov0" title="0">
                return &amp;FailIncorrectDetails{}, nil</span>

        case CodeIncorrectPaymentAmount:<span class="cov0" title="0">
                return &amp;FailIncorrectPaymentAmount{}, nil</span>

        case CodeFinalExpiryTooSoon:<span class="cov0" title="0">
                return &amp;FailFinalExpiryTooSoon{}, nil</span>

        case CodeInvalidOnionVersion:<span class="cov0" title="0">
                return &amp;FailInvalidOnionVersion{}, nil</span>

        case CodeInvalidOnionHmac:<span class="cov0" title="0">
                return &amp;FailInvalidOnionHmac{}, nil</span>

        case CodeInvalidOnionKey:<span class="cov0" title="0">
                return &amp;FailInvalidOnionKey{}, nil</span>

        case CodeTemporaryChannelFailure:<span class="cov0" title="0">
                return &amp;FailTemporaryChannelFailure{}, nil</span>

        case CodeAmountBelowMinimum:<span class="cov0" title="0">
                return &amp;FailAmountBelowMinimum{}, nil</span>

        case CodeFeeInsufficient:<span class="cov0" title="0">
                return &amp;FailFeeInsufficient{}, nil</span>

        case CodeIncorrectCltvExpiry:<span class="cov0" title="0">
                return &amp;FailIncorrectCltvExpiry{}, nil</span>

        case CodeExpiryTooSoon:<span class="cov0" title="0">
                return &amp;FailExpiryTooSoon{}, nil</span>

        case CodeChannelDisabled:<span class="cov0" title="0">
                return &amp;FailChannelDisabled{}, nil</span>

        case CodeFinalIncorrectCltvExpiry:<span class="cov0" title="0">
                return &amp;FailFinalIncorrectCltvExpiry{}, nil</span>

        case CodeFinalIncorrectHtlcAmount:<span class="cov0" title="0">
                return &amp;FailFinalIncorrectHtlcAmount{}, nil</span>

        case CodeExpiryTooFar:<span class="cov0" title="0">
                return &amp;FailExpiryTooFar{}, nil</span>

        case CodeInvalidOnionPayload:<span class="cov0" title="0">
                return &amp;InvalidOnionPayload{}, nil</span>

        case CodeMPPTimeout:<span class="cov0" title="0">
                return &amp;FailMPPTimeout{}, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown error code: %v", code)</span>
        }
}

// writeOnionErrorChanUpdate writes out a ChannelUpdate using the onion error
// format. The format is that we first write out the true serialized length of
// the channel update, followed by the serialized channel update itself.
func writeOnionErrorChanUpdate(w io.Writer, chanUpdate *ChannelUpdate,
        pver uint32) error <span class="cov0" title="0">{

        // First, we encode the channel update in a temporary buffer in order
        // to get the exact serialized size.
        var b bytes.Buffer
        if err := chanUpdate.Encode(&amp;b, pver); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now that we know the size, we can write the length out in the main
        // writer.
        <span class="cov0" title="0">updateLen := b.Len()
        if err := WriteElement(w, uint16(updateLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the length written, we'll then write out the serialized channel
        // update.
        <span class="cov0" title="0">if _, err := w.Write(b.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcutil"
)

// FundingFlag represents the possible bit mask values for the ChannelFlags
// field within the OpenChannel struct.
type FundingFlag uint8

const (
        // FFAnnounceChannel is a FundingFlag that when set, indicates the
        // initiator of a funding flow wishes to announce the channel to the
        // greater network.
        FFAnnounceChannel FundingFlag = 1 &lt;&lt; iota
)

// OpenChannel is the message Alice sends to Bob if we should like to create a
// channel with Bob where she's the sole provider of funds to the channel.
// Single funder channels simplify the initial funding workflow, are supported
// by nodes backed by SPV Bitcoin clients, and have a simpler security models
// than dual funded channels.
type OpenChannel struct {
        // ChainHash is the target chain that the initiator wishes to open a
        // channel within.
        ChainHash chainhash.Hash

        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // FundingAmount is the amount of satoshis that the initiator of the
        // channel wishes to use as the total capacity of the channel. The
        // initial balance of the funding will be this value minus the push
        // amount (if set).
        FundingAmount btcutil.Amount

        // PushAmount is the value that the initiating party wishes to "push"
        // to the responding as part of the first commitment state. If the
        // responder accepts, then this will be their initial balance.
        PushAmount MilliSatoshi

        // DustLimit is the specific dust limit the sender of this message
        // would like enforced on their version of the commitment transaction.
        // Any output below this value will be "trimmed" from the commitment
        // transaction, with the amount of the HTLC going to dust.
        DustLimit btcutil.Amount

        // MaxValueInFlight represents the maximum amount of coins that can be
        // pending within the channel at any given time. If the amount of funds
        // in limbo exceeds this amount, then the channel will be failed.
        MaxValueInFlight MilliSatoshi

        // ChannelReserve is the amount of BTC that the receiving party MUST
        // maintain a balance above at all times. This is a safety mechanism to
        // ensure that both sides always have skin in the game during the
        // channel's lifetime.
        ChannelReserve btcutil.Amount

        // HtlcMinimum is the smallest HTLC that the sender of this message
        // will accept.
        HtlcMinimum MilliSatoshi

        // FeePerKiloWeight is the initial fee rate that the initiator suggests
        // for both commitment transaction. This value is expressed in sat per
        // kilo-weight.
        //
        // TODO(halseth): make SatPerKWeight when fee estimation is in own
        // package. Currently this will cause an import cycle.
        FeePerKiloWeight uint32

        // CsvDelay is the number of blocks to use for the relative time lock
        // in the pay-to-self output of both commitment transactions.
        CsvDelay uint16

        // MaxAcceptedHTLCs is the total number of incoming HTLC's that the
        // sender of this channel will accept.
        MaxAcceptedHTLCs uint16

        // FundingKey is the key that should be used on behalf of the sender
        // within the 2-of-2 multi-sig output that it contained within the
        // funding transaction.
        FundingKey *btcec.PublicKey

        // RevocationPoint is the base revocation point for the sending party.
        // Any commitment transaction belonging to the receiver of this message
        // should use this key and their per-commitment point to derive the
        // revocation key for the commitment transaction.
        RevocationPoint *btcec.PublicKey

        // PaymentPoint is the base payment point for the sending party. This
        // key should be combined with the per commitment point for a
        // particular commitment state in order to create the key that should
        // be used in any output that pays directly to the sending party, and
        // also within the HTLC covenant transactions.
        PaymentPoint *btcec.PublicKey

        // DelayedPaymentPoint is the delay point for the sending party. This
        // key should be combined with the per commitment point to derive the
        // keys that are used in outputs of the sender's commitment transaction
        // where they claim funds.
        DelayedPaymentPoint *btcec.PublicKey

        // HtlcPoint is the base point used to derive the set of keys for this
        // party that will be used within the HTLC public key scripts.  This
        // value is combined with the receiver's revocation base point in order
        // to derive the keys that are used within HTLC scripts.
        HtlcPoint *btcec.PublicKey

        // FirstCommitmentPoint is the first commitment point for the sending
        // party. This value should be combined with the receiver's revocation
        // base point in order to derive the revocation keys that are placed
        // within the commitment transaction of the sender.
        FirstCommitmentPoint *btcec.PublicKey

        // ChannelFlags is a bit-field which allows the initiator of the
        // channel to specify further behavior surrounding the channel.
        // Currently, the least significant bit of this bit field indicates the
        // initiator of the channel wishes to advertise this channel publicly.
        ChannelFlags FundingFlag

        // UpfrontShutdownScript is the script to which the channel funds should
        // be paid when mutually closing the channel. This field is optional, and
        // and has a length prefix, so a zero will be written if it is not set
        // and its length followed by the script will be written if it is set.
        UpfrontShutdownScript DeliveryAddress
}

// A compile time check to ensure OpenChannel implements the lnwire.Message
// interface.
var _ Message = (*OpenChannel)(nil)

// Encode serializes the target OpenChannel into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) Encode(w io.Writer, pver uint32) error <span class="cov7" title="26">{
        return WriteElements(w,
                o.ChainHash[:],
                o.PendingChannelID[:],
                o.FundingAmount,
                o.PushAmount,
                o.DustLimit,
                o.MaxValueInFlight,
                o.ChannelReserve,
                o.HtlcMinimum,
                o.FeePerKiloWeight,
                o.CsvDelay,
                o.MaxAcceptedHTLCs,
                o.FundingKey,
                o.RevocationPoint,
                o.PaymentPoint,
                o.DelayedPaymentPoint,
                o.HtlcPoint,
                o.FirstCommitmentPoint,
                o.ChannelFlags,
                o.UpfrontShutdownScript,
        )
}</span>

// Decode deserializes the serialized OpenChannel stored in the passed
// io.Reader into the target OpenChannel using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) Decode(r io.Reader, pver uint32) error <span class="cov10" title="66">{
        if err := ReadElements(r,
                o.ChainHash[:],
                o.PendingChannelID[:],
                &amp;o.FundingAmount,
                &amp;o.PushAmount,
                &amp;o.DustLimit,
                &amp;o.MaxValueInFlight,
                &amp;o.ChannelReserve,
                &amp;o.HtlcMinimum,
                &amp;o.FeePerKiloWeight,
                &amp;o.CsvDelay,
                &amp;o.MaxAcceptedHTLCs,
                &amp;o.FundingKey,
                &amp;o.RevocationPoint,
                &amp;o.PaymentPoint,
                &amp;o.DelayedPaymentPoint,
                &amp;o.HtlcPoint,
                &amp;o.FirstCommitmentPoint,
                &amp;o.ChannelFlags,
        ); err != nil </span><span class="cov6" title="13">{
                return err
        }</span>

        // Check for the optional upfront shutdown script field. If it is not there,
        // silence the EOF error.
        <span class="cov9" title="53">err := ReadElement(r, &amp;o.UpfrontShutdownScript)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="52">return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as an OpenChannel on the wire.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) MsgType() MessageType <span class="cov7" title="26">{
        return MsgOpenChannel
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// OpenChannel message.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) MaxPayloadLength(uint32) uint32 <span class="cov10" title="66">{
        // (32 * 2) + (8 * 6) + (4 * 1) + (2 * 2) + (33 * 6) + 1
        var length uint32 = 319 // base length

        // Upfront shutdown script max length.
        length += 2 + deliveryAddressMaxSize

        return length
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package lnwire

import "io"

// PingPayload is a set of opaque bytes used to pad out a ping message.
type PingPayload []byte

// Ping defines a message which is sent by peers periodically to determine if
// the connection is still valid. Each ping message carries the number of bytes
// to pad the pong response with, and also a number of bytes to be ignored at
// the end of the ping message (which is padding).
type Ping struct {
        // NumPongBytes is the number of bytes the pong response to this
        // message should carry.
        NumPongBytes uint16

        // PaddingBytes is a set of opaque bytes used to pad out this ping
        // message. Using this field in conjunction to the one above, it's
        // possible for node to generate fake cover traffic.
        PaddingBytes PingPayload
}

// NewPing returns a new Ping message.
func NewPing(numBytes uint16) *Ping <span class="cov0" title="0">{
        return &amp;Ping{
                NumPongBytes: numBytes,
        }
}</span>

// A compile time check to ensure Ping implements the lnwire.Message interface.
var _ Message = (*Ping)(nil)

// Decode deserializes a serialized Ping message stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Ping) Decode(r io.Reader, pver uint32) error <span class="cov10" title="13">{
        return ReadElements(r,
                &amp;p.NumPongBytes,
                &amp;p.PaddingBytes)
}</span>

// Encode serializes the target Ping into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (p *Ping) Encode(w io.Writer, pver uint32) error <span class="cov6" title="5">{
        return WriteElements(w,
                p.NumPongBytes,
                p.PaddingBytes)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (p *Ping) MsgType() MessageType <span class="cov6" title="5">{
        return MsgPing
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a Ping
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p Ping) MaxPayloadLength(uint32) uint32 <span class="cov10" title="13">{
        return 65532
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package lnwire

import "io"

// PongPayload is a set of opaque bytes sent in response to a ping message.
type PongPayload []byte

// Pong defines a message which is the direct response to a received Ping
// message. A Pong reply indicates that a connection is still active. The Pong
// reply to a Ping message should contain the nonce carried in the original
// Pong message.
type Pong struct {
        // PongBytes is a set of opaque bytes that corresponds to the
        // NumPongBytes defined in the ping message that this pong is
        // replying to.
        PongBytes PongPayload
}

// NewPong returns a new Pong message.
func NewPong(pongBytes []byte) *Pong <span class="cov0" title="0">{
        return &amp;Pong{
                PongBytes: pongBytes,
        }
}</span>

// A compile time check to ensure Pong implements the lnwire.Message interface.
var _ Message = (*Pong)(nil)

// Decode deserializes a serialized Pong message stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Pong) Decode(r io.Reader, pver uint32) error <span class="cov10" title="10">{
        return ReadElements(r,
                &amp;p.PongBytes,
        )
}</span>

// Encode serializes the target Pong into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (p *Pong) Encode(w io.Writer, pver uint32) error <span class="cov6" title="4">{
        return WriteElements(w,
                p.PongBytes,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (p *Pong) MsgType() MessageType <span class="cov6" title="4">{
        return MsgPong
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a Pong
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Pong) MaxPayloadLength(uint32) uint32 <span class="cov10" title="10">{
        return 65532
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// QueryChannelRange is a message sent by a node in order to query the
// receiving node of the set of open channel they know of with short channel
// ID's after the specified block height, capped at the number of blocks beyond
// that block height. This will be used by nodes upon initial connect to
// synchronize their views of the network.
type QueryChannelRange struct {
        // ChainHash denotes the target chain that we're trying to synchronize
        // channel graph state for.
        ChainHash chainhash.Hash

        // FirstBlockHeight is the first block in the query range. The
        // responder should send all new short channel IDs from this block
        // until this block plus the specified number of blocks.
        FirstBlockHeight uint32

        // NumBlocks is the number of blocks beyond the first block that short
        // channel ID's should be sent for.
        NumBlocks uint32
}

// NewQueryChannelRange creates a new empty QueryChannelRange message.
func NewQueryChannelRange() *QueryChannelRange <span class="cov0" title="0">{
        return &amp;QueryChannelRange{}
}</span>

// A compile time check to ensure QueryChannelRange implements the
// lnwire.Message interface.
var _ Message = (*QueryChannelRange)(nil)

// Decode deserializes a serialized QueryChannelRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) Decode(r io.Reader, pver uint32) error <span class="cov10" title="801">{
        return ReadElements(r,
                q.ChainHash[:],
                &amp;q.FirstBlockHeight,
                &amp;q.NumBlocks,
        )
}</span>

// Encode serializes the target QueryChannelRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) Encode(w io.Writer, pver uint32) error <span class="cov8" title="286">{
        return WriteElements(w,
                q.ChainHash[:],
                q.FirstBlockHeight,
                q.NumBlocks,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) MsgType() MessageType <span class="cov1" title="1">{
        return MsgQueryChannelRange
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// QueryChannelRange complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) MaxPayloadLength(uint32) uint32 <span class="cov2" title="4">{
        // 32 + 4 + 4
        return 40
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package lnwire

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "io"
        "sort"
        "sync"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ShortChanIDEncoding is an enum-like type that represents exactly how a set
// of short channel ID's is encoded on the wire. The set of encodings allows us
// to take advantage of the structure of a list of short channel ID's to
// achieving a high degree of compression.
type ShortChanIDEncoding uint8

const (
        // EncodingSortedPlain signals that the set of short channel ID's is
        // encoded using the regular encoding, in a sorted order.
        EncodingSortedPlain ShortChanIDEncoding = 0

        // EncodingSortedZlib signals that the set of short channel ID's is
        // encoded by first sorting the set of channel ID's, as then
        // compressing them using zlib.
        EncodingSortedZlib ShortChanIDEncoding = 1
)

const (
        // maxZlibBufSize is the max number of bytes that we'll accept from a
        // zlib decoding instance. We do this in order to limit the total
        // amount of memory allocated during a decoding instance.
        maxZlibBufSize = 67413630
)

// ErrUnsortedSIDs is returned when decoding a QueryShortChannelID request whose
// items were not sorted.
type ErrUnsortedSIDs struct {
        prevSID ShortChannelID
        curSID  ShortChannelID
}

// Error returns a human-readable description of the error.
func (e ErrUnsortedSIDs) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("current sid: %v isn't greater than last sid: %v",
                e.curSID, e.prevSID)
}</span>

// zlibDecodeMtx is a package level mutex that we'll use in order to ensure
// that we'll only attempt a single zlib decoding instance at a time. This
// allows us to also further bound our memory usage.
var zlibDecodeMtx sync.Mutex

// ErrUnknownShortChanIDEncoding is a parametrized error that indicates that we
// came across an unknown short channel ID encoding, and therefore were unable
// to continue parsing.
func ErrUnknownShortChanIDEncoding(encoding ShortChanIDEncoding) error <span class="cov1" title="2">{
        return fmt.Errorf("unknown short chan id encoding: %v", encoding)
}</span>

// QueryShortChanIDs is a message that allows the sender to query a set of
// channel announcement and channel update messages that correspond to the set
// of encoded short channel ID's. The encoding of the short channel ID's is
// detailed in the query message ensuring that the receiver knows how to
// properly decode each encode short channel ID which may be encoded using a
// compression format. The receiver should respond with a series of channel
// announcement and channel updates, finally sending a ReplyShortChanIDsEnd
// message.
type QueryShortChanIDs struct {
        // ChainHash denotes the target chain that we're querying for the
        // channel channel ID's of.
        ChainHash chainhash.Hash

        // EncodingType is a signal to the receiver of the message that
        // indicates exactly how the set of short channel ID's that follow have
        // been encoded.
        EncodingType ShortChanIDEncoding

        // ShortChanIDs is a slice of decoded short channel ID's.
        ShortChanIDs []ShortChannelID

        // noSort indicates whether or not to sort the short channel ids before
        // writing them out.
        //
        // NOTE: This should only be used during testing.
        noSort bool
}

// NewQueryShortChanIDs creates a new QueryShortChanIDs message.
func NewQueryShortChanIDs(h chainhash.Hash, e ShortChanIDEncoding,
        s []ShortChannelID) *QueryShortChanIDs <span class="cov0" title="0">{

        return &amp;QueryShortChanIDs{
                ChainHash:    h,
                EncodingType: e,
                ShortChanIDs: s,
        }
}</span>

// A compile time check to ensure QueryShortChanIDs implements the
// lnwire.Message interface.
var _ Message = (*QueryShortChanIDs)(nil)

// Decode deserializes a serialized QueryShortChanIDs message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) Decode(r io.Reader, pver uint32) error <span class="cov6" title="732">{
        err := ReadElements(r, q.ChainHash[:])
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="731">q.EncodingType, q.ShortChanIDs, err = decodeShortChanIDs(r)

        return err</span>
}

// decodeShortChanIDs decodes a set of short channel ID's that have been
// encoded. The first byte of the body details how the short chan ID's were
// encoded. We'll use this type to govern exactly how we go about encoding the
// set of short channel ID's.
func decodeShortChanIDs(r io.Reader) (ShortChanIDEncoding, []ShortChannelID, error) <span class="cov6" title="1525">{
        // First, we'll attempt to read the number of bytes in the body of the
        // set of encoded short channel ID's.
        var numBytesResp uint16
        err := ReadElements(r, &amp;numBytesResp)
        if err != nil </span><span class="cov1" title="2">{
                return 0, nil, err
        }</span>

        <span class="cov6" title="1523">if numBytesResp == 0 </span><span class="cov1" title="2">{
                return 0, nil, fmt.Errorf("No encoding type specified")
        }</span>

        <span class="cov6" title="1521">queryBody := make([]byte, numBytesResp)
        if _, err := io.ReadFull(r, queryBody); err != nil </span><span class="cov1" title="2">{
                return 0, nil, err
        }</span>

        // The first byte is the encoding type, so we'll extract that so we can
        // continue our parsing.
        <span class="cov6" title="1519">encodingType := ShortChanIDEncoding(queryBody[0])

        // Before continuing, we'll snip off the first byte of the query body
        // as that was just the encoding type.
        queryBody = queryBody[1:]

        // Otherwise, depending on the encoding type, we'll decode the encode
        // short channel ID's in a different manner.
        switch encodingType </span>{

        // In this encoding, we'll simply read a sort array of encoded short
        // channel ID's from the buffer.
        case EncodingSortedPlain:<span class="cov3" title="41">
                // If after extracting the encoding type, then number of
                // remaining bytes instead a whole multiple of the size of an
                // encoded short channel ID (8 bytes), then we'll return a
                // parsing error.
                if len(queryBody)%8 != 0 </span><span class="cov1" title="2">{
                        return 0, nil, fmt.Errorf("whole number of short "+
                                "chan ID's cannot be encoded in len=%v",
                                len(queryBody))
                }</span>

                // As each short channel ID is encoded as 8 bytes, we can
                // compute the number of bytes encoded based on the size of the
                // query body.
                <span class="cov3" title="39">numShortChanIDs := len(queryBody) / 8
                if numShortChanIDs == 0 </span><span class="cov2" title="4">{
                        return encodingType, nil, nil
                }</span>

                // Finally, we'll read out the exact number of short channel
                // ID's to conclude our parsing.
                <span class="cov3" title="35">shortChanIDs := make([]ShortChannelID, numShortChanIDs)
                bodyReader := bytes.NewReader(queryBody)
                var lastChanID ShortChannelID
                for i := 0; i &lt; numShortChanIDs; i++ </span><span class="cov8" title="15557">{
                        if err := ReadElements(bodyReader, &amp;shortChanIDs[i]); err != nil </span><span class="cov0" title="0">{
                                return 0, nil, fmt.Errorf("unable to parse "+
                                        "short chan ID: %v", err)
                        }</span>

                        <span class="cov8" title="15557">cid := shortChanIDs[i]
                        if cid.ToUint64() &lt;= lastChanID.ToUint64() </span><span class="cov1" title="3">{
                                return 0, nil, ErrUnsortedSIDs{lastChanID, cid}
                        }</span>
                        <span class="cov8" title="15554">lastChanID = cid</span>
                }

                <span class="cov3" title="32">return encodingType, shortChanIDs, nil</span>

        // In this encoding, we'll use zlib to decode the compressed payload.
        // However, we'll pay attention to ensure that we don't open our selves
        // up to a memory exhaustion attack.
        case EncodingSortedZlib:<span class="cov6" title="1476">
                // We'll obtain an ultimately release the zlib decode mutex.
                // This guards us against allocating too much memory to decode
                // each instance from concurrent peers.
                zlibDecodeMtx.Lock()
                defer zlibDecodeMtx.Unlock()

                // Before we start to decode, we'll create a limit reader over
                // the current reader. This will ensure that we can control how
                // much memory we're allocating during the decoding process.
                limitedDecompressor, err := zlib.NewReader(&amp;io.LimitedReader{
                        R: bytes.NewReader(queryBody),
                        N: maxZlibBufSize,
                })
                if err != nil </span><span class="cov2" title="13">{
                        return 0, nil, fmt.Errorf("unable to create zlib reader: %v", err)
                }</span>

                <span class="cov6" title="1463">var (
                        shortChanIDs []ShortChannelID
                        lastChanID   ShortChannelID
                )
                for </span><span class="cov8" title="31039">{
                        // We'll now attempt to read the next short channel ID
                        // encoded in the payload.
                        var cid ShortChannelID
                        err := ReadElements(limitedDecompressor, &amp;cid)

                        switch </span>{
                        // If we get an EOF error, then that either means we've
                        // read all that's contained in the buffer, or have hit
                        // our limit on the number of bytes we'll read. In
                        // either case, we'll return what we have so far.
                        case err == io.ErrUnexpectedEOF || err == io.EOF:<span class="cov6" title="1086">
                                return encodingType, shortChanIDs, nil</span>

                        // Otherwise, we hit some other sort of error, possibly
                        // an invalid payload, so we'll exit early with the
                        // error.
                        case err != nil:<span class="cov4" title="54">
                                return 0, nil, fmt.Errorf("unable to "+
                                        "deflate next short chan "+
                                        "ID: %v", err)</span>
                        }

                        // We successfully read the next ID, so well collect
                        // that in the set of final ID's to return.
                        <span class="cov8" title="29899">shortChanIDs = append(shortChanIDs, cid)

                        // Finally, we'll ensure that this short chan ID is
                        // greater than the last one. This is a requirement
                        // within the encoding, and if violated can aide us in
                        // detecting malicious payloads.
                        if cid.ToUint64() &lt;= lastChanID.ToUint64() </span><span class="cov5" title="323">{
                                return 0, nil, ErrUnsortedSIDs{lastChanID, cid}
                        }</span>

                        <span class="cov8" title="29576">lastChanID = cid</span>
                }

        default:<span class="cov1" title="2">
                // If we've been sent an encoding type that we don't know of,
                // then we'll return a parsing error as we can't continue if
                // we're unable to encode them.
                return 0, nil, ErrUnknownShortChanIDEncoding(encodingType)</span>
        }
}

// Encode serializes the target QueryShortChanIDs into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) Encode(w io.Writer, pver uint32) error <span class="cov5" title="276">{
        // First, we'll write out the chain hash.
        err := WriteElements(w, q.ChainHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Base on our encoding type, we'll write out the set of short channel
        // ID's.
        <span class="cov5" title="276">return encodeShortChanIDs(w, q.EncodingType, q.ShortChanIDs, q.noSort)</span>
}

// encodeShortChanIDs encodes the passed short channel ID's into the passed
// io.Writer, respecting the specified encoding type.
func encodeShortChanIDs(w io.Writer, encodingType ShortChanIDEncoding,
        shortChanIDs []ShortChannelID, noSort bool) error <span class="cov5" title="561">{

        // For both of the current encoding types, the channel ID's are to be
        // sorted in place, so we'll do that now. The sorting is applied unless
        // we were specifically requested not to for testing purposes.
        if !noSort </span><span class="cov5" title="561">{
                sort.Slice(shortChanIDs, func(i, j int) bool </span><span class="cov10" title="142525">{
                        return shortChanIDs[i].ToUint64() &lt;
                                shortChanIDs[j].ToUint64()
                }</span>)
        }

        <span class="cov5" title="561">switch encodingType </span>{

        // In this encoding, we'll simply write a sorted array of encoded short
        // channel ID's from the buffer.
        case EncodingSortedPlain:<span class="cov3" title="18">
                // First, we'll write out the number of bytes of the query
                // body. We add 1 as the response will have the encoding type
                // prepended to it.
                numBytesBody := uint16(len(shortChanIDs)*8) + 1
                if err := WriteElements(w, numBytesBody); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // We'll then write out the encoding that that follows the
                // actual encoded short channel ID's.
                <span class="cov3" title="18">if err := WriteElements(w, encodingType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Now that we know they're sorted, we can write out each short
                // channel ID to the buffer.
                <span class="cov3" title="18">for _, chanID := range shortChanIDs </span><span class="cov7" title="7682">{
                        if err := WriteElements(w, chanID); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to write short chan "+
                                        "ID: %v", err)
                        }</span>
                }

                <span class="cov3" title="18">return nil</span>

        // For this encoding we'll first write out a serialized version of all
        // the channel ID's into a buffer, then zlib encode that. The final
        // payload is what we'll write out to the passed io.Writer.
        //
        // TODO(roasbeef): assumes the caller knows the proper chunk size to
        // pass to avoid bin-packing here
        case EncodingSortedZlib:<span class="cov5" title="543">
                // We'll make a new buffer, then wrap that with a zlib writer
                // so we can write directly to the buffer and encode in a
                // streaming manner.
                var buf bytes.Buffer
                zlibWriter := zlib.NewWriter(&amp;buf)

                // Next, we'll write out all the channel ID's directly into the
                // zlib writer, which will do compressing on the fly.
                for _, chanID := range shortChanIDs </span><span class="cov8" title="14184">{
                        err := WriteElements(zlibWriter, chanID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to write short chan "+
                                        "ID: %v", err)
                        }</span>
                }

                // Now that we've written all the elements, we'll ensure the
                // compressed stream is written to the underlying buffer.
                <span class="cov5" title="543">if err := zlibWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to finalize "+
                                "compression: %v", err)
                }</span>

                // Now that we have all the items compressed, we can compute
                // what the total payload size will be. We add one to account
                // for the byte to encode the type.
                <span class="cov5" title="543">compressedPayload := buf.Bytes()
                numBytesBody := len(compressedPayload) + 1

                // Finally, we can write out the number of bytes, the
                // compression type, and finally the buffer itself.
                if err := WriteElements(w, uint16(numBytesBody)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="543">if err := WriteElements(w, encodingType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov5" title="543">_, err := w.Write(compressedPayload)
                return err</span>

        default:<span class="cov0" title="0">
                // If we're trying to encode with an encoding type that we
                // don't know of, then we'll return a parsing error as we can't
                // continue if we're unable to encode them.
                return ErrUnknownShortChanIDEncoding(encodingType)</span>
        }
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) MsgType() MessageType <span class="cov5" title="276">{
        return MsgQueryShortChanIDs
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// QueryShortChanIDs complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) MaxPayloadLength(uint32) uint32 <span class="cov6" title="732">{
        return MaxMessagePayload
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package lnwire

import "io"

// ReplyChannelRange is the response to the QueryChannelRange message. It
// includes the original query, and the next streaming chunk of encoded short
// channel ID's as the response. We'll also include a byte that indicates if
// this is the last query in the message.
type ReplyChannelRange struct {
        // QueryChannelRange is the corresponding query to this response.
        QueryChannelRange

        // Complete denotes if this is the conclusion of the set of streaming
        // responses to the original query.
        Complete uint8

        // EncodingType is a signal to the receiver of the message that
        // indicates exactly how the set of short channel ID's that follow have
        // been encoded.
        EncodingType ShortChanIDEncoding

        // ShortChanIDs is a slice of decoded short channel ID's.
        ShortChanIDs []ShortChannelID

        // noSort indicates whether or not to sort the short channel ids before
        // writing them out.
        //
        // NOTE: This should only be used for testing.
        noSort bool
}

// NewReplyChannelRange creates a new empty ReplyChannelRange message.
func NewReplyChannelRange() *ReplyChannelRange <span class="cov0" title="0">{
        return &amp;ReplyChannelRange{}
}</span>

// A compile time check to ensure ReplyChannelRange implements the
// lnwire.Message interface.
var _ Message = (*ReplyChannelRange)(nil)

// Decode deserializes a serialized ReplyChannelRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) Decode(r io.Reader, pver uint32) error <span class="cov10" title="797">{
        err := c.QueryChannelRange.Decode(r, pver)
        if err != nil </span><span class="cov1" title="2">{
                return err
        }</span>

        <span class="cov9" title="795">if err := ReadElements(r, &amp;c.Complete); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="794">c.EncodingType, c.ShortChanIDs, err = decodeShortChanIDs(r)

        return err</span>
}

// Encode serializes the target ReplyChannelRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) Encode(w io.Writer, pver uint32) error <span class="cov8" title="285">{
        if err := c.QueryChannelRange.Encode(w, pver); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="285">if err := WriteElements(w, c.Complete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="285">return encodeShortChanIDs(w, c.EncodingType, c.ShortChanIDs, c.noSort)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) MsgType() MessageType <span class="cov8" title="285">{
        return MsgReplyChannelRange
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// ReplyChannelRange complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) MaxPayloadLength(uint32) uint32 <span class="cov10" title="797">{
        return MaxMessagePayload
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ReplyShortChanIDsEnd is a message that marks the end of a streaming message
// response to an initial QueryShortChanIDs message. This marks that the
// receiver of the original QueryShortChanIDs for the target chain has either
// sent all adequate responses it knows of, or doesn't now of any short chan
// ID's for the target chain.
type ReplyShortChanIDsEnd struct {
        // ChainHash denotes the target chain that we're respond to a short
        // chan ID query for.
        ChainHash chainhash.Hash

        // Complete will be set to 0 if we don't know of the chain that the
        // remote peer sent their query for. Otherwise, we'll set this to 1 in
        // order to indicate that we've sent all known responses for the prior
        // set of short chan ID's in the corresponding QueryShortChanIDs
        // message.
        Complete uint8
}

// NewReplyShortChanIDsEnd creates a new empty ReplyShortChanIDsEnd message.
func NewReplyShortChanIDsEnd() *ReplyShortChanIDsEnd <span class="cov0" title="0">{
        return &amp;ReplyShortChanIDsEnd{}
}</span>

// A compile time check to ensure ReplyShortChanIDsEnd implements the
// lnwire.Message interface.
var _ Message = (*ReplyShortChanIDsEnd)(nil)

// Decode deserializes a serialized ReplyShortChanIDsEnd message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) Decode(r io.Reader, pver uint32) error <span class="cov10" title="5">{
        return ReadElements(r,
                c.ChainHash[:],
                &amp;c.Complete,
        )
}</span>

// Encode serializes the target ReplyShortChanIDsEnd into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChainHash[:],
                c.Complete,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) MsgType() MessageType <span class="cov1" title="1">{
        return MsgReplyShortChanIDsEnd
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// ReplyShortChanIDsEnd complete message observing the specified protocol
// version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) MaxPayloadLength(uint32) uint32 <span class="cov10" title="5">{
        // 32 (chain hash) + 1 (complete)
        return 33
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
)

// RevokeAndAck is sent by either side once a CommitSig message has been
// received, and validated. This message serves to revoke the prior commitment
// transaction, which was the most up to date version until a CommitSig message
// referencing the specified ChannelPoint was received.  Additionally, this
// message also piggyback's the next revocation hash that Alice should use when
// constructing the Bob's version of the next commitment transaction (which
// would be done before sending a CommitSig message).  This piggybacking allows
// Alice to send the next CommitSig message modifying Bob's commitment
// transaction without first asking for a revocation hash initially.
type RevokeAndAck struct {
        // ChanID uniquely identifies to which currently active channel this
        // RevokeAndAck applies to.
        ChanID ChannelID

        // Revocation is the preimage to the revocation hash of the now prior
        // commitment transaction.
        Revocation [32]byte

        // NextRevocationKey is the next commitment point which should be used
        // for the next commitment transaction the remote peer creates for us.
        // This, in conjunction without revocation base point will be used to
        // create the proper revocation key used within the commitment
        // transaction.
        NextRevocationKey *btcec.PublicKey
}

// NewRevokeAndAck creates a new RevokeAndAck message.
func NewRevokeAndAck() *RevokeAndAck <span class="cov0" title="0">{
        return &amp;RevokeAndAck{}
}</span>

// A compile time check to ensure RevokeAndAck implements the lnwire.Message
// interface.
var _ Message = (*RevokeAndAck)(nil)

// Decode deserializes a serialized RevokeAndAck message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) Decode(r io.Reader, pver uint32) error <span class="cov10" title="33">{
        return ReadElements(r,
                &amp;c.ChanID,
                c.Revocation[:],
                &amp;c.NextRevocationKey,
        )
}</span>

// Encode serializes the target RevokeAndAck into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) Encode(w io.Writer, pver uint32) error <span class="cov7" title="12">{
        return WriteElements(w,
                c.ChanID,
                c.Revocation[:],
                c.NextRevocationKey,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) MsgType() MessageType <span class="cov7" title="12">{
        return MsgRevokeAndAck
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a RevokeAndAck
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) MaxPayloadLength(uint32) uint32 <span class="cov10" title="33">{
        // 32 + 32 + 33
        return 97
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *RevokeAndAck) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package lnwire

import (
        "fmt"
)

// ShortChannelID represents the set of data which is needed to retrieve all
// necessary data to validate the channel existence.
type ShortChannelID struct {
        // BlockHeight is the height of the block where funding transaction
        // located.
        //
        // NOTE: This field is limited to 3 bytes.
        BlockHeight uint32

        // TxIndex is a position of funding transaction within a block.
        //
        // NOTE: This field is limited to 3 bytes.
        TxIndex uint32

        // TxPosition indicating transaction output which pays to the channel.
        TxPosition uint16
}

// NewShortChanIDFromInt returns a new ShortChannelID which is the decoded
// version of the compact channel ID encoded within the uint64. The format of
// the compact channel ID is as follows: 3 bytes for the block height, 3 bytes
// for the transaction index, and 2 bytes for the output index.
func NewShortChanIDFromInt(chanID uint64) ShortChannelID <span class="cov0" title="0">{
        return ShortChannelID{
                BlockHeight: uint32(chanID &gt;&gt; 40),
                TxIndex:     uint32(chanID&gt;&gt;16) &amp; 0xFFFFFF,
                TxPosition:  uint16(chanID),
        }
}</span>

// ToUint64 converts the ShortChannelID into a compact format encoded within a
// uint64 (8 bytes).
func (c ShortChannelID) ToUint64() uint64 <span class="cov10" title="375962">{
        // TODO(roasbeef): explicit error on overflow?
        return ((uint64(c.BlockHeight) &lt;&lt; 40) | (uint64(c.TxIndex) &lt;&lt; 16) |
                (uint64(c.TxPosition)))
}</span>

// String generates a human-readable representation of the channel ID.
func (c ShortChannelID) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d:%d:%d", c.BlockHeight, c.TxIndex, c.TxPosition)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package lnwire

import (
        "io"
)

// Shutdown is sent by either side in order to initiate the cooperative closure
// of a channel. This message is sparse as both sides implicitly have the
// information necessary to construct a transaction that will send the settled
// funds of both parties to the final delivery addresses negotiated during the
// funding workflow.
type Shutdown struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // Address is the script to which the channel funds will be paid.
        Address DeliveryAddress
}

// DeliveryAddress is used to communicate the address to which funds from a
// closed channel should be sent. The address can be a p2wsh, p2pkh, p2sh or
// p2wpkh.
type DeliveryAddress []byte

// deliveryAddressMaxSize is the maximum expected size in bytes of a
// DeliveryAddress based on the types of scripts we know.
// Following are the known scripts and their sizes in bytes.
// - pay to witness script hash: 34
// - pay to pubkey hash: 25
// - pay to script hash: 22
// - pay to witness pubkey hash: 22.
const deliveryAddressMaxSize = 34

// NewShutdown creates a new Shutdown message.
func NewShutdown(cid ChannelID, addr DeliveryAddress) *Shutdown <span class="cov0" title="0">{
        return &amp;Shutdown{
                ChannelID: cid,
                Address:   addr,
        }
}</span>

// A compile-time check to ensure Shutdown implements the lnwire.Message
// interface.
var _ Message = (*Shutdown)(nil)

// Decode deserializes a serialized Shutdown stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) Decode(r io.Reader, pver uint32) error <span class="cov10" title="18">{
        return ReadElements(r, &amp;s.ChannelID, &amp;s.Address)
}</span>

// Encode serializes the target Shutdown into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) Encode(w io.Writer, pver uint32) error <span class="cov7" title="7">{
        return WriteElements(w, s.ChannelID, s.Address)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) MsgType() MessageType <span class="cov7" title="7">{
        return MsgShutdown
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="18">{
        var length uint32

        // ChannelID - 32bytes
        length += 32

        // Len - 2 bytes
        length += 2

        // ScriptPubKey - maximum delivery address size.
        length += deliveryAddressMaxSize

        return length
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package lnwire

import (
        "fmt"

        "github.com/btcsuite/btcd/btcec"
)

// Sig is a fixed-sized ECDSA signature. Unlike Bitcoin, we use fixed sized
// signatures on the wire, instead of DER encoded signatures. This type
// provides several methods to convert to/from a regular Bitcoin DER encoded
// signature (raw bytes and *btcec.Signature).
type Sig [64]byte

// NewSigFromRawSignature returns a Sig from a Bitcoin raw signature encoded in
// the canonical DER encoding.
func NewSigFromRawSignature(sig []byte) (Sig, error) <span class="cov0" title="0">{
        var b Sig

        if len(sig) == 0 </span><span class="cov0" title="0">{
                return b, fmt.Errorf("cannot decode empty signature")
        }</span>

        // Extract lengths of R and S. The DER representation is laid out as
        // 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s
        // which means the length of R is the 4th byte and the length of S
        // is the second byte after R ends. 0x02 signifies a length-prefixed,
        // zero-padded, big-endian bigint. 0x30 signifies a DER signature.
        // See the Serialize() method for btcec.Signature for details.
        <span class="cov0" title="0">rLen := sig[3]
        sLen := sig[5+rLen]

        // Check to make sure R and S can both fit into their intended buffers.
        // We check S first because these code blocks decrement sLen and rLen
        // in the case of a 33-byte 0-padded integer returned from Serialize()
        // and rLen is used in calculating array indices for S. We can track
        // this with additional variables, but it's more efficient to just
        // check S first.
        if sLen &gt; 32 </span><span class="cov0" title="0">{
                if (sLen &gt; 33) || (sig[6+rLen] != 0x00) </span><span class="cov0" title="0">{
                        return b, fmt.Errorf("S is over 32 bytes long " +
                                "without padding")
                }</span>
                <span class="cov0" title="0">sLen--
                copy(b[64-sLen:], sig[7+rLen:])</span>
        } else<span class="cov0" title="0"> {
                copy(b[64-sLen:], sig[6+rLen:])
        }</span>

        // Do the same for R as we did for S
        <span class="cov0" title="0">if rLen &gt; 32 </span><span class="cov0" title="0">{
                if (rLen &gt; 33) || (sig[4] != 0x00) </span><span class="cov0" title="0">{
                        return b, fmt.Errorf("R is over 32 bytes long " +
                                "without padding")
                }</span>
                <span class="cov0" title="0">rLen--
                copy(b[32-rLen:], sig[5:5+rLen])</span>
        } else<span class="cov0" title="0"> {
                copy(b[32-rLen:], sig[4:4+rLen])
        }</span>

        <span class="cov0" title="0">return b, nil</span>
}

// NewSigFromSignature creates a new signature as used on the wire, from an
// existing btcec.Signature.
func NewSigFromSignature(e *btcec.Signature) (Sig, error) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return Sig{}, fmt.Errorf("cannot decode empty signature")
        }</span>

        // Serialize the signature with all the checks that entails.
        <span class="cov0" title="0">return NewSigFromRawSignature(e.Serialize())</span>
}

// ToSignature converts the fixed-sized signature to a btcec.Signature objects
// which can be used for signature validation checks.
func (b *Sig) ToSignature() (*btcec.Signature, error) <span class="cov0" title="0">{
        // Parse the signature with strict checks.
        sigBytes := b.ToSignatureBytes()
        sig, err := btcec.ParseDERSignature(sigBytes, btcec.S256())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}

// ToSignatureBytes serializes the target fixed-sized signature into the raw
// bytes of a DER encoding.
func (b *Sig) ToSignatureBytes() []byte <span class="cov0" title="0">{
        // Extract canonically-padded bigint representations from buffer
        r := extractCanonicalPadding(b[0:32])
        s := extractCanonicalPadding(b[32:64])
        rLen := uint8(len(r))
        sLen := uint8(len(s))

        // Create a canonical serialized signature. DER format is:
        // 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s
        sigBytes := make([]byte, 6+rLen+sLen)
        sigBytes[0] = 0x30            // DER signature magic value
        sigBytes[1] = 4 + rLen + sLen // Length of rest of signature
        sigBytes[2] = 0x02            // Big integer magic value
        sigBytes[3] = rLen            // Length of R
        sigBytes[rLen+4] = 0x02       // Big integer magic value
        sigBytes[rLen+5] = sLen       // Length of S
        copy(sigBytes[4:], r)         // Copy R
        copy(sigBytes[rLen+6:], s)    // Copy S

        return sigBytes
}</span>

// extractCanonicalPadding is a utility function to extract the canonical
// padding of a big-endian integer from the wire encoding (a 0-padded
// big-endian integer) such that it passes btcec.canonicalPadding test.
func extractCanonicalPadding(b []byte) []byte <span class="cov0" title="0">{
        for i := 0; i &lt; len(b); i++ </span><span class="cov0" title="0">{
                // Found first non-zero byte.
                if b[i] &gt; 0 </span><span class="cov0" title="0">{
                        // If the MSB is set, we need zero padding.
                        if b[i]&amp;0x80 == 0x80 </span><span class="cov0" title="0">{
                                return append([]byte{0x00}, b[i:]...)
                        }</span>
                        <span class="cov0" title="0">return b[i:]</span>
                }
        }
        <span class="cov0" title="0">return []byte{0x00}</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package lnwire

import (
        "io"
)

// OnionPacketSize is the size of the serialized Sphinx onion packet included
// in each UpdateAddHTLC message. The breakdown of the onion packet is as
// follows: 1-byte version, 33-byte ephemeral public key (for ECDH), 1300-bytes
// of per-hop data, and a 32-byte HMAC over the entire packet.
const OnionPacketSize = 1366

// UpdateAddHTLC is the message sent by Alice to Bob when she wishes to add an
// HTLC to his remote commitment transaction. In addition to information
// detailing the value, the ID, expiry, and the onion blob is also included
// which allows Bob to derive the next hop in the route. The HTLC added by this
// message is to be added to the remote node's "pending" HTLC's.  A subsequent
// CommitSig message will move the pending HTLC to the newly created commitment
// transaction, marking them as "staged".
type UpdateAddHTLC struct {
        // ChanID is the particular active channel that this UpdateAddHTLC is
        // bound to.
        ChanID ChannelID

        // ID is the identification server for this HTLC. This value is
        // explicitly included as it allows nodes to survive single-sided
        // restarts. The ID value for this sides starts at zero, and increases
        // with each offered HTLC.
        ID uint64

        // Amount is the amount of millisatoshis this HTLC is worth.
        Amount MilliSatoshi

        // PaymentHash is the payment hash to be included in the HTLC this
        // request creates. The pre-image to this HTLC must be revealed by the
        // upstream peer in order to fully settle the HTLC.
        PaymentHash [32]byte

        // Expiry is the number of blocks after which this HTLC should expire.
        // It is the receiver's duty to ensure that the outgoing HTLC has a
        // sufficient expiry value to allow her to redeem the incoming HTLC.
        Expiry uint32

        // OnionBlob is the raw serialized mix header used to route an HTLC in
        // a privacy-preserving manner. The mix header is defined currently to
        // be parsed as a 4-tuple: (groupElement, routingInfo, headerMAC,
        // body).  First the receiving node should use the groupElement, and
        // its current onion key to derive a shared secret with the source.
        // Once the shared secret has been derived, the headerMAC should be
        // checked FIRST. Note that the MAC only covers the routingInfo field.
        // If the MAC matches, and the shared secret is fresh, then the node
        // should strip off a layer of encryption, exposing the next hop to be
        // used in the subsequent UpdateAddHTLC message.
        OnionBlob [OnionPacketSize]byte
}

// NewUpdateAddHTLC returns a new empty UpdateAddHTLC message.
func NewUpdateAddHTLC() *UpdateAddHTLC <span class="cov0" title="0">{
        return &amp;UpdateAddHTLC{}
}</span>

// A compile time check to ensure UpdateAddHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateAddHTLC)(nil)

// Decode deserializes a serialized UpdateAddHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="7">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                &amp;c.Amount,
                c.PaymentHash[:],
                &amp;c.Expiry,
                c.OnionBlob[:],
        )
}</span>

// Encode serializes the target UpdateAddHTLC into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.Amount,
                c.PaymentHash[:],
                c.Expiry,
                c.OnionBlob[:],
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateAddHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateAddHTLC
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="7">{
        // 1450
        return 32 + 8 + 4 + 8 + 32 + 1366
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *UpdateAddHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package lnwire

import (
        "io"
)

// OpaqueReason is an opaque encrypted byte slice that encodes the exact
// failure reason and additional some supplemental data. The contents of this
// slice can only be decrypted by the sender of the original HTLC.
type OpaqueReason []byte

// UpdateFailHTLC is sent by Alice to Bob in order to remove a previously added
// HTLC. Upon receipt of an UpdateFailHTLC the HTLC should be removed from the
// next commitment transaction, with the UpdateFailHTLC propagated backwards in
// the route to fully undo the HTLC.
type UpdateFailHTLC struct {
        // ChanIDPoint is the particular active channel that this
        // UpdateFailHTLC is bound to.
        ChanID ChannelID

        // ID references which HTLC on the remote node's commitment transaction
        // has timed out.
        ID uint64

        // Reason is an onion-encrypted blob that details why the HTLC was
        // failed. This blob is only fully decryptable by the initiator of the
        // HTLC message.
        Reason OpaqueReason
}

// A compile time check to ensure UpdateFailHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateFailHTLC)(nil)

// Decode deserializes a serialized UpdateFailHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="12">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                &amp;c.Reason,
        )
}</span>

// Encode serializes the target UpdateFailHTLC into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) Encode(w io.Writer, pver uint32) error <span class="cov6" title="4">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.Reason,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) MsgType() MessageType <span class="cov6" title="4">{
        return MsgUpdateFailHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateFailHTLC
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="12">{
        var length uint32

        // Length of the ChanID
        length += 32

        // Length of the ID
        length += 8

        // Length of the length opaque reason
        length += 2

        // Length of the Reason
        length += 292

        return length
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *UpdateFailHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package lnwire

import (
        "crypto/sha256"
        "io"
)

// UpdateFailMalformedHTLC is sent by either the payment forwarder or by
// payment receiver to the payment sender in order to notify it that the onion
// blob can't be parsed. For that reason we send this message instead of
// obfuscate the onion failure.
type UpdateFailMalformedHTLC struct {
        // ChanID is the particular active channel that this
        // UpdateFailMalformedHTLC is bound to.
        ChanID ChannelID

        // ID references which HTLC on the remote node's commitment transaction
        // has timed out.
        ID uint64

        // ShaOnionBlob hash of the onion blob on which can't be parsed by the
        // node in the payment path.
        ShaOnionBlob [sha256.Size]byte

        // FailureCode the exact reason why onion blob haven't been parsed.
        FailureCode FailCode
}

// A compile time check to ensure UpdateFailMalformedHTLC implements the
// lnwire.Message interface.
var _ Message = (*UpdateFailMalformedHTLC)(nil)

// Decode deserializes a serialized UpdateFailMalformedHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="6">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                c.ShaOnionBlob[:],
                &amp;c.FailureCode,
        )
}</span>

// Encode serializes the target UpdateFailMalformedHTLC into the passed
// io.Writer observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.ShaOnionBlob[:],
                c.FailureCode,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFailMalformedHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// UpdateFailMalformedHTLC complete message observing the specified protocol
// version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="6">{
        // 32 +  8 + 32 + 2
        return 74
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *UpdateFailMalformedHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package lnwire

import (
        "io"
)

// UpdateFee is the message the channel initiator sends to the other peer if
// the channel commitment fee needs to be updated.
type UpdateFee struct {
        // ChanID is the channel that this UpdateFee is meant for.
        ChanID ChannelID

        // FeePerKw is the fee-per-kw on commit transactions that the sender of
        // this message wants to use for this channel.
        //
        // TODO(halseth): make SatPerKWeight when fee estimation is moved to
        // own package. Currently this will cause an import cycle.
        FeePerKw uint32
}

// NewUpdateFee creates a new UpdateFee message.
func NewUpdateFee(chanID ChannelID, feePerKw uint32) *UpdateFee <span class="cov0" title="0">{
        return &amp;UpdateFee{
                ChanID:   chanID,
                FeePerKw: feePerKw,
        }
}</span>

// A compile time check to ensure UpdateFee implements the lnwire.Message
// interface.
var _ Message = (*UpdateFee)(nil)

// Decode deserializes a serialized UpdateFee message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.FeePerKw,
        )
}</span>

// Encode serializes the target UpdateFee into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.FeePerKw,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFee
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateFee
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) MaxPayloadLength(uint32) uint32 <span class="cov10" title="4">{
        // 32 + 4
        return 36
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *UpdateFee) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package lnwire

import (
        "io"
)

// UpdateFulfillHTLC is sent by Alice to Bob when she wishes to settle a
// particular HTLC referenced by its HTLCKey within a specific active channel
// referenced by ChannelPoint.  A subsequent CommitSig message will be sent by
// Alice to "lock-in" the removal of the specified HTLC, possible containing a
// batch signature covering several settled HTLC's.
type UpdateFulfillHTLC struct {
        // ChanID references an active channel which holds the HTLC to be
        // settled.
        ChanID ChannelID

        // ID denotes the exact HTLC stage within the receiving node's
        // commitment transaction to be removed.
        ID uint64

        // PaymentPreimage is the R-value preimage required to fully settle an
        // HTLC.
        PaymentPreimage [32]byte
}

// NewUpdateFulfillHTLC returns a new empty UpdateFulfillHTLC.
func NewUpdateFulfillHTLC(chanID ChannelID, id uint64,
        preimage [32]byte) *UpdateFulfillHTLC <span class="cov0" title="0">{

        return &amp;UpdateFulfillHTLC{
                ChanID:          chanID,
                ID:              id,
                PaymentPreimage: preimage,
        }
}</span>

// A compile time check to ensure UpdateFulfillHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateFulfillHTLC)(nil)

// Decode deserializes a serialized UpdateFulfillHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="5">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                c.PaymentPreimage[:],
        )
}</span>

// Encode serializes the target UpdateFulfillHTLC into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.PaymentPreimage[:],
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFulfillHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateFulfillHTLC
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="5">{
        // 32 + 8 + 32
        return 72
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of lnd.LinkUpdater interface.
func (c *UpdateFulfillHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		</div>
	
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>

</body></html>