<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - cnode_cov.info - src/init.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - init.cpp<span style="font-size: 80%;"> (source / <a href="init.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">cnode_cov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">241</td>
            <td class="headerCovTableEntry">971</td>
            <td class="headerCovTableEntryLo">24.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-07-19 06:20:52</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">16.7 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2009-2010 Satoshi Nakamoto</a>
<span class="lineNum">       2 </span>            : // Copyright (c) 2009-2020 The Bitcoin Core developers
<span class="lineNum">       3 </span>            : // Distributed under the MIT software license, see the accompanying
<span class="lineNum">       4 </span>            : // file COPYING or http://www.opensource.org/licenses/mit-license.php.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #if defined(HAVE_CONFIG_H)
<span class="lineNum">       7 </span>            : #include &lt;config/bitcoin-config.h&gt;
<span class="lineNum">       8 </span>            : #endif
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;init.h&gt;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;addrman.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;amount.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;banman.h&gt;
<span class="lineNum">      15 </span>            : #include &lt;blockfilter.h&gt;
<span class="lineNum">      16 </span>            : #include &lt;chain.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;chainparams.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;compat/sanity.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;consensus/validation.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;fs.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;hash.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;httprpc.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;httpserver.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;index/blockfilterindex.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;index/txindex.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;interfaces/chain.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;key.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;miner.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;net.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;net_permissions.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;net_processing.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;netbase.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;node/context.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;node/ui_interface.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;policy/feerate.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;policy/fees.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;policy/policy.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;policy/settings.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;rpc/blockchain.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;rpc/register.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;rpc/server.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;rpc/util.h&gt;
<span class="lineNum">      43 </span>            : #include &lt;scheduler.h&gt;
<span class="lineNum">      44 </span>            : #include &lt;script/sigcache.h&gt;
<span class="lineNum">      45 </span>            : #include &lt;script/standard.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;shutdown.h&gt;
<span class="lineNum">      47 </span>            : #include &lt;sync.h&gt;
<span class="lineNum">      48 </span>            : #include &lt;timedata.h&gt;
<span class="lineNum">      49 </span>            : #include &lt;torcontrol.h&gt;
<span class="lineNum">      50 </span>            : #include &lt;txdb.h&gt;
<span class="lineNum">      51 </span>            : #include &lt;txmempool.h&gt;
<span class="lineNum">      52 </span>            : #include &lt;util/asmap.h&gt;
<span class="lineNum">      53 </span>            : #include &lt;util/check.h&gt;
<span class="lineNum">      54 </span>            : #include &lt;util/moneystr.h&gt;
<span class="lineNum">      55 </span>            : #include &lt;util/string.h&gt;
<span class="lineNum">      56 </span>            : #include &lt;util/system.h&gt;
<span class="lineNum">      57 </span>            : #include &lt;util/threadnames.h&gt;
<span class="lineNum">      58 </span>            : #include &lt;util/translation.h&gt;
<span class="lineNum">      59 </span>            : #include &lt;validation.h&gt;
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : #include &lt;validationinterface.h&gt;
<span class="lineNum">      62 </span>            : #include &lt;walletinitinterface.h&gt;
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #include &lt;functional&gt;
<span class="lineNum">      65 </span>            : #include &lt;set&gt;
<span class="lineNum">      66 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      67 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #ifndef WIN32
<span class="lineNum">      70 </span>            : #include &lt;attributes.h&gt;
<span class="lineNum">      71 </span>            : #include &lt;cerrno&gt;
<span class="lineNum">      72 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      73 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      74 </span>            : #endif
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : #include &lt;boost/algorithm/string/replace.hpp&gt;
<span class="lineNum">      77 </span>            : #include &lt;boost/signals2/signal.hpp&gt;
<span class="lineNum">      78 </span>            : #include &lt;boost/thread/thread.hpp&gt;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : #if ENABLE_ZMQ
<span class="lineNum">      81 </span>            : #include &lt;zmq/zmqabstractnotifier.h&gt;
<span class="lineNum">      82 </span>            : #include &lt;zmq/zmqnotificationinterface.h&gt;
<span class="lineNum">      83 </span>            : #include &lt;zmq/zmqrpc.h&gt;
<span class="lineNum">      84 </span>            : #endif
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : static bool fFeeEstimatesInitialized = false;
<span class="lineNum">      87 </span>            : static const bool DEFAULT_PROXYRANDOMIZE = true;
<span class="lineNum">      88 </span>            : static const bool DEFAULT_REST_ENABLE = false;
<span class="lineNum">      89 </span>            : static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : #ifdef WIN32
<span class="lineNum">      92 </span>            : // Win32 LevelDB doesn't use filedescriptors, and the ones used for
<span class="lineNum">      93 </span>            : // accessing block files don't count towards the fd_set size limit
<span class="lineNum">      94 </span>            : // anyway.
<span class="lineNum">      95 </span>            : #define MIN_CORE_FILEDESCRIPTORS 0
<span class="lineNum">      96 </span>            : #else
<span class="lineNum">      97 </span>            : #define MIN_CORE_FILEDESCRIPTORS 150
<span class="lineNum">      98 </span>            : #endif
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : static const char* FEE_ESTIMATES_FILENAME=&quot;fee_estimates.dat&quot;;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : static const char* DEFAULT_ASMAP_FILENAME=&quot;ip_asn.map&quot;;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : /**
<span class="lineNum">     105 </span>            :  * The PID file facilities.
<span class="lineNum">     106 </span>            :  */
<span class="lineNum">     107 </span>            : static const char* BITCOIN_PID_FILENAME = &quot;bitcoind.pid&quot;;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 : static fs::path GetPidFile()</span>
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     return AbsPathForConfigVal(fs::path(gArgs.GetArg(&quot;-pid&quot;, BITCOIN_PID_FILENAME)));</span>
<span class="lineNum">     112 </span>            : }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 : NODISCARD static bool CreatePidFile()</span>
<span class="lineNum">     115 </span>            : {
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     fsbridge::ofstream file{GetPidFile()};</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     if (file) {</span>
<span class="lineNum">     118 </span>            : #ifdef WIN32
<span class="lineNum">     119 </span>            :         tfm::format(file, &quot;%d\n&quot;, GetCurrentProcessId());
<span class="lineNum">     120 </span>            : #else
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         tfm::format(file, &quot;%d\n&quot;, getpid());</span>
<span class="lineNum">     122 </span>            : #endif
<span class="lineNum">     123 </span>            :         return true;
<span class="lineNum">     124 </span>            :     } else {
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;Unable to create the PID file '%s': %s&quot;), GetPidFile().string(), std::strerror(errno)));</span>
<span class="lineNum">     126 </span>            :     }
<span class="lineNum">     127 </span>            : }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     130 </span>            : //
<span class="lineNum">     131 </span>            : // Shutdown
<span class="lineNum">     132 </span>            : //
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : //
<span class="lineNum">     135 </span>            : // Thread management and startup/shutdown:
<span class="lineNum">     136 </span>            : //
<span class="lineNum">     137 </span>            : // The network-processing threads are all part of a thread group
<span class="lineNum">     138 </span>            : // created by AppInit() or the Qt main() function.
<span class="lineNum">     139 </span>            : //
<span class="lineNum">     140 </span>            : // A clean exit happens when StartShutdown() or the SIGTERM
<span class="lineNum">     141 </span>            : // signal handler sets ShutdownRequested(), which makes main thread's
<span class="lineNum">     142 </span>            : // WaitForShutdown() interrupts the thread group.
<span class="lineNum">     143 </span>            : // And then, WaitForShutdown() makes all other on-going threads
<span class="lineNum">     144 </span>            : // in the thread group join the main thread.
<span class="lineNum">     145 </span>            : // Shutdown() is then called to clean up database connections, and stop other
<span class="lineNum">     146 </span>            : // threads that should only be stopped after the main network-processing
<span class="lineNum">     147 </span>            : // threads have exited.
<span class="lineNum">     148 </span>            : //
<span class="lineNum">     149 </span>            : // Shutdown for Qt is very similar, only it uses a QTimer to detect
<span class="lineNum">     150 </span>            : // ShutdownRequested() getting set, and then does the normal Qt
<span class="lineNum">     151 </span>            : // shutdown thing.
<span class="lineNum">     152 </span>            : //
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineCov">     104927 : static std::unique_ptr&lt;ECCVerifyHandle&gt; globalVerifyHandle;</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineCov">     104927 : static std::thread g_load_block;</span>
<span class="lineNum">     157 </span>            : 
<a name="158"><span class="lineNum">     158 </span><span class="lineCov">     104927 : static boost::thread_group threadGroup;</span></a>
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span><span class="lineNoCov">          0 : void Interrupt(NodeContext&amp; node)</span>
<span class="lineNum">     161 </span>            : {
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     InterruptHTTPServer();</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     InterruptHTTPRPC();</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     InterruptRPC();</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     InterruptREST();</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     InterruptTorControl();</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     InterruptMapPort();</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     if (node.connman)</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         node.connman-&gt;Interrupt();</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     if (g_txindex) {</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         g_txindex-&gt;Interrupt();</span>
<span class="lineNum">     172 </span>            :     }
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     ForEachBlockFilterIndex([](BlockFilterIndex&amp; index) { index.Interrupt(); });</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : void Shutdown(NodeContext&amp; node)</span>
<span class="lineNum">     177 </span>            : {
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     static Mutex g_shutdown_mutex;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     TRY_LOCK(g_shutdown_mutex, lock_shutdown);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     if (!lock_shutdown) return;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;%s: In progress...\n&quot;, __func__);</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :     /// Note: Shutdown() must be able to handle cases in which initialization failed part of the way,
<span class="lineNum">     184 </span>            :     /// for example if the data directory was found to be locked.
<span class="lineNum">     185 </span>            :     /// Be sure that anything that writes files or flushes caches only does this if the respective
<span class="lineNum">     186 </span>            :     /// module was initialized.
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     util::ThreadRename(&quot;shutoff&quot;);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     mempool.AddTransactionsUpdated(1);</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     StopHTTPRPC();</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     StopREST();</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     StopRPC();</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     StopHTTPServer();</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     for (const auto&amp; client : node.chain_clients) {</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         client-&gt;flush();</span>
<span class="lineNum">     196 </span>            :     }
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     StopMapPort();</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :     // Because these depend on each-other, we make sure that neither can be
<span class="lineNum">     200 </span>            :     // using the other before destroying them.
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     if (node.peer_logic) UnregisterValidationInterface(node.peer_logic.get());</span>
<span class="lineNum">     202 </span>            :     // Follow the lock order requirements:
<span class="lineNum">     203 </span>            :     // * CheckForStaleTipAndEvictPeers locks cs_main before indirectly calling GetExtraOutboundCount
<span class="lineNum">     204 </span>            :     //   which locks cs_vNodes.
<span class="lineNum">     205 </span>            :     // * ProcessMessage locks cs_main and g_cs_orphans before indirectly calling ForEachNode which
<span class="lineNum">     206 </span>            :     //   locks cs_vNodes.
<span class="lineNum">     207 </span>            :     // * CConnman::Stop calls DeleteNode, which calls FinalizeNode, which locks cs_main and calls
<span class="lineNum">     208 </span>            :     //   EraseOrphansFor, which locks g_cs_orphans.
<span class="lineNum">     209 </span>            :     //
<span class="lineNum">     210 </span>            :     // Thus the implicit locking order requirement is: (1) cs_main, (2) g_cs_orphans, (3) cs_vNodes.
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (node.connman) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         node.connman-&gt;StopThreads();</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         LOCK2(::cs_main, ::g_cs_orphans);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         node.connman-&gt;StopNodes();</span>
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     StopTorControl();</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :     // After everything has been shut down, but before things get flushed, stop the
<span class="lineNum">     220 </span>            :     // CScheduler/checkqueue, threadGroup and load block thread.
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (node.scheduler) node.scheduler-&gt;stop();</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     if (g_load_block.joinable()) g_load_block.join();</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     threadGroup.interrupt_all();</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     threadGroup.join_all();</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     // After the threads that potentially access these pointers have been stopped,
<span class="lineNum">     227 </span>            :     // destruct and reset all to nullptr.
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     node.peer_logic.reset();</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     node.connman.reset();</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     node.banman.reset();</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (::mempool.IsLoaded() &amp;&amp; gArgs.GetArg(&quot;-persistmempool&quot;, DEFAULT_PERSIST_MEMPOOL)) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         DumpMempool(::mempool);</span>
<span class="lineNum">     234 </span>            :     }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     if (fFeeEstimatesInitialized)</span>
<span class="lineNum">     237 </span>            :     {
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         ::feeEstimator.FlushUnconfirmed();</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         CAutoFile est_fileout(fsbridge::fopen(est_path, &quot;wb&quot;), SER_DISK, CLIENT_VERSION);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         if (!est_fileout.IsNull())</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :             ::feeEstimator.Write(est_fileout);</span>
<span class="lineNum">     243 </span>            :         else
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: Failed to write fee estimates to %s\n&quot;, __func__, est_path.string());</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         fFeeEstimatesInitialized = false;</span>
<span class="lineNum">     246 </span>            :     }
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if (node.chainman) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         LOCK(cs_main);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         for (CChainState* chainstate : node.chainman-&gt;GetAll()) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :             if (chainstate-&gt;CanFlushToDisk()) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :                 chainstate-&gt;ForceFlushStateToDisk();</span>
<span class="lineNum">     254 </span>            :             }
<span class="lineNum">     255 </span>            :         }
<span class="lineNum">     256 </span>            :     }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :     // After there are no more peers/RPC left to give us new data which may generate
<span class="lineNum">     259 </span>            :     // CValidationInterface callbacks, flush them...
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     GetMainSignals().FlushBackgroundCallbacks();</span>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :     // Stop and delete all indexes only after flushing background callbacks.
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     if (g_txindex) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         g_txindex-&gt;Stop();</span>
<span class="lineNum">     265 </span>            :         g_txindex.reset();
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     ForEachBlockFilterIndex([](BlockFilterIndex&amp; index) { index.Stop(); });</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     DestroyAllBlockFilterIndexes();</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :     // Any future callbacks will be dropped. This should absolutely be safe - if
<span class="lineNum">     271 </span>            :     // missing a callback results in an unrecoverable situation, unclean shutdown
<span class="lineNum">     272 </span>            :     // would too. The only reason to do the above flushes is to let the wallet catch
<span class="lineNum">     273 </span>            :     // up with our current chain to avoid any strange pruning edge cases and make
<span class="lineNum">     274 </span>            :     // next startup faster by avoiding rescan.
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     if (node.chainman) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :         LOCK(cs_main);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         for (CChainState* chainstate : node.chainman-&gt;GetAll()) {</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :             if (chainstate-&gt;CanFlushToDisk()) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                 chainstate-&gt;ForceFlushStateToDisk();</span>
<span class="lineNum">     281 </span>            :                 chainstate-&gt;ResetCoinsViews();
<span class="lineNum">     282 </span>            :             }
<span class="lineNum">     283 </span>            :         }
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         pblocktree.reset();</span>
<span class="lineNum">     285 </span>            :     }
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     for (const auto&amp; client : node.chain_clients) {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         client-&gt;stop();</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : #if ENABLE_ZMQ
<span class="lineNum">     291 </span>            :     if (g_zmq_notification_interface) {
<span class="lineNum">     292 </span>            :         UnregisterValidationInterface(g_zmq_notification_interface);
<span class="lineNum">     293 </span>            :         delete g_zmq_notification_interface;
<span class="lineNum">     294 </span>            :         g_zmq_notification_interface = nullptr;
<span class="lineNum">     295 </span>            :     }
<span class="lineNum">     296 </span>            : #endif
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     node.chain_clients.clear();</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     UnregisterAllValidationInterfaces();</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     GetMainSignals().UnregisterBackgroundSignalScheduler();</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     globalVerifyHandle.reset();</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     ECC_Stop();</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     node.args = nullptr;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     node.mempool = nullptr;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     node.chainman = nullptr;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     node.scheduler.reset();</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     try {
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         if (!fs::remove(GetPidFile())) {</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: Unable to remove PID file: File does not exist\n&quot;, __func__);</span>
<span class="lineNum">     311 </span>            :         }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     } catch (const fs::filesystem_error&amp; e) {</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;%s: Unable to remove PID file: %s\n&quot;, __func__, fsbridge::get_filesystem_error_message(e));</span>
<span class="lineNum">     314 </span>            :     }
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;%s: done\n&quot;, __func__);</span>
<span class="lineNum">     317 </span>            : }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : /**
<span class="lineNum">     320 </span>            :  * Signal handlers are very limited in what they are allowed to do.
<span class="lineNum">     321 </span>            :  * The execution context the handler is invoked in is not guaranteed,
<span class="lineNum">     322 </span>            :  * so we restrict handler operations to just touching variables:
<a name="323"><span class="lineNum">     323 </span>            :  */</a>
<span class="lineNum">     324 </span>            : #ifndef WIN32
<span class="lineNum">     325 </span><span class="lineNoCov">          0 : static void HandleSIGTERM(int)</span>
<span class="lineNum">     326 </span>            : {
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     StartShutdown();</span>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : static void HandleSIGHUP(int)</span>
<span class="lineNum">     331 </span>            : {
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     LogInstance().m_reopen_file = true;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     334 </span>            : #else
<span class="lineNum">     335 </span>            : static BOOL WINAPI consoleCtrlHandler(DWORD dwCtrlType)
<span class="lineNum">     336 </span>            : {
<span class="lineNum">     337 </span>            :     StartShutdown();
<span class="lineNum">     338 </span>            :     Sleep(INFINITE);
<span class="lineNum">     339 </span>            :     return true;
<span class="lineNum">     340 </span>            : }
<span class="lineNum">     341 </span>            : #endif
<a name="342"><span class="lineNum">     342 </span>            : </a>
<span class="lineNum">     343 </span>            : #ifndef WIN32
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : static void registerSignalHandler(int signal, void(*handler)(int))</span>
<span class="lineNum">     345 </span>            : {
<span class="lineNum">     346 </span>            :     struct sigaction sa;
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     sa.sa_handler = handler;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     sigemptyset(&amp;sa.sa_mask);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     sa.sa_flags = 0;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     sigaction(signal, &amp;sa, nullptr);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     352 </span>            : #endif
<a name="353"><span class="lineNum">     353 </span>            : </a>
<span class="lineNum">     354 </span><span class="lineCov">     104927 : static boost::signals2::connection rpc_notify_block_change_connection;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 : static void OnRPCStarted()</span>
<span class="lineNum">     356 </span>            : {
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     rpc_notify_block_change_connection = uiInterface.NotifyBlockTip_connect(std::bind(RPCNotifyBlockChange, std::placeholders::_2));</span>
<a name="358"><span class="lineNum">     358 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 : static void OnRPCStopped()</span>
<span class="lineNum">     361 </span>            : {
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     rpc_notify_block_change_connection.disconnect();</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     RPCNotifyBlockChange(nullptr);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     g_best_block_cv.notify_all();</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     LogPrint(BCLog::RPC, &quot;RPC stopped.\n&quot;);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">     104927 : void SetupServerArgs(NodeContext&amp; node)</span>
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span><span class="lineCov">     104927 :     assert(!node.args);</span>
<span class="lineNum">     371 </span><span class="lineCov">     104927 :     node.args = &amp;gArgs;</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineCov">     104927 :     SetupHelpOptions(gArgs);</span>
<span class="lineNum">     374 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-help-debug&quot;, &quot;Print help message with debugging options and exit&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineCov">     209854 :     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);</span>
<span class="lineNum">     377 </span><span class="lineCov">     209854 :     const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);</span>
<span class="lineNum">     378 </span><span class="lineCov">     209854 :     const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);</span>
<span class="lineNum">     379 </span><span class="lineCov">     209854 :     const auto defaultChainParams = CreateChainParams(CBaseChainParams::MAIN);</span>
<span class="lineNum">     380 </span><span class="lineCov">     209854 :     const auto testnetChainParams = CreateChainParams(CBaseChainParams::TESTNET);</span>
<span class="lineNum">     381 </span><span class="lineCov">     209854 :     const auto regtestChainParams = CreateChainParams(CBaseChainParams::REGTEST);</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :     // Hidden Options
<span class="lineNum">     384 </span>            :     std::vector&lt;std::string&gt; hidden_args = {
<span class="lineNum">     385 </span>            :         &quot;-dbcrashratio&quot;, &quot;-forcecompactdb&quot;,
<span class="lineNum">     386 </span>            :         // GUI args. These will be overwritten by SetupUIArgs for the GUI
<span class="lineNum">     387 </span><span class="lineCov">    1154197 :         &quot;-choosedatadir&quot;, &quot;-lang=&lt;lang&gt;&quot;, &quot;-min&quot;, &quot;-resetguisettings&quot;, &quot;-splash&quot;, &quot;-uiplatform&quot;};</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-version&quot;, &quot;Print version and exit&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     390 </span>            : #if HAVE_SYSTEM
<span class="lineNum">     391 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-alertnotify=&lt;cmd&gt;&quot;, &quot;Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     392 </span>            : #endif
<span class="lineNum">     393 </span><span class="lineCov">     944343 :     gArgs.AddArg(&quot;-assumevalid=&lt;hex&gt;&quot;, strprintf(&quot;If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)&quot;, defaultChainParams-&gt;GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams-&gt;GetConsensus().defaultAssumeValid.GetHex()), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     394 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-blocksdir=&lt;dir&gt;&quot;, &quot;Specify directory to hold blocks subdirectory for *.dat files (default: &lt;datadir&gt;)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     395 </span>            : #if HAVE_SYSTEM
<span class="lineNum">     396 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-blocknotify=&lt;cmd&gt;&quot;, &quot;Execute command when the best block changes (%s in cmd is replaced by block hash)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     397 </span>            : #endif
<span class="lineNum">     398 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-blockreconstructionextratxn=&lt;n&gt;&quot;, strprintf(&quot;Extra transactions to keep in memory for compact block reconstructions (default: %u)&quot;, DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     399 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-blocksonly&quot;, strprintf(&quot;Whether to reject transactions from network peers. Automatic broadcast and rebroadcast of any transactions from inbound peers is disabled, unless the peer has the 'forcerelay' permission. RPC transactions are not affected. (default: %u)&quot;, DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     400 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-conf=&lt;file&gt;&quot;, strprintf(&quot;Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)&quot;, BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     401 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-datadir=&lt;dir&gt;&quot;, &quot;Specify data directory&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     402 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-dbbatchsize&quot;, strprintf(&quot;Maximum database write batch size in bytes (default: %u)&quot;, nDefaultDbBatchSize), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     403 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-dbcache=&lt;n&gt;&quot;, strprintf(&quot;Maximum database cache size &lt;n&gt; MiB (%d to %d, default: %d). In addition, unused mempool memory is shared for this cache (see -maxmempool).&quot;, nMinDbCache, nMaxDbCache, nDefaultDbCache), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     404 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-debuglogfile=&lt;file&gt;&quot;, strprintf(&quot;Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)&quot;, DEFAULT_DEBUGLOGFILE), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     405 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-feefilter&quot;, strprintf(&quot;Tell other nodes to filter invs to us by our mempool min fee (default: %u)&quot;, DEFAULT_FEEFILTER), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     406 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-includeconf=&lt;file&gt;&quot;, &quot;Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     407 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-loadblock=&lt;file&gt;&quot;, &quot;Imports blocks from external file on startup&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     408 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxmempool=&lt;n&gt;&quot;, strprintf(&quot;Keep the transaction memory pool below &lt;n&gt; megabytes (default: %u)&quot;, DEFAULT_MAX_MEMPOOL_SIZE), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     409 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxorphantx=&lt;n&gt;&quot;, strprintf(&quot;Keep at most &lt;n&gt; unconnectable transactions in memory (default: %u)&quot;, DEFAULT_MAX_ORPHAN_TRANSACTIONS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     410 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-mempoolexpiry=&lt;n&gt;&quot;, strprintf(&quot;Do not keep transactions in the mempool longer than &lt;n&gt; hours (default: %u)&quot;, DEFAULT_MEMPOOL_EXPIRY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     411 </span><span class="lineCov">     944343 :     gArgs.AddArg(&quot;-minimumchainwork=&lt;hex&gt;&quot;, strprintf(&quot;Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)&quot;, defaultChainParams-&gt;GetConsensus().nMinimumChainWork.GetHex(), testnetChainParams-&gt;GetConsensus().nMinimumChainWork.GetHex()), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     412 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-par=&lt;n&gt;&quot;, strprintf(&quot;Set the number of script verification threads (%u to %d, 0 = auto, &lt;0 = leave that many cores free, default: %d)&quot;,</span>
<span class="lineNum">     413 </span><span class="lineCov">     104927 :         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     414 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-persistmempool&quot;, strprintf(&quot;Whether to save the mempool on shutdown and load on restart (default: %u)&quot;, DEFAULT_PERSIST_MEMPOOL), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     415 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-pid=&lt;file&gt;&quot;, strprintf(&quot;Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)&quot;, BITCOIN_PID_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     416 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-prune=&lt;n&gt;&quot;, strprintf(&quot;Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. &quot;</span>
<span class="lineNum">     417 </span>            :             &quot;Warning: Reverting this setting requires re-downloading the entire blockchain. &quot;
<span class="lineNum">     418 </span><span class="lineCov">     104927 :             &quot;(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, &gt;=%u = automatically prune block files to stay under the specified target size in MiB)&quot;, MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     419 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-reindex&quot;, &quot;Rebuild chain state and block index from the blk*.dat files on disk&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     420 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-reindex-chainstate&quot;, &quot;Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     421 </span>            : #ifndef WIN32
<span class="lineNum">     422 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-sysperms&quot;, &quot;Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     423 </span>            : #else
<span class="lineNum">     424 </span>            :     hidden_args.emplace_back(&quot;-sysperms&quot;);
<span class="lineNum">     425 </span>            : #endif
<span class="lineNum">     426 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-txindex&quot;, strprintf(&quot;Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)&quot;, DEFAULT_TXINDEX), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     427 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-blockfilterindex=&lt;type&gt;&quot;,</span>
<span class="lineNum">     428 </span><span class="lineCov">     314781 :                  strprintf(&quot;Maintain an index of compact filters by block (default: %s, values: %s).&quot;, DEFAULT_BLOCKFILTERINDEX, ListBlockFilterTypes()) +</span>
<span class="lineNum">     429 </span>            :                  &quot; If &lt;type&gt; is not supplied or if &lt;type&gt; = 1, indexes for all known types are enabled.&quot;,
<span class="lineNum">     430 </span>            :                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-addnode=&lt;ip&gt;&quot;, &quot;Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.&quot;, ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     433 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-asmap=&lt;file&gt;&quot;, strprintf(&quot;Specify asn mapping used for bucketing of the peers (default: %s). Relative paths will be prefixed by the net-specific datadir location.&quot;, DEFAULT_ASMAP_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     434 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-bantime=&lt;n&gt;&quot;, strprintf(&quot;Default duration (in seconds) of manually configured bans (default: %u)&quot;, DEFAULT_MISBEHAVING_BANTIME), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     435 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-bind=&lt;addr&gt;&quot;, &quot;Bind to given address and always listen on it. Use [host]:port notation for IPv6&quot;, ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     436 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-connect=&lt;ip&gt;&quot;, &quot;Connect only to the specified node; -noconnect disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.&quot;, ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     437 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-discover&quot;, &quot;Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     438 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-dns&quot;, strprintf(&quot;Allow DNS lookups for -addnode, -seednode and -connect (default: %u)&quot;, DEFAULT_NAME_LOOKUP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     439 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-dnsseed&quot;, &quot;Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     440 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-externalip=&lt;ip&gt;&quot;, &quot;Specify your own public address&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     441 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-forcednsseed&quot;, strprintf(&quot;Always query for peer addresses via DNS lookup (default: %u)&quot;, DEFAULT_FORCEDNSSEED), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     442 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-listen&quot;, &quot;Accept connections from outside (default: 1 if no -proxy or -connect)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     443 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-listenonion&quot;, strprintf(&quot;Automatically create Tor hidden service (default: %d)&quot;, DEFAULT_LISTEN_ONION), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     444 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxconnections=&lt;n&gt;&quot;, strprintf(&quot;Maintain at most &lt;n&gt; connections to peers (default: %u)&quot;, DEFAULT_MAX_PEER_CONNECTIONS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     445 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxreceivebuffer=&lt;n&gt;&quot;, strprintf(&quot;Maximum per-connection receive buffer, &lt;n&gt;*1000 bytes (default: %u)&quot;, DEFAULT_MAXRECEIVEBUFFER), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     446 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxsendbuffer=&lt;n&gt;&quot;, strprintf(&quot;Maximum per-connection send buffer, &lt;n&gt;*1000 bytes (default: %u)&quot;, DEFAULT_MAXSENDBUFFER), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     447 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxtimeadjustment&quot;, strprintf(&quot;Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)&quot;, DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     448 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxuploadtarget=&lt;n&gt;&quot;, strprintf(&quot;Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)&quot;, DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     449 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-onion=&lt;ip:port&gt;&quot;, &quot;Use separate SOCKS5 proxy to reach peers via Tor hidden services, set -noonion to disable (default: -proxy)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     450 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-onlynet=&lt;net&gt;&quot;, &quot;Make outgoing connections only through network &lt;net&gt; (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     451 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-peerbloomfilters&quot;, strprintf(&quot;Support filtering of blocks and transaction with bloom filters (default: %u)&quot;, DEFAULT_PEERBLOOMFILTERS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     452 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-peerblockfilters&quot;, strprintf(&quot;Serve compact block filters to peers per BIP 157 (default: %u)&quot;, DEFAULT_PEERBLOCKFILTERS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     453 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-permitbaremultisig&quot;, strprintf(&quot;Relay non-P2SH multisig (default: %u)&quot;, DEFAULT_PERMIT_BAREMULTISIG), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     454 </span><span class="lineCov">     839416 :     gArgs.AddArg(&quot;-port=&lt;port&gt;&quot;, strprintf(&quot;Listen for connections on &lt;port&gt; (default: %u, testnet: %u, regtest: %u)&quot;, defaultChainParams-&gt;GetDefaultPort(), testnetChainParams-&gt;GetDefaultPort(), regtestChainParams-&gt;GetDefaultPort()), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     455 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-proxy=&lt;ip:port&gt;&quot;, &quot;Connect through SOCKS5 proxy, set -noproxy to disable (default: disabled)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     456 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-proxyrandomize&quot;, strprintf(&quot;Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)&quot;, DEFAULT_PROXYRANDOMIZE), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     457 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-seednode=&lt;ip&gt;&quot;, &quot;Connect to a node to retrieve peer addresses, and disconnect. This option can be specified multiple times to connect to multiple nodes.&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     458 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-timeout=&lt;n&gt;&quot;, strprintf(&quot;Specify connection timeout in milliseconds (minimum: 1, default: %d)&quot;, DEFAULT_CONNECT_TIMEOUT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     459 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-peertimeout=&lt;n&gt;&quot;, strprintf(&quot;Specify p2p connection timeout in seconds. This option determines the amount of time a peer may be inactive before the connection to it is dropped. (minimum: 1, default: %d)&quot;, DEFAULT_PEER_CONNECT_TIMEOUT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     460 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-torcontrol=&lt;ip&gt;:&lt;port&gt;&quot;, strprintf(&quot;Tor control port to use if onion listening enabled (default: %s)&quot;, DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     461 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-torpassword=&lt;pass&gt;&quot;, &quot;Tor control port password (default: empty)&quot;, ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);</span>
<span class="lineNum">     462 </span>            : #ifdef USE_UPNP
<span class="lineNum">     463 </span>            : #if USE_UPNP
<span class="lineNum">     464 </span>            :     gArgs.AddArg(&quot;-upnp&quot;, &quot;Use UPnP to map the listening port (default: 1 when listening and no -proxy)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
<span class="lineNum">     465 </span>            : #else
<span class="lineNum">     466 </span>            :     gArgs.AddArg(&quot;-upnp&quot;, strprintf(&quot;Use UPnP to map the listening port (default: %u)&quot;, 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
<span class="lineNum">     467 </span>            : #endif
<span class="lineNum">     468 </span>            : #else
<span class="lineNum">     469 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-upnp&quot;);</span>
<span class="lineNum">     470 </span>            : #endif
<span class="lineNum">     471 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-whitebind=&lt;[permissions@]addr&gt;&quot;, &quot;Bind to the given address and add permission flags to the peers connecting to it. &quot;</span>
<span class="lineNum">     472 </span><span class="lineCov">     734489 :         &quot;Use [host]:port notation for IPv6. Allowed permissions: &quot; + Join(NET_PERMISSIONS_DOC, &quot;, &quot;) + &quot;. &quot;</span>
<span class="lineNum">     473 </span>            :         &quot;Specify multiple permissions separated by commas (default: download,noban,mempool,relay). Can be specified multiple times.&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-whitelist=&lt;[permissions@]IP address or network&gt;&quot;, &quot;Add permission flags to the peers connecting from the given IP address (e.g. 1.2.3.4) or &quot;</span>
<span class="lineNum">     476 </span>            :         &quot;CIDR-notated network (e.g. 1.2.3.0/24). Uses the same permissions as &quot;
<span class="lineNum">     477 </span>            :         &quot;-whitebind. Can be specified multiple times.&quot; , ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">     104927 :     g_wallet_init_interface.AddWalletOptions();</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : #if ENABLE_ZMQ
<span class="lineNum">     482 </span>            :     gArgs.AddArg(&quot;-zmqpubhashblock=&lt;address&gt;&quot;, &quot;Enable publish hash block in &lt;address&gt;&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     483 </span>            :     gArgs.AddArg(&quot;-zmqpubhashtx=&lt;address&gt;&quot;, &quot;Enable publish hash transaction in &lt;address&gt;&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     484 </span>            :     gArgs.AddArg(&quot;-zmqpubrawblock=&lt;address&gt;&quot;, &quot;Enable publish raw block in &lt;address&gt;&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     485 </span>            :     gArgs.AddArg(&quot;-zmqpubrawtx=&lt;address&gt;&quot;, &quot;Enable publish raw transaction in &lt;address&gt;&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     486 </span>            :     gArgs.AddArg(&quot;-zmqpubhashblockhwm=&lt;n&gt;&quot;, strprintf(&quot;Set publish hash block outbound message high water mark (default: %d)&quot;, CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     487 </span>            :     gArgs.AddArg(&quot;-zmqpubhashtxhwm=&lt;n&gt;&quot;, strprintf(&quot;Set publish hash transaction outbound message high water mark (default: %d)&quot;, CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     488 </span>            :     gArgs.AddArg(&quot;-zmqpubrawblockhwm=&lt;n&gt;&quot;, strprintf(&quot;Set publish raw block outbound message high water mark (default: %d)&quot;, CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     489 </span>            :     gArgs.AddArg(&quot;-zmqpubrawtxhwm=&lt;n&gt;&quot;, strprintf(&quot;Set publish raw transaction outbound message high water mark (default: %d)&quot;, CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
<span class="lineNum">     490 </span>            : #else
<span class="lineNum">     491 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubhashblock=&lt;address&gt;&quot;);</span>
<span class="lineNum">     492 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubhashtx=&lt;address&gt;&quot;);</span>
<span class="lineNum">     493 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubrawblock=&lt;address&gt;&quot;);</span>
<span class="lineNum">     494 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubrawtx=&lt;address&gt;&quot;);</span>
<span class="lineNum">     495 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubhashblockhwm=&lt;n&gt;&quot;);</span>
<span class="lineNum">     496 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubhashtxhwm=&lt;n&gt;&quot;);</span>
<span class="lineNum">     497 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubrawblockhwm=&lt;n&gt;&quot;);</span>
<span class="lineNum">     498 </span><span class="lineCov">     104927 :     hidden_args.emplace_back(&quot;-zmqpubrawtxhwm=&lt;n&gt;&quot;);</span>
<span class="lineNum">     499 </span>            : #endif
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-checkblocks=&lt;n&gt;&quot;, strprintf(&quot;How many blocks to check at startup (default: %u, 0 = all)&quot;, DEFAULT_CHECKBLOCKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     502 </span><span class="lineCov">     944343 :     gArgs.AddArg(&quot;-checklevel=&lt;n&gt;&quot;, strprintf(&quot;How thorough the block verification of -checkblocks is: %s (0-4, default: %u)&quot;, Join(CHECKLEVEL_DOC, &quot;, &quot;), DEFAULT_CHECKLEVEL), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     503 </span><span class="lineCov">     734489 :     gArgs.AddArg(&quot;-checkblockindex&quot;, strprintf(&quot;Do a consistency check for the block tree, chainstate, and other validation data structures occasionally. (default: %u, regtest: %u)&quot;, defaultChainParams-&gt;DefaultConsistencyChecks(), regtestChainParams-&gt;DefaultConsistencyChecks()), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     504 </span><span class="lineCov">     734489 :     gArgs.AddArg(&quot;-checkmempool=&lt;n&gt;&quot;, strprintf(&quot;Run checks every &lt;n&gt; transactions (default: %u, regtest: %u)&quot;, defaultChainParams-&gt;DefaultConsistencyChecks(), regtestChainParams-&gt;DefaultConsistencyChecks()), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     505 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-checkpoints&quot;, strprintf(&quot;Enable rejection of any forks from the known historical chain until block 295000 (default: %u)&quot;, DEFAULT_CHECKPOINTS_ENABLED), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     506 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-deprecatedrpc=&lt;method&gt;&quot;, &quot;Allows deprecated RPC method(s) to be used&quot;, ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     507 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-dropmessagestest=&lt;n&gt;&quot;, &quot;Randomly drop 1 of every &lt;n&gt; network messages&quot;, ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     508 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-stopafterblockimport&quot;, strprintf(&quot;Stop running after importing blocks from disk (default: %u)&quot;, DEFAULT_STOPAFTERBLOCKIMPORT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     509 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-stopatheight&quot;, strprintf(&quot;Stop running after reaching the given height in the main chain (default: %u)&quot;, DEFAULT_STOPATHEIGHT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     510 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-limitancestorcount=&lt;n&gt;&quot;, strprintf(&quot;Do not accept transactions if number of in-mempool ancestors is &lt;n&gt; or more (default: %u)&quot;, DEFAULT_ANCESTOR_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     511 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-limitancestorsize=&lt;n&gt;&quot;, strprintf(&quot;Do not accept transactions whose size with all in-mempool ancestors exceeds &lt;n&gt; kilobytes (default: %u)&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     512 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-limitdescendantcount=&lt;n&gt;&quot;, strprintf(&quot;Do not accept transactions if any ancestor would have &lt;n&gt; or more in-mempool descendants (default: %u)&quot;, DEFAULT_DESCENDANT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     513 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-limitdescendantsize=&lt;n&gt;&quot;, strprintf(&quot;Do not accept transactions if any ancestor would have more than &lt;n&gt; kilobytes of in-mempool descendants (default: %u).&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     514 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-addrmantest&quot;, &quot;Allows to test address relay on localhost&quot;, ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     515 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-debug=&lt;category&gt;&quot;, &quot;Output debugging information (default: -nodebug, supplying &lt;category&gt; is optional). &quot;</span>
<span class="lineNum">     516 </span><span class="lineCov">     419708 :         &quot;If &lt;category&gt; is not supplied or if &lt;category&gt; = 1, output all debugging information. &lt;category&gt; can be: &quot; + LogInstance().LogCategoriesString() + &quot;.&quot;,</span>
<span class="lineNum">     517 </span>            :         ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);
<span class="lineNum">     518 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-debugexclude=&lt;category&gt;&quot;, strprintf(&quot;Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.&quot;), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     519 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-logips&quot;, strprintf(&quot;Include IP addresses in debug output (default: %u)&quot;, DEFAULT_LOGIPS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     520 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-logtimestamps&quot;, strprintf(&quot;Prepend debug output with timestamp (default: %u)&quot;, DEFAULT_LOGTIMESTAMPS), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     521 </span>            : #ifdef HAVE_THREAD_LOCAL
<span class="lineNum">     522 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-logthreadnames&quot;, strprintf(&quot;Prepend debug output with name of the originating thread (only available on platforms supporting thread_local) (default: %u)&quot;, DEFAULT_LOGTHREADNAMES), ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     523 </span>            : #else
<span class="lineNum">     524 </span>            :     hidden_args.emplace_back(&quot;-logthreadnames&quot;);
<span class="lineNum">     525 </span>            : #endif
<span class="lineNum">     526 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-logtimemicros&quot;, strprintf(&quot;Add microsecond precision to debug timestamps (default: %u)&quot;, DEFAULT_LOGTIMEMICROS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     527 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-mocktime=&lt;n&gt;&quot;, &quot;Replace actual time with &quot; + UNIX_EPOCH_TIME + &quot; (default: 0)&quot;, ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     528 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxsigcachesize=&lt;n&gt;&quot;, strprintf(&quot;Limit sum of signature cache and script execution cache sizes to &lt;n&gt; MiB (default: %u)&quot;, DEFAULT_MAX_SIG_CACHE_SIZE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     529 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-maxtipage=&lt;n&gt;&quot;, strprintf(&quot;Maximum tip age in seconds to consider node in initial block download (default: %u)&quot;, DEFAULT_MAX_TIP_AGE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     530 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-printpriority&quot;, strprintf(&quot;Log transaction fee per kB when mining blocks (default: %u)&quot;, DEFAULT_PRINTPRIORITY), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     531 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-printtoconsole&quot;, &quot;Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     532 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-shrinkdebugfile&quot;, &quot;Shrink debug.log file on client startup (default: 1 when no -debug)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     533 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-uacomment=&lt;cmt&gt;&quot;, &quot;Append comment to the user agent string&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineCov">     104927 :     SetupChainParamsBaseOptions();</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-acceptnonstdtxn&quot;, strprintf(&quot;Relay and mine \&quot;non-standard\&quot; transactions (%sdefault: %u)&quot;, &quot;testnet/regtest only; &quot;, !testnetChainParams-&gt;RequireStandard()), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     538 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-incrementalrelayfee=&lt;amt&gt;&quot;, strprintf(&quot;Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)&quot;, CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     539 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-dustrelayfee=&lt;amt&gt;&quot;, strprintf(&quot;Fee rate (in %s/kB) used to define dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)&quot;, CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     540 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-bytespersigop&quot;, strprintf(&quot;Equivalent bytes per sigop in transactions for relay and mining (default: %u)&quot;, DEFAULT_BYTES_PER_SIGOP), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     541 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-datacarrier&quot;, strprintf(&quot;Relay and mine data carrier transactions (default: %u)&quot;, DEFAULT_ACCEPT_DATACARRIER), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     542 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-datacarriersize&quot;, strprintf(&quot;Maximum size of data in data carrier transactions we relay and mine (default: %u)&quot;, MAX_OP_RETURN_RELAY), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     543 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-minrelaytxfee=&lt;amt&gt;&quot;, strprintf(&quot;Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)&quot;,</span>
<span class="lineNum">     544 </span><span class="lineCov">     209854 :         CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     545 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-whitelistforcerelay&quot;, strprintf(&quot;Add 'forcerelay' permission to whitelisted inbound peers with default permissions. This will relay transactions even if the transactions were already in the mempool. (default: %d)&quot;, DEFAULT_WHITELISTFORCERELAY), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     546 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-whitelistrelay&quot;, strprintf(&quot;Add 'relay' permission to whitelisted inbound peers with default permissions. This will accept relayed transactions even when not relaying transactions (default: %d)&quot;, DEFAULT_WHITELISTRELAY), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-blockmaxweight=&lt;n&gt;&quot;, strprintf(&quot;Set maximum BIP141 block weight (default: %d)&quot;, DEFAULT_BLOCK_MAX_WEIGHT), ArgsManager::ALLOW_ANY, OptionsCategory::BLOCK_CREATION);</span>
<span class="lineNum">     550 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-blockmintxfee=&lt;amt&gt;&quot;, strprintf(&quot;Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)&quot;, CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)), ArgsManager::ALLOW_ANY, OptionsCategory::BLOCK_CREATION);</span>
<span class="lineNum">     551 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-blockversion=&lt;n&gt;&quot;, &quot;Override block version to test forking scenarios&quot;, ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::BLOCK_CREATION);</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-rest&quot;, strprintf(&quot;Accept public REST requests (default: %u)&quot;, DEFAULT_REST_ENABLE), ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     554 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcallowip=&lt;ip&gt;&quot;, &quot;Allow JSON-RPC connections from specified source. Valid for &lt;ip&gt; are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     555 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcauth=&lt;userpw&gt;&quot;, &quot;Username and HMAC-SHA-256 hashed password for JSON-RPC connections. The field &lt;userpw&gt; comes in the format: &lt;USERNAME&gt;:&lt;SALT&gt;$&lt;HASH&gt;. A canonical python script is included in share/rpcauth. The client then connects normally using the rpcuser=&lt;USERNAME&gt;/rpcpassword=&lt;PASSWORD&gt; pair of arguments. This option can be specified multiple times&quot;, ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::RPC);</span>
<span class="lineNum">     556 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcbind=&lt;addr&gt;[:port]&quot;, &quot;Bind to given address to listen for JSON-RPC connections. Do not expose the RPC server to untrusted networks such as the public internet! This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost)&quot;, ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY | ArgsManager::SENSITIVE, OptionsCategory::RPC);</span>
<span class="lineNum">     557 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpccookiefile=&lt;loc&gt;&quot;, &quot;Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     558 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcpassword=&lt;pw&gt;&quot;, &quot;Password for JSON-RPC connections&quot;, ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::RPC);</span>
<span class="lineNum">     559 </span><span class="lineCov">     839416 :     gArgs.AddArg(&quot;-rpcport=&lt;port&gt;&quot;, strprintf(&quot;Listen for JSON-RPC connections on &lt;port&gt; (default: %u, testnet: %u, regtest: %u)&quot;, defaultBaseParams-&gt;RPCPort(), testnetBaseParams-&gt;RPCPort(), regtestBaseParams-&gt;RPCPort()), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::RPC);</span>
<span class="lineNum">     560 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-rpcserialversion&quot;, strprintf(&quot;Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)&quot;, DEFAULT_RPC_SERIALIZE_VERSION), ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     561 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-rpcservertimeout=&lt;n&gt;&quot;, strprintf(&quot;Timeout during HTTP requests (default: %d)&quot;, DEFAULT_HTTP_SERVER_TIMEOUT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::RPC);</span>
<span class="lineNum">     562 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-rpcthreads=&lt;n&gt;&quot;, strprintf(&quot;Set the number of threads to service RPC calls (default: %d)&quot;, DEFAULT_HTTP_THREADS), ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     563 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcuser=&lt;user&gt;&quot;, &quot;Username for JSON-RPC connections&quot;, ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::RPC);</span>
<span class="lineNum">     564 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcwhitelist=&lt;whitelist&gt;&quot;, &quot;Set a whitelist to filter incoming RPC calls for a specific user. The field &lt;whitelist&gt; comes in the format: &lt;USERNAME&gt;:&lt;rpc 1&gt;,&lt;rpc 2&gt;,...,&lt;rpc n&gt;. If multiple whitelists are set for a given user, they are set-intersected. See -rpcwhitelistdefault documentation for information on default whitelist behavior.&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     565 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-rpcwhitelistdefault&quot;, &quot;Sets default behavior for rpc whitelisting. Unless rpcwhitelistdefault is set to 0, if any -rpcwhitelist is set, the rpc server acts as if all rpc users are subject to empty-unless-otherwise-specified whitelists. If rpcwhitelistdefault is set to 1 and no -rpcwhitelist is set, rpc server acts as if all rpc users are subject to empty whitelists.&quot;, ArgsManager::ALLOW_BOOL, OptionsCategory::RPC);</span>
<span class="lineNum">     566 </span><span class="lineCov">     524635 :     gArgs.AddArg(&quot;-rpcworkqueue=&lt;n&gt;&quot;, strprintf(&quot;Set the depth of the work queue to service RPC calls (default: %d)&quot;, DEFAULT_HTTP_WORKQUEUE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::RPC);</span>
<span class="lineNum">     567 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-server&quot;, &quot;Accept command line and JSON-RPC commands&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::RPC);</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : #if HAVE_DECL_DAEMON
<span class="lineNum">     570 </span><span class="lineCov">     629562 :     gArgs.AddArg(&quot;-daemon&quot;, &quot;Run in the background as a daemon and accept commands&quot;, ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);</span>
<span class="lineNum">     571 </span>            : #else
<span class="lineNum">     572 </span>            :     hidden_args.emplace_back(&quot;-daemon&quot;);
<span class="lineNum">     573 </span>            : #endif
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :     // Add the hidden options
<span class="lineNum">     576 </span><span class="lineCov">     104927 :     gArgs.AddHiddenArgs(hidden_args);</span>
<span class="lineNum">     577 </span><span class="lineCov">     104927 : }</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 : std::string LicenseInfo()</span>
<span class="lineNum">     580 </span>            : {
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     const std::string URL_SOURCE_CODE = &quot;&lt;https://github.com/bitcoin/bitcoin&gt;&quot;;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     return CopyrightHolders(strprintf(_(&quot;Copyright (C) %i-%i&quot;).translated, 2009, COPYRIGHT_YEAR) + &quot; &quot;) + &quot;\n&quot; +</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :            &quot;\n&quot; +</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :            strprintf(_(&quot;Please contribute if you find %s useful. &quot;</span>
<span class="lineNum">     586 </span>            :                        &quot;Visit %s for further information about the software.&quot;).translated,
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                PACKAGE_NAME, &quot;&lt;&quot; PACKAGE_URL &quot;&gt;&quot;) +</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :            &quot;\n&quot; +</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :            strprintf(_(&quot;The source code is available from %s.&quot;).translated,</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                URL_SOURCE_CODE) +</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :            &quot;\n&quot; +</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :            &quot;\n&quot; +</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :            _(&quot;This is experimental software.&quot;).translated + &quot;\n&quot; +</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :            strprintf(_(&quot;Distributed under the MIT software license, see the accompanying file %s or %s&quot;).translated, &quot;COPYING&quot;, &quot;&lt;https://opensource.org/licenses/MIT&gt;&quot;) +</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :            &quot;\n&quot;;</span>
<span class="lineNum">     596 </span>            : }
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : #if HAVE_SYSTEM
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : static void BlockNotifyCallback(SynchronizationState sync_state, const CBlockIndex* pBlockIndex)</span>
<span class="lineNum">     600 </span>            : {
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     if (sync_state != SynchronizationState::POST_INIT || !pBlockIndex)</span>
<span class="lineNum">     602 </span>            :         return;
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     std::string strCmd = gArgs.GetArg(&quot;-blocknotify&quot;, &quot;&quot;);</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     if (!strCmd.empty()) {</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         boost::replace_all(strCmd, &quot;%s&quot;, pBlockIndex-&gt;GetBlockHash().GetHex());</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         std::thread t(runCommand, strCmd);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         t.detach(); // thread runs free</span>
<span class="lineNum">     609 </span>            :     }
<span class="lineNum">     610 </span>            : }
<span class="lineNum">     611 </span>            : #endif
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : static bool fHaveGenesis = false;
<span class="lineNum">     614 </span><span class="lineCov">     104927 : static Mutex g_genesis_wait_mutex;</span>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">     104927 : static std::condition_variable g_genesis_wait_cv;</span></a>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 : static void BlockNotifyGenesisWait(const CBlockIndex* pBlockIndex)</span>
<span class="lineNum">     618 </span>            : {
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     if (pBlockIndex != nullptr) {</span>
<span class="lineNum">     620 </span>            :         {
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :             LOCK(g_genesis_wait_mutex);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             fHaveGenesis = true;</span>
<span class="lineNum">     623 </span>            :         }
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         g_genesis_wait_cv.notify_all();</span>
<span class="lineNum">     625 </span>            :     }
<span class="lineNum">     626 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     627 </span>            : 
<a name="628"><span class="lineNum">     628 </span>            : struct CImportingNow</a>
<span class="lineNum">     629 </span>            : {
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     CImportingNow() {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :         assert(fImporting == false);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         fImporting = true;</span>
<a name="633"><span class="lineNum">     633 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     ~CImportingNow() {</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         assert(fImporting == true);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         fImporting = false;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     639 </span>            : };
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : // If we're using -prune with -reindex, then delete block files that will be ignored by the
<span class="lineNum">     643 </span>            : // reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile
<span class="lineNum">     644 </span>            : // is missing, do the same here to delete any later block files after a gap.  Also delete all
<span class="lineNum">     645 </span>            : // rev files since they'll be rewritten by the reindex anyway.  This ensures that vinfoBlockFile
<span class="lineNum">     646 </span>            : // is in sync with what's actually on disk by the time we start downloading, so that pruning
<span class="lineNum">     647 </span>            : // works correctly.
<span class="lineNum">     648 </span><span class="lineNoCov">          0 : static void CleanupBlockRevFiles()</span>
<span class="lineNum">     649 </span>            : {
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     std::map&lt;std::string, fs::path&gt; mapBlockFiles;</span>
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :     // Glob all blk?????.dat and rev?????.dat files from the blocks directory.
<span class="lineNum">     653 </span>            :     // Remove the rev files immediately and insert the blk file paths into an
<span class="lineNum">     654 </span>            :     // ordered map keyed by block file index.
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\n&quot;);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     fs::path blocksdir = GetBlocksDir();</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         if (fs::is_regular_file(*it) &amp;&amp;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :             it-&gt;path().filename().string().length() == 12 &amp;&amp;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :             it-&gt;path().filename().string().substr(8,4) == &quot;.dat&quot;)</span>
<span class="lineNum">     661 </span>            :         {
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :             if (it-&gt;path().filename().string().substr(0,3) == &quot;blk&quot;)</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 mapBlockFiles[it-&gt;path().filename().string().substr(3,5)] = it-&gt;path();</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :             else if (it-&gt;path().filename().string().substr(0,3) == &quot;rev&quot;)</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 remove(it-&gt;path());</span>
<span class="lineNum">     666 </span>            :         }
<span class="lineNum">     667 </span>            :     }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :     // Remove all block files that aren't part of a contiguous set starting at
<span class="lineNum">     670 </span>            :     // zero by walking the ordered map (keys are block file indices) by
<span class="lineNum">     671 </span>            :     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)
<span class="lineNum">     672 </span>            :     // start removing block files.
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     int nContigCounter = 0;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     for (const std::pair&lt;const std::string, fs::path&gt;&amp; item : mapBlockFiles) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         if (atoi(item.first) == nContigCounter) {</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :             nContigCounter++;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     678 </span>            :         }
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         remove(item.second);</span>
<span class="lineNum">     680 </span>            :     }
<span class="lineNum">     681 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 : static void ThreadImport(ChainstateManager&amp; chainman, std::vector&lt;fs::path&gt; vImportFiles)</span>
<span class="lineNum">     684 </span>            : {
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     const CChainParams&amp; chainparams = Params();</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     ScheduleBatchPriority();</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :     {
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     CImportingNow imp;</span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :     // -reindex
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     if (fReindex) {</span>
<span class="lineNum">     693 </span>            :         int nFile = 0;
<span class="lineNum">     694 </span>            :         while (true) {
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :             FlatFilePos pos(nFile, 0);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :             if (!fs::exists(GetBlockPosFilename(pos)))</span>
<span class="lineNum">     697 </span>            :                 break; // No block files left to reindex
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :             FILE *file = OpenBlockFile(pos, true);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :             if (!file)</span>
<span class="lineNum">     700 </span>            :                 break; // This error is logged in OpenBlockFile
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;Reindexing block file blk%05u.dat...\n&quot;, (unsigned int)nFile);</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :             LoadExternalBlockFile(chainparams, file, &amp;pos);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :             if (ShutdownRequested()) {</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :                 LogPrintf(&quot;Shutdown requested. Exit %s\n&quot;, __func__);</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     706 </span>            :             }
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :             nFile++;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         pblocktree-&gt;WriteReindexing(false);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         fReindex = false;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Reindexing finished\n&quot;);</span>
<span class="lineNum">     712 </span>            :         // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         LoadGenesisBlock(chainparams);</span>
<span class="lineNum">     714 </span>            :     }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :     // -loadblock=
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     for (const fs::path&amp; path : vImportFiles) {</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :         FILE *file = fsbridge::fopen(path, &quot;rb&quot;);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :         if (file) {</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;Importing blocks file %s...\n&quot;, path.string());</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :             LoadExternalBlockFile(chainparams, file);</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :             if (ShutdownRequested()) {</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :                 LogPrintf(&quot;Shutdown requested. Exit %s\n&quot;, __func__);</span>
<span class="lineNum">     724 </span>            :                 return;
<span class="lineNum">     725 </span>            :             }
<span class="lineNum">     726 </span>            :         } else {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;Warning: Could not open blocks file %s\n&quot;, path.string());</span>
<span class="lineNum">     728 </span>            :         }
<span class="lineNum">     729 </span>            :     }
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :     // scan for better chains in the block chain database, that are not yet connected in the active best chain
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :     // We can't hold cs_main during ActivateBestChain even though we're accessing
<a name="734"><span class="lineNum">     734 </span>            :     // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve</a>
<span class="lineNum">     735 </span>            :     // the relevant pointers before the ABC call.
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         BlockValidationState state;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         if (!chainstate-&gt;ActivateBestChain(state, chainparams, nullptr)) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;Failed to connect best block (%s)\n&quot;, state.ToString());</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :             StartShutdown();</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     742 </span>            :         }
<span class="lineNum">     743 </span>            :     }
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-stopafterblockimport&quot;, DEFAULT_STOPAFTERBLOCKIMPORT)) {</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Stopping after block import\n&quot;);</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         StartShutdown();</span>
<span class="lineNum">     748 </span>            :         return;
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            :     } // End scope of CImportingNow
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     if (gArgs.GetArg(&quot;-persistmempool&quot;, DEFAULT_PERSIST_MEMPOOL)) {</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         LoadMempool(::mempool);</span>
<span class="lineNum">     753 </span>            :     }
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     ::mempool.SetIsLoaded(!ShutdownRequested());</span>
<span class="lineNum">     755 </span>            : }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : /** Sanity checks
<span class="lineNum">     758 </span>            :  *  Ensure that Bitcoin is running in a usable environment with all
<span class="lineNum">     759 </span>            :  *  necessary library support.
<span class="lineNum">     760 </span>            :  */
<span class="lineNum">     761 </span><span class="lineNoCov">          0 : static bool InitSanityCheck()</span>
<span class="lineNum">     762 </span>            : {
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     if (!ECC_InitSanityCheck()) {</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;Elliptic curve cryptography sanity check failure. Aborting.&quot;));</span>
<span class="lineNum">     765 </span>            :     }
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     if (!glibc_sanity_test() || !glibcxx_sanity_test())</span>
<span class="lineNum">     768 </span>            :         return false;
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :     if (!Random_SanityCheck()) {</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;OS cryptographic RNG sanity check failure. Aborting.&quot;));</span>
<span class="lineNum">     772 </span>            :     }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :     return true;
<span class="lineNum">     775 </span>            : }
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineNoCov">          0 : static bool AppInitServers(const util::Ref&amp; context)</span>
<span class="lineNum">     778 </span>            : {
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     RPCServer::OnStarted(&amp;OnRPCStarted);</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     RPCServer::OnStopped(&amp;OnRPCStopped);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     if (!InitHTTPServer())</span>
<span class="lineNum">     782 </span>            :         return false;
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     StartRPC();</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     if (!StartHTTPRPC(context))</span>
<span class="lineNum">     785 </span>            :         return false;
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-rest&quot;, DEFAULT_REST_ENABLE)) StartREST(context);</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     StartHTTPServer();</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     789 </span>            : }
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            : // Parameter interaction based on rules
<span class="lineNum">     792 </span><span class="lineNoCov">          0 : void InitParameterInteraction()</span>
<span class="lineNum">     793 </span>            : {
<span class="lineNum">     794 </span>            :     // when specifying an explicit binding address, you want to listen on it
<span class="lineNum">     795 </span>            :     // even when -connect or -proxy is specified
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-bind&quot;)) {</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-listen&quot;, true))</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -bind set -&gt; setting -listen=1\n&quot;, __func__);</span>
<span class="lineNum">     799 </span>            :     }
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-whitebind&quot;)) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-listen&quot;, true))</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -whitebind set -&gt; setting -listen=1\n&quot;, __func__);</span>
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-connect&quot;)) {</span>
<span class="lineNum">     806 </span>            :         // when only connecting to trusted nodes, do not seed via DNS, or listen by default
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-dnsseed&quot;, false))</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -connect set -&gt; setting -dnsseed=0\n&quot;, __func__);</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-listen&quot;, false))</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -connect set -&gt; setting -listen=0\n&quot;, __func__);</span>
<span class="lineNum">     811 </span>            :     }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-proxy&quot;)) {</span>
<span class="lineNum">     814 </span>            :         // to protect privacy, do not listen by default if a default proxy server is specified
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-listen&quot;, false))</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -proxy set -&gt; setting -listen=0\n&quot;, __func__);</span>
<span class="lineNum">     817 </span>            :         // to protect privacy, do not use UPNP when a proxy is set. The user may still specify -listen=1
<span class="lineNum">     818 </span>            :         // to listen locally, so don't rely on this happening through -listen below.
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-upnp&quot;, false))</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -proxy set -&gt; setting -upnp=0\n&quot;, __func__);</span>
<span class="lineNum">     821 </span>            :         // to protect privacy, do not discover addresses by default
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-discover&quot;, false))</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -proxy set -&gt; setting -discover=0\n&quot;, __func__);</span>
<span class="lineNum">     824 </span>            :     }
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     if (!gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN)) {</span>
<span class="lineNum">     827 </span>            :         // do not map ports or try to retrieve public IP when not listening (pointless)
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-upnp&quot;, false))</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -listen=0 -&gt; setting -upnp=0\n&quot;, __func__);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-discover&quot;, false))</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -listen=0 -&gt; setting -discover=0\n&quot;, __func__);</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-listenonion&quot;, false))</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -listen=0 -&gt; setting -listenonion=0\n&quot;, __func__);</span>
<span class="lineNum">     834 </span>            :     }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-externalip&quot;)) {</span>
<span class="lineNum">     837 </span>            :         // if an explicit public IP is specified, do not try to find others
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-discover&quot;, false))</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -externalip set -&gt; setting -discover=0\n&quot;, __func__);</span>
<span class="lineNum">     840 </span>            :     }
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :     // disable whitelistrelay in blocksonly mode
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-blocksonly&quot;, DEFAULT_BLOCKSONLY)) {</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-whitelistrelay&quot;, false))</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -blocksonly=1 -&gt; setting -whitelistrelay=0\n&quot;, __func__);</span>
<span class="lineNum">     846 </span>            :     }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     // Forcing relay from whitelisted hosts implies we will accept relays from them in the first place.
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-whitelistforcerelay&quot;, DEFAULT_WHITELISTFORCERELAY)) {</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         if (gArgs.SoftSetBoolArg(&quot;-whitelistrelay&quot;, true))</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :             LogPrintf(&quot;%s: parameter interaction: -whitelistforcerelay=1 -&gt; setting -whitelistrelay=1\n&quot;, __func__);</span>
<span class="lineNum">     852 </span>            :     }
<span class="lineNum">     853 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            : /**
<span class="lineNum">     856 </span>            :  * Initialize global loggers.
<span class="lineNum">     857 </span>            :  *
<span class="lineNum">     858 </span>            :  * Note that this is called very early in the process lifetime, so you should be
<span class="lineNum">     859 </span>            :  * careful about what global state you rely on here.
<span class="lineNum">     860 </span>            :  */
<span class="lineNum">     861 </span><span class="lineCov">     104927 : void InitLogging()</span>
<span class="lineNum">     862 </span>            : {
<span class="lineNum">     863 </span><span class="lineCov">     314781 :     LogInstance().m_print_to_file = !gArgs.IsArgNegated(&quot;-debuglogfile&quot;);</span>
<span class="lineNum">     864 </span><span class="lineCov">    1154197 :     LogInstance().m_file_path = AbsPathForConfigVal(gArgs.GetArg(&quot;-debuglogfile&quot;, DEFAULT_DEBUGLOGFILE));</span>
<span class="lineNum">     865 </span><span class="lineCov">     629562 :     LogInstance().m_print_to_console = gArgs.GetBoolArg(&quot;-printtoconsole&quot;, !gArgs.GetBoolArg(&quot;-daemon&quot;, false));</span>
<span class="lineNum">     866 </span><span class="lineCov">     314781 :     LogInstance().m_log_timestamps = gArgs.GetBoolArg(&quot;-logtimestamps&quot;, DEFAULT_LOGTIMESTAMPS);</span>
<span class="lineNum">     867 </span><span class="lineCov">     314781 :     LogInstance().m_log_time_micros = gArgs.GetBoolArg(&quot;-logtimemicros&quot;, DEFAULT_LOGTIMEMICROS);</span>
<span class="lineNum">     868 </span>            : #ifdef HAVE_THREAD_LOCAL
<span class="lineNum">     869 </span><span class="lineCov">     314781 :     LogInstance().m_log_threadnames = gArgs.GetBoolArg(&quot;-logthreadnames&quot;, DEFAULT_LOGTHREADNAMES);</span>
<span class="lineNum">     870 </span>            : #endif
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineCov">     314781 :     fLogIPs = gArgs.GetBoolArg(&quot;-logips&quot;, DEFAULT_LOGIPS);</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineCov">     209854 :     std::string version_string = FormatFullVersion();</span>
<span class="lineNum">     875 </span>            : #ifdef DEBUG
<span class="lineNum">     876 </span>            :     version_string += &quot; (debug build)&quot;;
<span class="lineNum">     877 </span>            : #else
<span class="lineNum">     878 </span><span class="lineCov">     104927 :     version_string += &quot; (release build)&quot;;</span>
<span class="lineNum">     879 </span>            : #endif
<span class="lineNum">     880 </span><span class="lineCov">     104927 :     LogPrintf(PACKAGE_NAME &quot; version %s\n&quot;, version_string);</span>
<span class="lineNum">     881 </span><span class="lineCov">     104927 : }</span>
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            : namespace { // Variables internal to initialization process only
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            : int nMaxConnections;
<span class="lineNum">     886 </span>            : int nUserMaxConnections;
<span class="lineNum">     887 </span>            : int nFD;
<span class="lineNum">     888 </span>            : ServiceFlags nLocalServices = ServiceFlags(NODE_NETWORK | NODE_NETWORK_LIMITED);
<span class="lineNum">     889 </span>            : int64_t peer_connect_timeout;
<span class="lineNum">     890 </span><span class="lineCov">     104927 : std::set&lt;BlockFilterType&gt; g_enabled_filter_types;</span>
<span class="lineNum">     891 </span>            : 
<a name="892"><span class="lineNum">     892 </span>            : } // namespace</a>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 : [[noreturn]] static void new_handler_terminate()</span>
<span class="lineNum">     895 </span>            : {
<span class="lineNum">     896 </span>            :     // Rather than throwing std::bad-alloc if allocation fails, terminate
<span class="lineNum">     897 </span>            :     // immediately to (try to) avoid chain corruption.
<span class="lineNum">     898 </span>            :     // Since LogPrintf may itself allocate memory, set the handler directly
<span class="lineNum">     899 </span>            :     // to terminate first.
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     std::set_new_handler(std::terminate);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Error: Out of memory. Terminating.\n&quot;);</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :     // The log was successful, terminate now.
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     std::terminate();</span>
<span class="lineNum">     905 </span>            : };
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 : bool AppInitBasicSetup()</span>
<span class="lineNum">     908 </span>            : {
<span class="lineNum">     909 </span>            :     // ********************************************************* Step 1: setup
<span class="lineNum">     910 </span>            : #ifdef _MSC_VER
<span class="lineNum">     911 </span>            :     // Turn off Microsoft heap dump noise
<span class="lineNum">     912 </span>            :     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
<span class="lineNum">     913 </span>            :     _CrtSetReportFile(_CRT_WARN, CreateFileA(&quot;NUL&quot;, GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, 0));
<span class="lineNum">     914 </span>            :     // Disable confusing &quot;helpful&quot; text message on abort, Ctrl-C
<span class="lineNum">     915 </span>            :     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
<span class="lineNum">     916 </span>            : #endif
<span class="lineNum">     917 </span>            : #ifdef WIN32
<span class="lineNum">     918 </span>            :     // Enable heap terminate-on-corruption
<span class="lineNum">     919 </span>            :     HeapSetInformation(nullptr, HeapEnableTerminationOnCorruption, nullptr, 0);
<span class="lineNum">     920 </span>            : #endif
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     if (!SetupNetworking()) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;Initializing networking failed.&quot;));</span>
<span class="lineNum">     924 </span>            :     }
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : #ifndef WIN32
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     if (!gArgs.GetBoolArg(&quot;-sysperms&quot;, false)) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         umask(077);</span>
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :     // Clean shutdown on SIGTERM
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     registerSignalHandler(SIGTERM, HandleSIGTERM);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     registerSignalHandler(SIGINT, HandleSIGTERM);</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :     // Reopen debug.log on SIGHUP
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     registerSignalHandler(SIGHUP, HandleSIGHUP);</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            :     // Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     signal(SIGPIPE, SIG_IGN);</span>
<span class="lineNum">     940 </span>            : #else
<span class="lineNum">     941 </span>            :     SetConsoleCtrlHandler(consoleCtrlHandler, true);
<span class="lineNum">     942 </span>            : #endif
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     std::set_new_handler(new_handler_terminate);</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     947 </span>            : }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">     104927 : bool AppInitParameterInteraction()</span>
<span class="lineNum">     950 </span>            : {
<span class="lineNum">     951 </span><span class="lineCov">     104927 :     const CChainParams&amp; chainparams = Params();</span>
<span class="lineNum">     952 </span>            :     // ********************************************************* Step 2: parameter interactions
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :     // also see: InitParameterInteraction()
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            :     // Error if network-specific options (-addnode, -connect, etc) are
<span class="lineNum">     957 </span>            :     // specified in default section of config file, but not overridden
<span class="lineNum">     958 </span>            :     // on the command line or in this network's section of the config file.
<span class="lineNum">     959 </span><span class="lineCov">     209854 :     std::string network = gArgs.GetChainName();</span>
<span class="lineNum">     960 </span><span class="lineCov">     209854 :     bilingual_str errors;</span>
<span class="lineNum">     961 </span><span class="lineCov">     419708 :     for (const auto&amp; arg : gArgs.GetUnsuitableSectionOnlyArgs()) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         errors += strprintf(_(&quot;Config setting for %s only applied on %s network when in [%s] section.&quot;) + Untranslated(&quot;\n&quot;), arg, network, network);</span>
<span class="lineNum">     963 </span>            :     }
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span><span class="lineCov">     104927 :     if (!errors.empty()) {</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         return InitError(errors);</span>
<span class="lineNum">     967 </span>            :     }
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :     // Warn if unrecognized section name are present in the config file.
<span class="lineNum">     970 </span><span class="lineCov">     209854 :     bilingual_str warnings;</span>
<span class="lineNum">     971 </span><span class="lineCov">     419708 :     for (const auto&amp; section : gArgs.GetUnrecognizedSections()) {</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         warnings += strprintf(Untranslated(&quot;%s:%i &quot;) + _(&quot;Section [%s] is not recognized.&quot;) + Untranslated(&quot;\n&quot;), section.m_file, section.m_line, section.m_name);</span>
<span class="lineNum">     973 </span>            :     }
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineCov">     104927 :     if (!warnings.empty()) {</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :         InitWarning(warnings);</span>
<span class="lineNum">     977 </span>            :     }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineCov">     209854 :     if (!fs::is_directory(GetBlocksDir())) {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;Specified blocks directory \&quot;%s\&quot; does not exist.&quot;), gArgs.GetArg(&quot;-blocksdir&quot;, &quot;&quot;)));</span>
<span class="lineNum">     981 </span>            :     }
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :     // parse and validate enabled filter types
<span class="lineNum">     984 </span><span class="lineCov">     314781 :     std::string blockfilterindex_value = gArgs.GetArg(&quot;-blockfilterindex&quot;, DEFAULT_BLOCKFILTERINDEX);</span>
<span class="lineNum">     985 </span><span class="lineCov">     209854 :     if (blockfilterindex_value == &quot;&quot; || blockfilterindex_value == &quot;1&quot;) {</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :         g_enabled_filter_types = AllBlockFilterTypes();</span>
<span class="lineNum">     987 </span><span class="lineCov">     104927 :     } else if (blockfilterindex_value != &quot;0&quot;) {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :         const std::vector&lt;std::string&gt; names = gArgs.GetArgs(&quot;-blockfilterindex&quot;);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         for (const auto&amp; name : names) {</span>
<span class="lineNum">     990 </span>            :             BlockFilterType filter_type;
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :             if (!BlockFilterTypeByName(name, filter_type)) {</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :                 return InitError(strprintf(_(&quot;Unknown -blockfilterindex value %s.&quot;), name));</span>
<span class="lineNum">     993 </span>            :             }
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :             g_enabled_filter_types.insert(filter_type);</span>
<span class="lineNum">     995 </span>            :         }
<span class="lineNum">     996 </span>            :     }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :     // Basic filters are the only supported filters. The basic filters index must be enabled
<span class="lineNum">     999 </span>            :     // to serve compact filters
<span class="lineNum">    1000 </span><span class="lineCov">     314781 :     if (gArgs.GetBoolArg(&quot;-peerblockfilters&quot;, DEFAULT_PEERBLOCKFILTERS) &amp;&amp;</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :         g_enabled_filter_types.count(BlockFilterType::BASIC) != 1) {</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         return InitError(_(&quot;Cannot set -peerblockfilters without -blockfilterindex.&quot;));</span>
<span class="lineNum">    1003 </span>            :     }
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            :     // if using block pruning, then disallow txindex
<span class="lineNum">    1006 </span><span class="lineCov">     419708 :     if (gArgs.GetArg(&quot;-prune&quot;, 0)) {</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         if (gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX))</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :             return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;));</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         if (!g_enabled_filter_types.empty()) {</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :             return InitError(_(&quot;Prune mode is incompatible with -blockfilterindex.&quot;));</span>
<span class="lineNum">    1011 </span>            :         }
<span class="lineNum">    1012 </span>            :     }
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :     // -bind and -whitebind can't be set when not listening
<span class="lineNum">    1015 </span><span class="lineCov">     839416 :     size_t nUserBind = gArgs.GetArgs(&quot;-bind&quot;).size() + gArgs.GetArgs(&quot;-whitebind&quot;).size();</span>
<span class="lineNum">    1016 </span><span class="lineCov">     209854 :     if (nUserBind != 0 &amp;&amp; !gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN)) {</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;Cannot set -bind or -whitebind together with -listen=0&quot;));</span>
<span class="lineNum">    1018 </span>            :     }
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            :     // Make sure enough file descriptors are available
<span class="lineNum">    1021 </span><span class="lineCov">     209854 :     int nBind = std::max(nUserBind, size_t(1));</span>
<span class="lineNum">    1022 </span><span class="lineCov">     314781 :     nUserMaxConnections = gArgs.GetArg(&quot;-maxconnections&quot;, DEFAULT_MAX_PEER_CONNECTIONS);</span>
<span class="lineNum">    1023 </span><span class="lineCov">     209854 :     nMaxConnections = std::max(nUserMaxConnections, 0);</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :     // Trim requested connection counts, to fit into system limitations
<span class="lineNum">    1026 </span>            :     // &lt;int&gt; in std::min&lt;int&gt;(...) to work around FreeBSD compilation issue described in #2695
<span class="lineNum">    1027 </span><span class="lineCov">     104927 :     nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS);</span>
<span class="lineNum">    1028 </span>            : #ifdef USE_POLL
<span class="lineNum">    1029 </span><span class="lineCov">     104927 :     int fd_max = nFD;</span>
<span class="lineNum">    1030 </span>            : #else
<span class="lineNum">    1031 </span>            :     int fd_max = FD_SETSIZE;
<span class="lineNum">    1032 </span>            : #endif
<span class="lineNum">    1033 </span><span class="lineCov">     314781 :     nMaxConnections = std::max(std::min&lt;int&gt;(nMaxConnections, fd_max - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS), 0);</span>
<span class="lineNum">    1034 </span><span class="lineCov">     104927 :     if (nFD &lt; MIN_CORE_FILEDESCRIPTORS)</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         return InitError(_(&quot;Not enough file descriptors available.&quot;));</span>
<span class="lineNum">    1036 </span><span class="lineCov">     209854 :     nMaxConnections = std::min(nFD - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS, nMaxConnections);</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">     104927 :     if (nMaxConnections &lt; nUserMaxConnections)</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         InitWarning(strprintf(_(&quot;Reducing -maxconnections from %d to %d, because of system limitations.&quot;), nUserMaxConnections, nMaxConnections));</span>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :     // ********************************************************* Step 3: parameter-to-internal-flags
<span class="lineNum">    1042 </span><span class="lineCov">     419708 :     if (gArgs.IsArgSet(&quot;-debug&quot;)) {</span>
<span class="lineNum">    1043 </span>            :         // Special-case: if -debug=0/-nodebug is set, turn off debugging messages
<span class="lineNum">    1044 </span><span class="lineCov">     314781 :         const std::vector&lt;std::string&gt; categories = gArgs.GetArgs(&quot;-debug&quot;);</span>
<a name="1045"><span class="lineNum">    1045 </span>            : </a>
<span class="lineNum">    1046 </span><span class="lineCov">     419708 :         if (std::none_of(categories.begin(), categories.end(),</span>
<span class="lineNum">    1047 </span><span class="lineCov">     314781 :             [](std::string cat){return cat == &quot;0&quot; || cat == &quot;none&quot;;})) {</span>
<span class="lineNum">    1048 </span><span class="lineCov">     524635 :             for (const auto&amp; cat : categories) {</span>
<span class="lineNum">    1049 </span><span class="lineCov">     104927 :                 if (!LogInstance().EnableCategory(cat)) {</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                     InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debug&quot;, cat));</span>
<span class="lineNum">    1051 </span>            :                 }
<span class="lineNum">    1052 </span>            :             }
<span class="lineNum">    1053 </span>            :         }
<span class="lineNum">    1054 </span>            :     }
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :     // Now remove the logging categories which were explicitly excluded
<span class="lineNum">    1057 </span><span class="lineCov">    1049270 :     for (const std::string&amp; cat : gArgs.GetArgs(&quot;-debugexclude&quot;)) {</span>
<span class="lineNum">    1058 </span><span class="lineCov">     209854 :         if (!LogInstance().DisableCategory(cat)) {</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :             InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debugexclude&quot;, cat));</span>
<span class="lineNum">    1060 </span>            :         }
<span class="lineNum">    1061 </span>            :     }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :     // Checkmempool and checkblockindex default to true in regtest mode
<span class="lineNum">    1064 </span><span class="lineCov">     524635 :     int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(gArgs.GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);</span>
<span class="lineNum">    1065 </span><span class="lineCov">     104927 :     if (ratio != 0) {</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         mempool.setSanityCheck(1.0 / ratio);</span>
<span class="lineNum">    1067 </span>            :     }
<span class="lineNum">    1068 </span><span class="lineCov">     314781 :     fCheckBlockIndex = gArgs.GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks());</span>
<span class="lineNum">    1069 </span><span class="lineCov">     419708 :     fCheckpointsEnabled = gArgs.GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED);</span>
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span><span class="lineCov">     629562 :     hashAssumeValid = uint256S(gArgs.GetArg(&quot;-assumevalid&quot;, chainparams.GetConsensus().defaultAssumeValid.GetHex()));</span>
<span class="lineNum">    1072 </span><span class="lineCov">     104927 :     if (!hashAssumeValid.IsNull())</span>
<span class="lineNum">    1073 </span><span class="lineCov">     104927 :         LogPrintf(&quot;Assuming ancestors of block %s have valid signatures.\n&quot;, hashAssumeValid.GetHex());</span>
<span class="lineNum">    1074 </span>            :     else
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Validating signatures for all blocks.\n&quot;);</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineCov">     419708 :     if (gArgs.IsArgSet(&quot;-minimumchainwork&quot;)) {</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         const std::string minChainWorkStr = gArgs.GetArg(&quot;-minimumchainwork&quot;, &quot;&quot;);</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         if (!IsHexNumber(minChainWorkStr)) {</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :             return InitError(strprintf(Untranslated(&quot;Invalid non-hex (%s) minimum chain work value specified&quot;), minChainWorkStr));</span>
<span class="lineNum">    1081 </span>            :         }
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         nMinimumChainWork = UintToArith256(uint256S(minChainWorkStr));</span>
<span class="lineNum">    1083 </span>            :     } else {
<span class="lineNum">    1084 </span><span class="lineCov">     104927 :         nMinimumChainWork = UintToArith256(chainparams.GetConsensus().nMinimumChainWork);</span>
<span class="lineNum">    1085 </span>            :     }
<span class="lineNum">    1086 </span><span class="lineCov">     209854 :     LogPrintf(&quot;Setting nMinimumChainWork=%s\n&quot;, nMinimumChainWork.GetHex());</span>
<span class="lineNum">    1087 </span><span class="lineCov">     209854 :     if (nMinimumChainWork &lt; UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Warning: nMinimumChainWork set below default value of %s\n&quot;, chainparams.GetConsensus().nMinimumChainWork.GetHex());</span>
<span class="lineNum">    1089 </span>            :     }
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :     // mempool limits
<span class="lineNum">    1092 </span><span class="lineCov">     314781 :     int64_t nMempoolSizeMax = gArgs.GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;</span>
<span class="lineNum">    1093 </span><span class="lineCov">     314781 :     int64_t nMempoolSizeMin = gArgs.GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40;</span>
<span class="lineNum">    1094 </span><span class="lineCov">     104927 :     if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin)</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0)));</span>
<span class="lineNum">    1096 </span>            :     // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool
<span class="lineNum">    1097 </span>            :     // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting.
<span class="lineNum">    1098 </span><span class="lineCov">     419708 :     if (gArgs.IsArgSet(&quot;-incrementalrelayfee&quot;))</span>
<span class="lineNum">    1099 </span>            :     {
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         CAmount n = 0;</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         if (!ParseMoney(gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;), n))</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :             return InitError(AmountErrMsg(&quot;incrementalrelayfee&quot;, gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;)));</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         incrementalRelayFee = CFeeRate(n);</span>
<span class="lineNum">    1104 </span>            :     }
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            :     // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files
<span class="lineNum">    1107 </span><span class="lineCov">     314781 :     int64_t nPruneArg = gArgs.GetArg(&quot;-prune&quot;, 0);</span>
<span class="lineNum">    1108 </span><span class="lineCov">     104927 :     if (nPruneArg &lt; 0) {</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;));</span>
<span class="lineNum">    1110 </span>            :     }
<span class="lineNum">    1111 </span><span class="lineCov">     104927 :     nPruneTarget = (uint64_t) nPruneArg * 1024 * 1024;</span>
<span class="lineNum">    1112 </span><span class="lineCov">     104927 :     if (nPruneArg == 1) {  // manual pruning: -prune=1</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Block pruning enabled.  Use RPC call pruneblockchain(height) to manually prune block and undo files.\n&quot;);</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :         nPruneTarget = std::numeric_limits&lt;uint64_t&gt;::max();</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         fPruneMode = true;</span>
<span class="lineNum">    1116 </span><span class="lineCov">     104927 :     } else if (nPruneTarget) {</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) {</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :             return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB.  Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));</span>
<span class="lineNum">    1119 </span>            :         }
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Prune configured to target %u MiB on disk for block and undo files.\n&quot;, nPruneTarget / 1024 / 1024);</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         fPruneMode = true;</span>
<span class="lineNum">    1122 </span>            :     }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineCov">     314781 :     nConnectTimeout = gArgs.GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT);</span>
<span class="lineNum">    1125 </span><span class="lineCov">     104927 :     if (nConnectTimeout &lt;= 0) {</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;</span>
<span class="lineNum">    1127 </span>            :     }
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineCov">     314781 :     peer_connect_timeout = gArgs.GetArg(&quot;-peertimeout&quot;, DEFAULT_PEER_CONNECT_TIMEOUT);</span>
<span class="lineNum">    1130 </span><span class="lineCov">     104927 :     if (peer_connect_timeout &lt;= 0) {</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;peertimeout cannot be configured with a negative value.&quot;));</span>
<span class="lineNum">    1132 </span>            :     }
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span><span class="lineCov">     419708 :     if (gArgs.IsArgSet(&quot;-minrelaytxfee&quot;)) {</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :         CAmount n = 0;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         if (!ParseMoney(gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;), n)) {</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :             return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;)));</span>
<span class="lineNum">    1138 </span>            :         }
<span class="lineNum">    1139 </span>            :         // High fee check is done afterward in CWallet::CreateWalletFromFile()
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :         ::minRelayTxFee = CFeeRate(n);</span>
<span class="lineNum">    1141 </span><span class="lineCov">     104927 :     } else if (incrementalRelayFee &gt; ::minRelayTxFee) {</span>
<span class="lineNum">    1142 </span>            :         // Allow only setting incrementalRelayFee to control both
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :         ::minRelayTxFee = incrementalRelayFee;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Increasing minrelaytxfee to %s to match incrementalrelayfee\n&quot;,::minRelayTxFee.ToString());</span>
<span class="lineNum">    1145 </span>            :     }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :     // Sanity check argument for min fee for including tx in block
<span class="lineNum">    1148 </span>            :     // TODO: Harmonize which arguments need sanity checking and where that happens
<span class="lineNum">    1149 </span><span class="lineCov">     419708 :     if (gArgs.IsArgSet(&quot;-blockmintxfee&quot;))</span>
<span class="lineNum">    1150 </span>            :     {
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :         CAmount n = 0;</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :         if (!ParseMoney(gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;), n))</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :             return InitError(AmountErrMsg(&quot;blockmintxfee&quot;, gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;)));</span>
<span class="lineNum">    1154 </span>            :     }
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            :     // Feerate used to define dust.  Shouldn't be changed lightly as old
<span class="lineNum">    1157 </span>            :     // implementations may inadvertently create non-standard transactions
<span class="lineNum">    1158 </span><span class="lineCov">     419708 :     if (gArgs.IsArgSet(&quot;-dustrelayfee&quot;))</span>
<span class="lineNum">    1159 </span>            :     {
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         CAmount n = 0;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :         if (!ParseMoney(gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;), n))</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :             return InitError(AmountErrMsg(&quot;dustrelayfee&quot;, gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;)));</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :         dustRelayFee = CFeeRate(n);</span>
<span class="lineNum">    1164 </span>            :     }
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineCov">     314781 :     fRequireStandard = !gArgs.GetBoolArg(&quot;-acceptnonstdtxn&quot;, !chainparams.RequireStandard());</span>
<span class="lineNum">    1167 </span><span class="lineCov">     104927 :     if (!chainparams.IsTestChain() &amp;&amp; !fRequireStandard) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :         return InitError(strprintf(Untranslated(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;), chainparams.NetworkIDString()));</span>
<span class="lineNum">    1169 </span>            :     }
<span class="lineNum">    1170 </span><span class="lineCov">     419708 :     nBytesPerSigOp = gArgs.GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp);</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineCov">     104927 :     if (!g_wallet_init_interface.ParameterInteraction()) return false;</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineCov">     314781 :     fIsBareMultisigStd = gArgs.GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG);</span>
<span class="lineNum">    1175 </span><span class="lineCov">     314781 :     fAcceptDatacarrier = gArgs.GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER);</span>
<span class="lineNum">    1176 </span><span class="lineCov">     314781 :     nMaxDatacarrierBytes = gArgs.GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes);</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :     // Option to startup with mocktime set (used for regression testing):
<span class="lineNum">    1179 </span><span class="lineCov">     314781 :     SetMockTime(gArgs.GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op</span>
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineCov">     419708 :     if (gArgs.GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS))</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM);</span>
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">     419708 :     if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0)</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;rpcserialversion must be non-negative.&quot;));</span>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineCov">     419708 :     if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1)</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :         return InitError(Untranslated(&quot;Unknown rpcserialversion requested.&quot;));</span>
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineCov">     314781 :     nMaxTipAge = gArgs.GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE);</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">     104927 :     return true;</span>
<span class="lineNum">    1193 </span>            : }
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 : static bool LockDataDirectory(bool probeOnly)</span>
<span class="lineNum">    1196 </span>            : {
<span class="lineNum">    1197 </span>            :     // Make sure only a single Bitcoin process is using the data directory.
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     fs::path datadir = GetDataDir();</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     if (!DirIsWritable(datadir)) {</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;Cannot write to data directory '%s'; check permissions.&quot;), datadir.string()));</span>
<span class="lineNum">    1201 </span>            :     }
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     if (!LockDirectory(datadir, &quot;.lock&quot;, probeOnly)) {</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;), datadir.string(), PACKAGE_NAME));</span>
<span class="lineNum">    1204 </span>            :     }
<span class="lineNum">    1205 </span>            :     return true;
<span class="lineNum">    1206 </span>            : }
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 : bool AppInitSanityChecks()</span>
<span class="lineNum">    1209 </span>            : {
<span class="lineNum">    1210 </span>            :     // ********************************************************* Step 4: sanity checks
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :     // Initialize elliptic curve code
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     std::string sha256_algo = SHA256AutoDetect();</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Using the '%s' SHA256 implementation\n&quot;, sha256_algo);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     RandomInit();</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     ECC_Start();</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     globalVerifyHandle.reset(new ECCVerifyHandle());</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            :     // Sanity check
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :     if (!InitSanityCheck())</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;Initialization sanity check failed. %s is shutting down.&quot;), PACKAGE_NAME));</span>
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            :     // Probe the data directory lock to give an early error message, if possible
<span class="lineNum">    1224 </span>            :     // We cannot hold the data directory lock here, as the forking for daemon() hasn't yet happened,
<span class="lineNum">    1225 </span>            :     // and a fork will cause weird behavior to it.
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     return LockDataDirectory(true);</span>
<a name="1227"><span class="lineNum">    1227 </span>            : }</a>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 : bool AppInitLockDataDirectory()</span>
<span class="lineNum">    1230 </span>            : {
<span class="lineNum">    1231 </span>            :     // After daemonization get the data directory lock again and hold on to it until exit
<span class="lineNum">    1232 </span>            :     // This creates a slight window for a race condition to happen, however this condition is harmless: it
<span class="lineNum">    1233 </span>            :     // will at most make us exit without printing a message to console.
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     if (!LockDataDirectory(false)) {</span>
<span class="lineNum">    1235 </span>            :         // Detailed error printed inside LockDataDirectory
<span class="lineNum">    1236 </span>            :         return false;
<span class="lineNum">    1237 </span>            :     }
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1239 </span>            : }
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 : bool AppInitMain(const util::Ref&amp; context, NodeContext&amp; node)</span>
<span class="lineNum">    1242 </span>            : {
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     const CChainParams&amp; chainparams = Params();</span>
<span class="lineNum">    1244 </span>            :     // ********************************************************* Step 4a: application initialization
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     if (!CreatePidFile()) {</span>
<span class="lineNum">    1246 </span>            :         // Detailed error printed inside CreatePidFile().
<span class="lineNum">    1247 </span>            :         return false;
<span class="lineNum">    1248 </span>            :     }
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     if (LogInstance().m_print_to_file) {</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :         if (gArgs.GetBoolArg(&quot;-shrinkdebugfile&quot;, LogInstance().DefaultShrinkDebugFile())) {</span>
<span class="lineNum">    1251 </span>            :             // Do this first since it both loads a bunch of debug.log into memory,
<span class="lineNum">    1252 </span>            :             // and because this needs to happen before any other debug.log printing
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :             LogInstance().ShrinkDebugFile();</span>
<span class="lineNum">    1254 </span>            :         }
<span class="lineNum">    1255 </span>            :     }
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     if (!LogInstance().StartLogging()) {</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :             return InitError(strprintf(Untranslated(&quot;Could not open debug log file %s&quot;),</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                 LogInstance().m_file_path.string()));</span>
<span class="lineNum">    1259 </span>            :     }
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     if (!LogInstance().m_log_timestamps)</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Startup time: %s\n&quot;, FormatISO8601DateTime(GetTime()));</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Default data directory %s\n&quot;, GetDefaultDataDir().string());</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Using data directory %s\n&quot;, GetDataDir().string());</span>
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :     // Only log conf file usage message if conf file actually exists.
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     fs::path config_file_path = GetConfigFile(gArgs.GetArg(&quot;-conf&quot;, BITCOIN_CONF_FILENAME));</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     if (fs::exists(config_file_path)) {</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Config file: %s\n&quot;, config_file_path.string());</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     } else if (gArgs.IsArgSet(&quot;-conf&quot;)) {</span>
<span class="lineNum">    1271 </span>            :         // Warn if no conf file exists at path provided by user
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :         InitWarning(strprintf(_(&quot;The specified config file %s does not exist\n&quot;), config_file_path.string()));</span>
<span class="lineNum">    1273 </span>            :     } else {
<span class="lineNum">    1274 </span>            :         // Not categorizing as &quot;Warning&quot; because it's the default behavior
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Config file: %s (not found, skipping)\n&quot;, config_file_path.string());</span>
<span class="lineNum">    1276 </span>            :     }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :     // Log the config arguments to debug.log
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     gArgs.LogArgs();</span>
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Using at most %i automatic connections (%i file descriptors available)\n&quot;, nMaxConnections, nFD);</span>
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :     // Warn about relative -datadir path.
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-datadir&quot;) &amp;&amp; !fs::path(gArgs.GetArg(&quot;-datadir&quot;, &quot;&quot;)).is_absolute()) {</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Warning: relative datadir option '%s' specified, which will be interpreted relative to the &quot; /* Continued */</span>
<span class="lineNum">    1286 </span>            :                   &quot;current working directory '%s'. This is fragile, because if bitcoin is started in the future &quot;
<span class="lineNum">    1287 </span>            :                   &quot;from a different location, it will be unable to locate the current data files. There could &quot;
<span class="lineNum">    1288 </span>            :                   &quot;also be data loss if bitcoin is started while in a temporary directory.\n&quot;,
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :             gArgs.GetArg(&quot;-datadir&quot;, &quot;&quot;), fs::current_path().string());</span>
<span class="lineNum">    1290 </span>            :     }
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     InitSignatureCache();</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     InitScriptExecutionCache();</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :     int script_threads = gArgs.GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS);</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     if (script_threads &lt;= 0) {</span>
<span class="lineNum">    1297 </span>            :         // -par=0 means autodetect (number of cores - 1 script threads)
<span class="lineNum">    1298 </span>            :         // -par=-n means &quot;leave n cores free&quot; (number of cores - n - 1 script threads)
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :         script_threads += GetNumCores();</span>
<span class="lineNum">    1300 </span>            :     }
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            :     // Subtract 1 because the main thread counts towards the par threads
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     script_threads = std::max(script_threads - 1, 0);</span>
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            :     // Number of script-checking threads &lt;= MAX_SCRIPTCHECK_THREADS
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     script_threads = std::min(script_threads, MAX_SCRIPTCHECK_THREADS);</span>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Script verification uses %d additional threads\n&quot;, script_threads);</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     if (script_threads &gt;= 1) {</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :         g_parallel_script_checks = true;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; script_threads; ++i) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :             threadGroup.create_thread([i]() { return ThreadScriptCheck(i); });</span>
<span class="lineNum">    1313 </span>            :         }
<span class="lineNum">    1314 </span>            :     }
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     assert(!node.scheduler);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :     node.scheduler = MakeUnique&lt;CScheduler&gt;();</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :     // Start the lightweight task scheduler thread
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :     threadGroup.create_thread([&amp;] { TraceThread(&quot;scheduler&quot;, [&amp;] { node.scheduler-&gt;serviceQueue(); }); });</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :     // Gather some entropy once per minute.
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     node.scheduler-&gt;scheduleEvery([]{</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :         RandAddPeriodic();</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     }, std::chrono::minutes{1});</span>
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :     GetMainSignals().RegisterBackgroundSignalScheduler(*node.scheduler);</span>
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :     // Create client interfaces for wallets that are supposed to be loaded
<span class="lineNum">    1330 </span>            :     // according to -wallet and -disablewallet options. This only constructs
<span class="lineNum">    1331 </span>            :     // the interfaces, it doesn't load wallet data. Wallets actually get loaded
<span class="lineNum">    1332 </span>            :     // when load() and start() interface methods are called below.
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :     g_wallet_init_interface.Construct(node);</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :     /* Register RPC commands regardless of -server setting so they will be
<span class="lineNum">    1336 </span>            :      * available in the GUI RPC console even if external calls are disabled.
<span class="lineNum">    1337 </span>            :      */
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     RegisterAllCoreRPCCommands(tableRPC);</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :     for (const auto&amp; client : node.chain_clients) {</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         client-&gt;registerRpcs();</span>
<span class="lineNum">    1341 </span>            :     }
<span class="lineNum">    1342 </span>            : #if ENABLE_ZMQ
<span class="lineNum">    1343 </span>            :     RegisterZMQRPCCommands(tableRPC);
<span class="lineNum">    1344 </span>            : #endif
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :     /* Start the RPC server already.  It will be started in &quot;warmup&quot; mode
<span class="lineNum">    1347 </span>            :      * and not really process calls already (but it will signify connections
<span class="lineNum">    1348 </span>            :      * that the server is there and will be ready later).  Warmup mode will
<span class="lineNum">    1349 </span>            :      * be disabled when initialisation is finished.
<span class="lineNum">    1350 </span>            :      */
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-server&quot;, false))</span>
<span class="lineNum">    1352 </span>            :     {
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :         uiInterface.InitMessage_connect(SetRPCWarmupStatus);</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :         if (!AppInitServers(context))</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :             return InitError(_(&quot;Unable to start HTTP server. See debug log for details.&quot;));</span>
<span class="lineNum">    1356 </span>            :     }
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            :     // ********************************************************* Step 5: verify wallet database integrity
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     for (const auto&amp; client : node.chain_clients) {</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :         if (!client-&gt;verify()) {</span>
<span class="lineNum">    1361 </span>            :             return false;
<span class="lineNum">    1362 </span>            :         }
<span class="lineNum">    1363 </span>            :     }
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span>            :     // ********************************************************* Step 6: network initialization
<span class="lineNum">    1366 </span>            :     // Note that we absolutely cannot open any actual connections
<span class="lineNum">    1367 </span>            :     // until the very end (&quot;start node&quot;) as the UTXO/block state
<span class="lineNum">    1368 </span>            :     // is not yet setup and may end up being set up twice if we
<span class="lineNum">    1369 </span>            :     // need to reindex later.
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     assert(!node.banman);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     node.banman = MakeUnique&lt;BanMan&gt;(GetDataDir() / &quot;banlist.dat&quot;, &amp;uiInterface, gArgs.GetArg(&quot;-bantime&quot;, DEFAULT_MISBEHAVING_BANTIME));</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     assert(!node.connman);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     node.connman = std::unique_ptr&lt;CConnman&gt;(new CConnman(GetRand(std::numeric_limits&lt;uint64_t&gt;::max()), GetRand(std::numeric_limits&lt;uint64_t&gt;::max())));</span>
<span class="lineNum">    1375 </span>            :     // Make mempool generally available in the node context. For example the connection manager, wallet, or RPC threads,
<span class="lineNum">    1376 </span>            :     // which are all started after this, may use it from the node context.
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     assert(!node.mempool);</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :     node.mempool = &amp;::mempool;</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :     assert(!node.chainman);</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     node.chainman = &amp;g_chainman;</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :     ChainstateManager&amp; chainman = *Assert(node.chainman);</span>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     node.peer_logic.reset(new PeerLogicValidation(node.connman.get(), node.banman.get(), *node.scheduler, chainman, *node.mempool));</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     RegisterValidationInterface(node.peer_logic.get());</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :     // sanitize comments per BIP-0014, format user agent and check total size
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     std::vector&lt;std::string&gt; uacomments;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     for (const std::string&amp; cmt : gArgs.GetArgs(&quot;-uacomment&quot;)) {</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :         if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :             return InitError(strprintf(_(&quot;User Agent comment (%s) contains unsafe characters.&quot;), cmt));</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :         uacomments.push_back(cmt);</span>
<span class="lineNum">    1392 </span>            :     }
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     if (strSubVersion.size() &gt; MAX_SUBVERSION_LENGTH) {</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :         return InitError(strprintf(_(&quot;Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.&quot;),</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :             strSubVersion.size(), MAX_SUBVERSION_LENGTH));</span>
<span class="lineNum">    1397 </span>            :     }
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-onlynet&quot;)) {</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         std::set&lt;enum Network&gt; nets;</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         for (const std::string&amp; snet : gArgs.GetArgs(&quot;-onlynet&quot;)) {</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :             enum Network net = ParseNetwork(snet);</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :             if (net == NET_UNROUTABLE)</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :                 return InitError(strprintf(_(&quot;Unknown network specified in -onlynet: '%s'&quot;), snet));</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :             nets.insert(net);</span>
<span class="lineNum">    1406 </span>            :         }
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :         for (int n = 0; n &lt; NET_MAX; n++) {</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :             enum Network net = (enum Network)n;</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :             if (!nets.count(net))</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :                 SetReachable(net, false);</span>
<span class="lineNum">    1411 </span>            :         }
<span class="lineNum">    1412 </span>            :     }
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            :     // Check for host lookup allowed before parsing any network related parameters
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     fNameLookup = gArgs.GetBoolArg(&quot;-dns&quot;, DEFAULT_NAME_LOOKUP);</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     bool proxyRandomize = gArgs.GetBoolArg(&quot;-proxyrandomize&quot;, DEFAULT_PROXYRANDOMIZE);</span>
<span class="lineNum">    1418 </span>            :     // -proxy sets a proxy for all outgoing network traffic
<span class="lineNum">    1419 </span>            :     // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     std::string proxyArg = gArgs.GetArg(&quot;-proxy&quot;, &quot;&quot;);</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     SetReachable(NET_ONION, false);</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     if (proxyArg != &quot;&quot; &amp;&amp; proxyArg != &quot;0&quot;) {</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :         CService proxyAddr;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :         if (!Lookup(proxyArg, proxyAddr, 9050, fNameLookup)) {</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :             return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: '%s'&quot;), proxyArg));</span>
<span class="lineNum">    1426 </span>            :         }
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :         proxyType addrProxy = proxyType(proxyAddr, proxyRandomize);</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :         if (!addrProxy.IsValid())</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :             return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: '%s'&quot;), proxyArg));</span>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :         SetProxy(NET_IPV4, addrProxy);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :         SetProxy(NET_IPV6, addrProxy);</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         SetProxy(NET_ONION, addrProxy);</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :         SetNameProxy(addrProxy);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :         SetReachable(NET_ONION, true); // by default, -proxy sets onion as reachable, unless -noonion later</span>
<span class="lineNum">    1437 </span>            :     }
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span>            :     // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses
<span class="lineNum">    1440 </span>            :     // -noonion (or -onion=0) disables connecting to .onion entirely
<span class="lineNum">    1441 </span>            :     // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none)
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     std::string onionArg = gArgs.GetArg(&quot;-onion&quot;, &quot;&quot;);</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     if (onionArg != &quot;&quot;) {</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :         if (onionArg == &quot;0&quot;) { // Handle -noonion/-onion=0</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :             SetReachable(NET_ONION, false);</span>
<span class="lineNum">    1446 </span>            :         } else {
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :             CService onionProxy;</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :             if (!Lookup(onionArg, onionProxy, 9050, fNameLookup)) {</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                 return InitError(strprintf(_(&quot;Invalid -onion address or hostname: '%s'&quot;), onionArg));</span>
<span class="lineNum">    1450 </span>            :             }
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :             proxyType addrOnion = proxyType(onionProxy, proxyRandomize);</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :             if (!addrOnion.IsValid())</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                 return InitError(strprintf(_(&quot;Invalid -onion address or hostname: '%s'&quot;), onionArg));</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :             SetProxy(NET_ONION, addrOnion);</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :             SetReachable(NET_ONION, true);</span>
<span class="lineNum">    1456 </span>            :         }
<span class="lineNum">    1457 </span>            :     }
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            :     // see Step 2: parameter interactions for more information about these
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     fListen = gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN);</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     fDiscover = gArgs.GetBoolArg(&quot;-discover&quot;, true);</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :     g_relay_txes = !gArgs.GetBoolArg(&quot;-blocksonly&quot;, DEFAULT_BLOCKSONLY);</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     for (const std::string&amp; strAddr : gArgs.GetArgs(&quot;-externalip&quot;)) {</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         CService addrLocal;</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         if (Lookup(strAddr, addrLocal, GetListenPort(), fNameLookup) &amp;&amp; addrLocal.IsValid())</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :             AddLocal(addrLocal, LOCAL_MANUAL);</span>
<span class="lineNum">    1468 </span>            :         else
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :             return InitError(ResolveErrMsg(&quot;externalip&quot;, strAddr));</span>
<span class="lineNum">    1470 </span>            :     }
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span>            :     // Read asmap file if configured
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-asmap&quot;)) {</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         fs::path asmap_path = fs::path(gArgs.GetArg(&quot;-asmap&quot;, &quot;&quot;));</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :         if (asmap_path.empty()) {</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :             asmap_path = DEFAULT_ASMAP_FILENAME;</span>
<span class="lineNum">    1477 </span>            :         }
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         if (!asmap_path.is_absolute()) {</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :             asmap_path = GetDataDir() / asmap_path;</span>
<span class="lineNum">    1480 </span>            :         }
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :         if (!fs::exists(asmap_path)) {</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :             InitError(strprintf(_(&quot;Could not find asmap file %s&quot;), asmap_path));</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1484 </span>            :         }
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :         std::vector&lt;bool&gt; asmap = CAddrMan::DecodeAsmap(asmap_path);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :         if (asmap.size() == 0) {</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :             InitError(strprintf(_(&quot;Could not parse asmap file %s&quot;), asmap_path));</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1489 </span>            :         }
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         const uint256 asmap_version = SerializeHash(asmap);</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :         node.connman-&gt;SetAsmap(std::move(asmap));</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Using asmap version %s for IP bucketing\n&quot;, asmap_version.ToString());</span>
<span class="lineNum">    1493 </span>            :     } else {
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Using /16 prefix for IP bucketing\n&quot;);</span>
<span class="lineNum">    1495 </span>            :     }
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            : #if ENABLE_ZMQ
<span class="lineNum">    1498 </span>            :     g_zmq_notification_interface = CZMQNotificationInterface::Create();
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :     if (g_zmq_notification_interface) {
<span class="lineNum">    1501 </span>            :         RegisterValidationInterface(g_zmq_notification_interface);
<span class="lineNum">    1502 </span>            :     }
<span class="lineNum">    1503 </span>            : #endif
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :     uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME;</span>
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-maxuploadtarget&quot;)) {</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :         nMaxOutboundLimit = gArgs.GetArg(&quot;-maxuploadtarget&quot;, DEFAULT_MAX_UPLOAD_TARGET)*1024*1024;</span>
<span class="lineNum">    1509 </span>            :     }
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span>            :     // ********************************************************* Step 7: load block chain
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     fReindex = gArgs.GetBoolArg(&quot;-reindex&quot;, false);</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     bool fReindexChainState = gArgs.GetBoolArg(&quot;-reindex-chainstate&quot;, false);</span>
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            :     // cache size calculations
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     int64_t nTotalCache = (gArgs.GetArg(&quot;-dbcache&quot;, nDefaultDbCache) &lt;&lt; 20);</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     nTotalCache = std::max(nTotalCache, nMinDbCache &lt;&lt; 20); // total cache cannot be less than nMinDbCache</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     nTotalCache = std::min(nTotalCache, nMaxDbCache &lt;&lt; 20); // total cache cannot be greater than nMaxDbcache</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     int64_t nBlockTreeDBCache = std::min(nTotalCache / 8, nMaxBlockDBCache &lt;&lt; 20);</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     nTotalCache -= nBlockTreeDBCache;</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :     int64_t nTxIndexCache = std::min(nTotalCache / 8, gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX) ? nMaxTxIndexCache &lt;&lt; 20 : 0);</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     nTotalCache -= nTxIndexCache;</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :     int64_t filter_index_cache = 0;</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     if (!g_enabled_filter_types.empty()) {</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :         size_t n_indexes = g_enabled_filter_types.size();</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :         int64_t max_cache = std::min(nTotalCache / 8, max_filter_index_cache &lt;&lt; 20);</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         filter_index_cache = max_cache / n_indexes;</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         nTotalCache -= filter_index_cache * n_indexes;</span>
<span class="lineNum">    1530 </span>            :     }
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 &lt;&lt; 23)); // use 25%-50% of the remainder for disk cache</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache &lt;&lt; 20); // cap total coins db cache</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :     nTotalCache -= nCoinDBCache;</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :     int64_t nMempoolSizeMax = gArgs.GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;Cache configuration:\n&quot;);</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;* Using %.1f MiB for block index database\n&quot;, nBlockTreeDBCache * (1.0 / 1024 / 1024));</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) {</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;* Using %.1f MiB for transaction index database\n&quot;, nTxIndexCache * (1.0 / 1024 / 1024));</span>
<span class="lineNum">    1540 </span>            :     }
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     for (BlockFilterType filter_type : g_enabled_filter_types) {</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;* Using %.1f MiB for %s block filter index database\n&quot;,</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :                   filter_index_cache * (1.0 / 1024 / 1024), BlockFilterTypeName(filter_type));</span>
<span class="lineNum">    1544 </span>            :     }
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;* Using %.1f MiB for chain state database\n&quot;, nCoinDBCache * (1.0 / 1024 / 1024));</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\n&quot;, nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));</span>
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span>            :     bool fLoaded = false;
<a name="1549"><span class="lineNum">    1549 </span><span class="lineNoCov">          0 :     while (!fLoaded &amp;&amp; !ShutdownRequested()) {</span></a>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :         bool fReset = fReindex;</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :         auto is_coinsview_empty = [&amp;](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :             return fReset || fReindexChainState || chainstate-&gt;CoinsTip().GetBestBlock().IsNull();</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         };</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :         bilingual_str strLoadError;</span>
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :         uiInterface.InitMessage(_(&quot;Loading block index...&quot;).translated);</span>
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :         do {
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :             const int64_t load_block_index_start_time = GetTimeMillis();</span>
<span class="lineNum">    1560 </span>            :             try {
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                 LOCK(cs_main);</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :                 chainman.InitializeChainstate();</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :                 UnloadBlockIndex();</span>
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span>            :                 // new CBlockTreeDB tries to delete the existing file, which
<span class="lineNum">    1566 </span>            :                 // fails if it's still open from the previous loop. Close it first:
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :                 pblocktree.reset();</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :                 pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, false, fReset));</span>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                 if (fReset) {</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :                     pblocktree-&gt;WriteReindexing(true);</span>
<span class="lineNum">    1572 </span>            :                     //If we're reindexing in prune mode, wipe away unusable block files and all undo data files
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                     if (fPruneMode)</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :                         CleanupBlockRevFiles();</span>
<span class="lineNum">    1575 </span>            :                 }
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :                 if (ShutdownRequested()) break;</span>
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span>            :                 // LoadBlockIndex will load fHavePruned if we've ever removed a
<span class="lineNum">    1580 </span>            :                 // block file from disk.
<span class="lineNum">    1581 </span>            :                 // Note that it also sets fReindex based on the disk flag!
<span class="lineNum">    1582 </span>            :                 // From here on out fReindex and fReset mean something different!
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :                 if (!chainman.LoadBlockIndex(chainparams)) {</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :                     if (ShutdownRequested()) break;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :                     strLoadError = _(&quot;Error loading block database&quot;);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1587 </span>            :                 }
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            :                 // If the loaded chain has a wrong genesis, bail out immediately
<span class="lineNum">    1590 </span>            :                 // (we're likely using a testnet datadir, or the other way around).
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :                 if (!chainman.BlockIndex().empty() &amp;&amp;</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :                         !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                     return InitError(_(&quot;Incorrect or no genesis block found. Wrong datadir for network?&quot;));</span>
<span class="lineNum">    1594 </span>            :                 }
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span>            :                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks
<span class="lineNum">    1597 </span>            :                 // in the past, but is now trying to run unpruned.
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :                 if (fHavePruned &amp;&amp; !fPruneMode) {</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :                     strLoadError = _(&quot;You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain&quot;);</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1601 </span>            :                 }
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :                 // At this point blocktree args are consistent with what's on disk.
<span class="lineNum">    1604 </span>            :                 // If we're not mid-reindex (based on disk + args), add a genesis block on disk
<span class="lineNum">    1605 </span>            :                 // (otherwise we use the one already on disk).
<span class="lineNum">    1606 </span>            :                 // This is called again in ThreadImport after the reindex completes.
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :                 if (!fReindex &amp;&amp; !LoadGenesisBlock(chainparams)) {</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :                     strLoadError = _(&quot;Error initializing block database&quot;);</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1610 </span>            :                 }
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            :                 // At this point we're either in reindex or we've loaded a useful
<span class="lineNum">    1613 </span>            :                 // block tree into BlockIndex()!
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                 bool failed_chainstate_init = false;</span>
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :                 for (CChainState* chainstate : chainman.GetAll()) {</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :                     LogPrintf(&quot;Initializing chainstate %s\n&quot;, chainstate-&gt;ToString());</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                     chainstate-&gt;InitCoinsDB(</span>
<span class="lineNum">    1620 </span>            :                         /* cache_size_bytes */ nCoinDBCache,
<span class="lineNum">    1621 </span>            :                         /* in_memory */ false,
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :                         /* should_wipe */ fReset || fReindexChainState);</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :                     chainstate-&gt;CoinsErrorCatcher().AddReadErrCallback([]() {</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                         uiInterface.ThreadSafeMessageBox(</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :                             _(&quot;Error reading from database, shutting down.&quot;),</span>
<span class="lineNum">    1627 </span>            :                             &quot;&quot;, CClientUIInterface::MSG_ERROR);
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :                     });</span>
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span>            :                     // If necessary, upgrade from older database format.
<span class="lineNum">    1631 </span>            :                     // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :                     if (!chainstate-&gt;CoinsDB().Upgrade()) {</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :                         strLoadError = _(&quot;Error upgrading chainstate database&quot;);</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :                         failed_chainstate_init = true;</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1636 </span>            :                     }
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            :                     // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :                     if (!chainstate-&gt;ReplayBlocks(chainparams)) {</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :                         strLoadError = _(&quot;Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.&quot;);</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :                         failed_chainstate_init = true;</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1643 </span>            :                     }
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span>            :                     // The on-disk coinsdb is now in a good state, create the cache
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :                     chainstate-&gt;InitCoinsCache();</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :                     assert(chainstate-&gt;CanFlushToDisk());</span>
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :                     if (!is_coinsview_empty(chainstate)) {</span>
<span class="lineNum">    1650 </span>            :                         // LoadChainTip initializes the chain based on CoinsTip()'s best block
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :                         if (!chainstate-&gt;LoadChainTip(chainparams)) {</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :                             strLoadError = _(&quot;Error initializing block database&quot;);</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :                             failed_chainstate_init = true;</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :                             break; // out of the per-chainstate loop</span>
<span class="lineNum">    1655 </span>            :                         }
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :                         assert(chainstate-&gt;m_chain.Tip() != nullptr);</span>
<span class="lineNum">    1657 </span>            :                     }
<span class="lineNum">    1658 </span>            :                 }
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :                 if (failed_chainstate_init) {</span>
<span class="lineNum">    1661 </span>            :                     break; // out of the chainstate activation do-while
<span class="lineNum">    1662 </span>            :                 }
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :             } catch (const std::exception&amp; e) {</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :                 LogPrintf(&quot;%s\n&quot;, e.what());</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                 strLoadError = _(&quot;Error opening block database&quot;);</span>
<span class="lineNum">    1666 </span>            :                 break;
<span class="lineNum">    1667 </span>            :             }
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :             bool failed_rewind{false};</span>
<a name="1670"><span class="lineNum">    1670 </span>            :             // Can't hold cs_main while calling RewindBlockIndex, so retrieve the relevant</a>
<span class="lineNum">    1671 </span>            :             // chainstates beforehand.
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :             for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :                 if (!fReset) {</span>
<span class="lineNum">    1674 </span>            :                     // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.
<span class="lineNum">    1675 </span>            :                     // It both disconnects blocks based on the chainstate, and drops block data in
<span class="lineNum">    1676 </span>            :                     // BlockIndex() based on lack of available witness data.
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :                     uiInterface.InitMessage(_(&quot;Rewinding blocks...&quot;).translated);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :                     if (!chainstate-&gt;RewindBlockIndex(chainparams)) {</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :                         strLoadError = _(</span>
<span class="lineNum">    1680 </span>            :                             &quot;Unable to rewind the database to a pre-fork state. &quot;
<span class="lineNum">    1681 </span>            :                             &quot;You will need to redownload the blockchain&quot;);
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :                         failed_rewind = true;</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                         break; // out of the per-chainstate loop</span>
<span class="lineNum">    1684 </span>            :                     }
<span class="lineNum">    1685 </span>            :                 }
<span class="lineNum">    1686 </span>            :             }
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :             if (failed_rewind) {</span>
<span class="lineNum">    1689 </span>            :                 break; // out of the chainstate activation do-while
<span class="lineNum">    1690 </span>            :             }
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :             bool failed_verification = false;</span>
<span class="lineNum">    1693 </span>            : 
<span class="lineNum">    1694 </span>            :             try {
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :                 LOCK(cs_main);</span>
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :                 for (CChainState* chainstate : chainman.GetAll()) {</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                     if (!is_coinsview_empty(chainstate)) {</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :                         uiInterface.InitMessage(_(&quot;Verifying blocks...&quot;).translated);</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :                         if (fHavePruned &amp;&amp; gArgs.GetArg(&quot;-checkblocks&quot;, DEFAULT_CHECKBLOCKS) &gt; MIN_BLOCKS_TO_KEEP) {</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :                             LogPrintf(&quot;Prune: pruned datadir may not have more than %d blocks; only checking available blocks\n&quot;,</span>
<span class="lineNum">    1702 </span>            :                                 MIN_BLOCKS_TO_KEEP);
<span class="lineNum">    1703 </span>            :                         }
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :                         const CBlockIndex* tip = chainstate-&gt;m_chain.Tip();</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :                         RPCNotifyBlockChange(tip);</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :                         if (tip &amp;&amp; tip-&gt;nTime &gt; GetAdjustedTime() + 2 * 60 * 60) {</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :                             strLoadError = _(&quot;The block database contains a block which appears to be from the future. &quot;</span>
<span class="lineNum">    1709 </span>            :                                     &quot;This may be due to your computer's date and time being set incorrectly. &quot;
<span class="lineNum">    1710 </span>            :                                     &quot;Only rebuild the block database if you are sure that your computer's date and time are correct&quot;);
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :                             failed_verification = true;</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    1713 </span>            :                         }
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span>            :                         // Only verify the DB of the active chainstate. This is fixed in later
<span class="lineNum">    1716 </span>            :                         // work when we allow VerifyDB to be parameterized by chainstate.
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :                         if (&amp;::ChainstateActive() == chainstate &amp;&amp;</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :                                 !CVerifyDB().VerifyDB(</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :                                 chainparams, &amp;chainstate-&gt;CoinsDB(),</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :                                 gArgs.GetArg(&quot;-checklevel&quot;, DEFAULT_CHECKLEVEL),</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :                                 gArgs.GetArg(&quot;-checkblocks&quot;, DEFAULT_CHECKBLOCKS))) {</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :                             strLoadError = _(&quot;Corrupted block database detected&quot;);</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :                             failed_verification = true;</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    1725 </span>            :                         }
<span class="lineNum">    1726 </span>            :                     }
<span class="lineNum">    1727 </span>            :                 }
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :             } catch (const std::exception&amp; e) {</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :                 LogPrintf(&quot;%s\n&quot;, e.what());</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :                 strLoadError = _(&quot;Error opening block database&quot;);</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :                 failed_verification = true;</span>
<span class="lineNum">    1732 </span>            :                 break;
<span class="lineNum">    1733 </span>            :             }
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :             if (!failed_verification) {</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :                 fLoaded = true;</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :                 LogPrintf(&quot; block index %15dms\n&quot;, GetTimeMillis() - load_block_index_start_time);</span>
<span class="lineNum">    1738 </span>            :             }
<span class="lineNum">    1739 </span>            :         } while(false);
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :         if (!fLoaded &amp;&amp; !ShutdownRequested()) {</span>
<span class="lineNum">    1742 </span>            :             // first suggest a reindex
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :             if (!fReset) {</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :                 bool fRet = uiInterface.ThreadSafeQuestion(</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :                     strLoadError + Untranslated(&quot;.\n\n&quot;) + _(&quot;Do you want to rebuild the block database now?&quot;),</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :                     strLoadError.original + &quot;.\nPlease restart with -reindex or -reindex-chainstate to recover.&quot;,</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :                     &quot;&quot;, CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :                 if (fRet) {</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :                     fReindex = true;</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :                     AbortShutdown();</span>
<span class="lineNum">    1751 </span>            :                 } else {
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                     LogPrintf(&quot;Aborted block database rebuild. Exiting.\n&quot;);</span>
<span class="lineNum">    1753 </span>            :                     return false;
<span class="lineNum">    1754 </span>            :                 }
<span class="lineNum">    1755 </span>            :             } else {
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :                 return InitError(strLoadError);</span>
<span class="lineNum">    1757 </span>            :             }
<span class="lineNum">    1758 </span>            :         }
<span class="lineNum">    1759 </span>            :     }
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            :     // As LoadBlockIndex can take several minutes, it's possible the user
<span class="lineNum">    1762 </span>            :     // requested to kill the GUI during the last operation. If so, exit.
<span class="lineNum">    1763 </span>            :     // As the program has not fully started yet, Shutdown() is possibly overkill.
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :     if (ShutdownRequested()) {</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Shutdown requested. Exiting.\n&quot;);</span>
<span class="lineNum">    1766 </span>            :         return false;
<span class="lineNum">    1767 </span>            :     }
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :     CAutoFile est_filein(fsbridge::fopen(est_path, &quot;rb&quot;), SER_DISK, CLIENT_VERSION);</span>
<span class="lineNum">    1771 </span>            :     // Allowed to fail as this file IS missing on first startup.
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :     if (!est_filein.IsNull())</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :         ::feeEstimator.Read(est_filein);</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :     fFeeEstimatesInitialized = true;</span>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :     // ********************************************************* Step 8: start indexers
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) {</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :         g_txindex = MakeUnique&lt;TxIndex&gt;(nTxIndexCache, false, fReindex);</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :         g_txindex-&gt;Start();</span>
<span class="lineNum">    1780 </span>            :     }
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :     for (const auto&amp; filter_type : g_enabled_filter_types) {</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :         InitBlockFilterIndex(filter_type, filter_index_cache, false, fReindex);</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :         GetBlockFilterIndex(filter_type)-&gt;Start();</span>
<span class="lineNum">    1785 </span>            :     }
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span>            :     // ********************************************************* Step 9: load wallet
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     for (const auto&amp; client : node.chain_clients) {</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :         if (!client-&gt;load()) {</span>
<span class="lineNum">    1790 </span>            :             return false;
<span class="lineNum">    1791 </span>            :         }
<span class="lineNum">    1792 </span>            :     }
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span>            :     // ********************************************************* Step 10: data directory maintenance
<span class="lineNum">    1795 </span>            : 
<span class="lineNum">    1796 </span>            :     // if pruning, unset the service bit and perform the initial blockstore prune
<span class="lineNum">    1797 </span>            :     // after any wallet rescanning has taken place.
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :     if (fPruneMode) {</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;Unsetting NODE_NETWORK on prune mode\n&quot;);</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :         nLocalServices = ServiceFlags(nLocalServices &amp; ~NODE_NETWORK);</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :         if (!fReindex) {</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :             LOCK(cs_main);</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :             for (CChainState* chainstate : chainman.GetAll()) {</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :                 uiInterface.InitMessage(_(&quot;Pruning blockstore...&quot;).translated);</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :                 chainstate-&gt;PruneAndFlush();</span>
<span class="lineNum">    1806 </span>            :             }
<span class="lineNum">    1807 </span>            :         }
<span class="lineNum">    1808 </span>            :     }
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :     if (chainparams.GetConsensus().SegwitHeight != std::numeric_limits&lt;int&gt;::max()) {</span>
<span class="lineNum">    1811 </span>            :         // Advertise witness capabilities.
<span class="lineNum">    1812 </span>            :         // The option to not set NODE_WITNESS is only used in the tests and should be removed.
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :         nLocalServices = ServiceFlags(nLocalServices | NODE_WITNESS);</span>
<span class="lineNum">    1814 </span>            :     }
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span>            :     // ********************************************************* Step 11: import blocks
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :     if (!CheckDiskSpace(GetDataDir())) {</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :         InitError(strprintf(_(&quot;Error: Disk space is low for %s&quot;), GetDataDir()));</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1821 </span>            :     }
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :     if (!CheckDiskSpace(GetBlocksDir())) {</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :         InitError(strprintf(_(&quot;Error: Disk space is low for %s&quot;), GetBlocksDir()));</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1825 </span>            :     }
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            :     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.
<span class="lineNum">    1828 </span>            :     // No locking, as this happens before any background thread is started.
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :     boost::signals2::connection block_notify_genesis_wait_connection;</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :     if (::ChainActive().Tip() == nullptr) {</span>
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :         block_notify_genesis_wait_connection = uiInterface.NotifyBlockTip_connect(std::bind(BlockNotifyGenesisWait, std::placeholders::_2));</span>
<span class="lineNum">    1832 </span>            :     } else {
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :         fHaveGenesis = true;</span>
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            : #if HAVE_SYSTEM
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :     if (gArgs.IsArgSet(&quot;-blocknotify&quot;))</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :         uiInterface.NotifyBlockTip_connect(BlockNotifyCallback);</span>
<span class="lineNum">    1839 </span>            : #endif
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :     std::vector&lt;fs::path&gt; vImportFiles;</span>
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :     for (const std::string&amp; strFile : gArgs.GetArgs(&quot;-loadblock&quot;)) {</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :         vImportFiles.push_back(strFile);</span>
<a name="1844"><span class="lineNum">    1844 </span>            :     }</a>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     g_load_block = std::thread(&amp;TraceThread&lt;std::function&lt;void()&gt;&gt;, &quot;loadblk&quot;, [=, &amp;chainman]{ ThreadImport(chainman, vImportFiles); });</span>
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span>            :     // Wait for genesis block to be processed
<span class="lineNum">    1849 </span>            :     {
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :         WAIT_LOCK(g_genesis_wait_mutex, lock);</span>
<span class="lineNum">    1851 </span>            :         // We previously could hang here if StartShutdown() is called prior to
<span class="lineNum">    1852 </span>            :         // ThreadImport getting started, so instead we just wait on a timer to
<span class="lineNum">    1853 </span>            :         // check ShutdownRequested() regularly.
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :         while (!fHaveGenesis &amp;&amp; !ShutdownRequested()) {</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :             g_genesis_wait_cv.wait_for(lock, std::chrono::milliseconds(500));</span>
<span class="lineNum">    1856 </span>            :         }
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :         block_notify_genesis_wait_connection.disconnect();</span>
<span class="lineNum">    1858 </span>            :     }
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :     if (ShutdownRequested()) {</span>
<span class="lineNum">    1861 </span>            :         return false;
<span class="lineNum">    1862 </span>            :     }
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span>            :     // ********************************************************* Step 12: start node
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            :     int chain_active_height;
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span>            :     //// debug print
<span class="lineNum">    1869 </span>            :     {
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :         LOCK(cs_main);</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :         LogPrintf(&quot;block tree size = %u\n&quot;, chainman.BlockIndex().size());</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :         chain_active_height = chainman.ActiveChain().Height();</span>
<span class="lineNum">    1873 </span>            :     }
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :     LogPrintf(&quot;nBestHeight = %d\n&quot;, chain_active_height);</span>
<span class="lineNum">    1875 </span>            : 
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-listenonion&quot;, DEFAULT_LISTEN_ONION))</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         StartTorControl();</span>
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     Discover();</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            :     // Map ports with UPnP
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :     if (gArgs.GetBoolArg(&quot;-upnp&quot;, DEFAULT_UPNP)) {</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :         StartMapPort();</span>
<span class="lineNum">    1884 </span>            :     }
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     CConnman::Options connOptions;</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :     connOptions.nLocalServices = nLocalServices;</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :     connOptions.nMaxConnections = nMaxConnections;</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :     connOptions.m_max_outbound_full_relay = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, connOptions.nMaxConnections);</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :     connOptions.m_max_outbound_block_relay = std::min(MAX_BLOCKS_ONLY_CONNECTIONS, connOptions.nMaxConnections-connOptions.m_max_outbound_full_relay);</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :     connOptions.nMaxAddnode = MAX_ADDNODE_CONNECTIONS;</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :     connOptions.nMaxFeeler = MAX_FEELER_CONNECTIONS;</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :     connOptions.nBestHeight = chain_active_height;</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     connOptions.uiInterface = &amp;uiInterface;</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :     connOptions.m_banman = node.banman.get();</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :     connOptions.m_msgproc = node.peer_logic.get();</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :     connOptions.nSendBufferMaxSize = 1000*gArgs.GetArg(&quot;-maxsendbuffer&quot;, DEFAULT_MAXSENDBUFFER);</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :     connOptions.nReceiveFloodSize = 1000*gArgs.GetArg(&quot;-maxreceivebuffer&quot;, DEFAULT_MAXRECEIVEBUFFER);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :     connOptions.m_added_nodes = gArgs.GetArgs(&quot;-addnode&quot;);</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :     connOptions.m_peer_connect_timeout = peer_connect_timeout;</span>
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :     for (const std::string&amp; strBind : gArgs.GetArgs(&quot;-bind&quot;)) {</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :         CService addrBind;</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :         if (!Lookup(strBind, addrBind, GetListenPort(), false)) {</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :             return InitError(ResolveErrMsg(&quot;bind&quot;, strBind));</span>
<span class="lineNum">    1909 </span>            :         }
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :         connOptions.vBinds.push_back(addrBind);</span>
<span class="lineNum">    1911 </span>            :     }
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :     for (const std::string&amp; strBind : gArgs.GetArgs(&quot;-whitebind&quot;)) {</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :         NetWhitebindPermissions whitebind;</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :         bilingual_str error;</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :         if (!NetWhitebindPermissions::TryParse(strBind, whitebind, error)) return InitError(error);</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :         connOptions.vWhiteBinds.push_back(whitebind);</span>
<span class="lineNum">    1917 </span>            :     }
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :     for (const auto&amp; net : gArgs.GetArgs(&quot;-whitelist&quot;)) {</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :         NetWhitelistPermissions subnet;</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :         bilingual_str error;</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :         if (!NetWhitelistPermissions::TryParse(net, subnet, error)) return InitError(error);</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :         connOptions.vWhitelistedRange.push_back(subnet);</span>
<span class="lineNum">    1924 </span>            :     }
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :     connOptions.vSeedNodes = gArgs.GetArgs(&quot;-seednode&quot;);</span>
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            :     // Initiate outbound connections unless connect=0
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :     connOptions.m_use_addrman_outgoing = !gArgs.IsArgSet(&quot;-connect&quot;);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :     if (!connOptions.m_use_addrman_outgoing) {</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :         const auto connect = gArgs.GetArgs(&quot;-connect&quot;);</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :         if (connect.size() != 1 || connect[0] != &quot;0&quot;) {</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :             connOptions.m_specified_outgoing = connect;</span>
<span class="lineNum">    1934 </span>            :         }
<span class="lineNum">    1935 </span>            :     }
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :     if (!node.connman-&gt;Start(*node.scheduler, connOptions)) {</span>
<span class="lineNum">    1937 </span>            :         return false;
<span class="lineNum">    1938 </span>            :     }
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :     // ********************************************************* Step 13: finished
<span class="lineNum">    1941 </span>            : 
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :     SetRPCWarmupFinished();</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :     uiInterface.InitMessage(_(&quot;Done loading&quot;).translated);</span>
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :     for (const auto&amp; client : node.chain_clients) {</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :         client-&gt;start(*node.scheduler);</span>
<span class="lineNum">    1947 </span>            :     }
<span class="lineNum">    1948 </span>            : 
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :     BanMan* banman = node.banman.get();</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :     node.scheduler-&gt;scheduleEvery([banman]{</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :         banman-&gt;DumpBanlist();</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :     }, DUMP_BANS_INTERVAL);</span>
<a name="1953"><span class="lineNum">    1953 </span>            : </a>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1955 </span><span class="lineCov">     314781 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
