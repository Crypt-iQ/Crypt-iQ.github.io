<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - socks5_cov.info - src/leveldb/db/dbformat.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/leveldb/db</a> - dbformat.h<span style="font-size: 80%;"> (source / <a href="dbformat.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">socks5_cov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">35</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-07-21 05:45:46</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<span class="lineNum">       2 </span>            : // Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       3 </span>            : // found in the LICENSE file. See the AUTHORS file for names of contributors.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #ifndef STORAGE_LEVELDB_DB_DBFORMAT_H_
<span class="lineNum">       6 </span>            : #define STORAGE_LEVELDB_DB_DBFORMAT_H_
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &lt;cstddef&gt;
<span class="lineNum">       9 </span>            : #include &lt;cstdint&gt;
<span class="lineNum">      10 </span>            : #include &lt;string&gt;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;leveldb/comparator.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;leveldb/db.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;leveldb/filter_policy.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;leveldb/slice.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;leveldb/table_builder.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;util/coding.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;util/logging.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : namespace leveldb {
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // Grouping of constants.  We may want to make some of these
<span class="lineNum">      23 </span>            : // parameters set via options.
<span class="lineNum">      24 </span>            : namespace config {
<span class="lineNum">      25 </span>            : static const int kNumLevels = 7;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // Level-0 compaction is started when we hit this many files.
<span class="lineNum">      28 </span>            : static const int kL0_CompactionTrigger = 4;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : // Soft limit on number of level-0 files.  We slow down writes at this point.
<span class="lineNum">      31 </span>            : static const int kL0_SlowdownWritesTrigger = 8;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : // Maximum number of level-0 files.  We stop writes at this point.
<span class="lineNum">      34 </span>            : static const int kL0_StopWritesTrigger = 12;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : // Maximum level to which a new compacted memtable is pushed if it
<span class="lineNum">      37 </span>            : // does not create overlap.  We try to push to level 2 to avoid the
<span class="lineNum">      38 </span>            : // relatively expensive level 0=&gt;1 compactions and to avoid some
<span class="lineNum">      39 </span>            : // expensive manifest file operations.  We do not push all the way to
<span class="lineNum">      40 </span>            : // the largest level since that can generate a lot of wasted disk
<span class="lineNum">      41 </span>            : // space if the same key space is being repeatedly overwritten.
<span class="lineNum">      42 </span>            : static const int kMaxMemCompactLevel = 2;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : // Approximate gap in bytes between samples of data read during iteration.
<span class="lineNum">      45 </span>            : static const int kReadBytesPeriod = 1048576;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : }  // namespace config
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : class InternalKey;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // Value types encoded as the last component of internal keys.
<span class="lineNum">      52 </span>            : // DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk
<span class="lineNum">      53 </span>            : // data structures.
<span class="lineNum">      54 </span>            : enum ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 };
<span class="lineNum">      55 </span>            : // kValueTypeForSeek defines the ValueType that should be passed when
<span class="lineNum">      56 </span>            : // constructing a ParsedInternalKey object for seeking to a particular
<span class="lineNum">      57 </span>            : // sequence number (since we sort sequence numbers in decreasing order
<span class="lineNum">      58 </span>            : // and the value type is embedded as the low 8 bits in the sequence
<span class="lineNum">      59 </span>            : // number in internal keys, we need to use the highest-numbered
<span class="lineNum">      60 </span>            : // ValueType, not the lowest).
<span class="lineNum">      61 </span>            : static const ValueType kValueTypeForSeek = kTypeValue;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : typedef uint64_t SequenceNumber;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : // We leave eight bits empty at the bottom so a type and sequence#
<span class="lineNum">      66 </span>            : // can be packed together into 64-bits.
<span class="lineNum">      67 </span>            : static const SequenceNumber kMaxSequenceNumber = ((0x1ull &lt;&lt; 56) - 1);
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : struct ParsedInternalKey {
<span class="lineNum">      70 </span>            :   Slice user_key;
<span class="lineNum">      71 </span>            :   SequenceNumber sequence;
<span class="lineNum">      72 </span>            :   ValueType type;
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   ParsedInternalKey() {}  // Intentionally left uninitialized (for speed)</span>
<span class="lineNum">      75 </span>            :   ParsedInternalKey(const Slice&amp; u, const SequenceNumber&amp; seq, ValueType t)
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :       : user_key(u), sequence(seq), type(t) {}</span>
<span class="lineNum">      77 </span>            :   std::string DebugString() const;
<span class="lineNum">      78 </span>            : };
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : // Return the length of the encoding of &quot;key&quot;.
<span class="lineNum">      81 </span>            : inline size_t InternalKeyEncodingLength(const ParsedInternalKey&amp; key) {
<span class="lineNum">      82 </span>            :   return key.user_key.size() + 8;
<span class="lineNum">      83 </span>            : }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : // Append the serialization of &quot;key&quot; to *result.
<span class="lineNum">      86 </span>            : void AppendInternalKey(std::string* result, const ParsedInternalKey&amp; key);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : // Attempt to parse an internal key from &quot;internal_key&quot;.  On success,
<span class="lineNum">      89 </span>            : // stores the parsed data in &quot;*result&quot;, and returns true.
<span class="lineNum">      90 </span>            : //
<span class="lineNum">      91 </span>            : // On error, returns false, leaves &quot;*result&quot; in an undefined state.
<span class="lineNum">      92 </span>            : bool ParseInternalKey(const Slice&amp; internal_key, ParsedInternalKey* result);
<a name="93"><span class="lineNum">      93 </span>            : </a>
<span class="lineNum">      94 </span>            : // Returns the user key portion of an internal key.
<span class="lineNum">      95 </span><span class="lineNoCov">          0 : inline Slice ExtractUserKey(const Slice&amp; internal_key) {</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   assert(internal_key.size() &gt;= 8);</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   return Slice(internal_key.data(), internal_key.size() - 8);</span>
<span class="lineNum">      98 </span>            : }
<span class="lineNum">      99 </span>            : 
<a name="100"><span class="lineNum">     100 </span>            : // A comparator for internal keys that uses a specified comparator for</a>
<span class="lineNum">     101 </span>            : // the user key portion and breaks ties by decreasing sequence number.
<span class="lineNum">     102 </span><span class="lineNoCov">          0 : class InternalKeyComparator : public Comparator {</span>
<span class="lineNum">     103 </span>            :  private:
<span class="lineNum">     104 </span>            :   const Comparator* user_comparator_;
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :  public:
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) {}</span>
<span class="lineNum">     108 </span>            :   const char* Name() const override;
<span class="lineNum">     109 </span>            :   int Compare(const Slice&amp; a, const Slice&amp; b) const override;
<span class="lineNum">     110 </span>            :   void FindShortestSeparator(std::string* start,
<span class="lineNum">     111 </span>            :                              const Slice&amp; limit) const override;
<span class="lineNum">     112 </span>            :   void FindShortSuccessor(std::string* key) const override;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :   const Comparator* user_comparator() const { return user_comparator_; }
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :   int Compare(const InternalKey&amp; a, const InternalKey&amp; b) const;
<span class="lineNum">     117 </span>            : };
<a name="118"><span class="lineNum">     118 </span>            : </a>
<span class="lineNum">     119 </span>            : // Filter policy wrapper that converts from internal keys to user keys
<span class="lineNum">     120 </span><span class="lineNoCov">          0 : class InternalFilterPolicy : public FilterPolicy {</span>
<span class="lineNum">     121 </span>            :  private:
<span class="lineNum">     122 </span>            :   const FilterPolicy* const user_policy_;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :  public:
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) {}</span>
<span class="lineNum">     126 </span>            :   const char* Name() const override;
<span class="lineNum">     127 </span>            :   void CreateFilter(const Slice* keys, int n, std::string* dst) const override;
<span class="lineNum">     128 </span>            :   bool KeyMayMatch(const Slice&amp; key, const Slice&amp; filter) const override;
<span class="lineNum">     129 </span>            : };
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : // Modules in this directory should keep internal keys wrapped inside
<span class="lineNum">     132 </span>            : // the following class instead of plain strings so that we do not
<span class="lineNum">     133 </span>            : // incorrectly use string comparisons instead of an InternalKeyComparator.
<span class="lineNum">     134 </span><span class="lineNoCov">          0 : class InternalKey {</span>
<span class="lineNum">     135 </span>            :  private:
<span class="lineNum">     136 </span>            :   std::string rep_;
<span class="lineNum">     137 </span>            : 
<a name="138"><span class="lineNum">     138 </span>            :  public:</a>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   InternalKey() {}  // Leave rep_ as empty to indicate it is invalid</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   InternalKey(const Slice&amp; user_key, SequenceNumber s, ValueType t) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     AppendInternalKey(&amp;rep_, ParsedInternalKey(user_key, s, t));</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :   bool DecodeFrom(const Slice&amp; s) {
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     rep_.assign(s.data(), s.size());</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     return !rep_.empty();</span>
<span class="lineNum">     147 </span>            :   }
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   Slice Encode() const {
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     assert(!rep_.empty());</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     return rep_;</span>
<span class="lineNum">     152 </span>            :   }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   Slice user_key() const { return ExtractUserKey(rep_); }</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   void SetFrom(const ParsedInternalKey&amp; p) {
<span class="lineNum">     157 </span>            :     rep_.clear();
<span class="lineNum">     158 </span>            :     AppendInternalKey(&amp;rep_, p);
<span class="lineNum">     159 </span>            :   }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   void Clear() { rep_.clear(); }</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   std::string DebugString() const;
<a name="164"><span class="lineNum">     164 </span>            : };</a>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineNoCov">          0 : inline int InternalKeyComparator::Compare(const InternalKey&amp; a,</span>
<span class="lineNum">     167 </span>            :                                           const InternalKey&amp; b) const {
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   return Compare(a.Encode(), b.Encode());</span>
<span class="lineNum">     169 </span>            : }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : inline bool ParseInternalKey(const Slice&amp; internal_key,
<span class="lineNum">     172 </span>            :                              ParsedInternalKey* result) {
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   const size_t n = internal_key.size();</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   if (n &lt; 8) return false;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   uint64_t num = DecodeFixed64(internal_key.data() + n - 8);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   uint8_t c = num &amp; 0xff;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   result-&gt;sequence = num &gt;&gt; 8;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   result-&gt;type = static_cast&lt;ValueType&gt;(c);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   result-&gt;user_key = Slice(internal_key.data(), n - 8);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   return (c &lt;= static_cast&lt;uint8_t&gt;(kTypeValue));</span>
<span class="lineNum">     181 </span>            : }
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : // A helper class useful for DBImpl::Get()
<span class="lineNum">     184 </span>            : class LookupKey {
<span class="lineNum">     185 </span>            :  public:
<span class="lineNum">     186 </span>            :   // Initialize *this for looking up user_key at a snapshot with
<span class="lineNum">     187 </span>            :   // the specified sequence number.
<span class="lineNum">     188 </span>            :   LookupKey(const Slice&amp; user_key, SequenceNumber sequence);
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   LookupKey(const LookupKey&amp;) = delete;
<span class="lineNum">     191 </span>            :   LookupKey&amp; operator=(const LookupKey&amp;) = delete;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   ~LookupKey();
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   // Return a key suitable for lookup in a MemTable.
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   Slice memtable_key() const { return Slice(start_, end_ - start_); }</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :   // Return an internal key (suitable for passing to an internal iterator)
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :   // Return the user key
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :  private:
<span class="lineNum">     205 </span>            :   // We construct a char array of the form:
<span class="lineNum">     206 </span>            :   //    klength  varint32               &lt;-- start_
<span class="lineNum">     207 </span>            :   //    userkey  char[klength]          &lt;-- kstart_
<span class="lineNum">     208 </span>            :   //    tag      uint64
<span class="lineNum">     209 </span>            :   //                                    &lt;-- end_
<span class="lineNum">     210 </span>            :   // The array is a suitable MemTable key.
<span class="lineNum">     211 </span>            :   // The suffix starting with &quot;userkey&quot; can be used as an InternalKey.
<span class="lineNum">     212 </span>            :   const char* start_;
<span class="lineNum">     213 </span>            :   const char* kstart_;
<span class="lineNum">     214 </span>            :   const char* end_;
<span class="lineNum">     215 </span>            :   char space_[200];  // Avoid allocation for short keys
<span class="lineNum">     216 </span>            : };
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : inline LookupKey::~LookupKey() {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   if (start_ != space_) delete[] start_;</span>
<span class="lineNum">     220 </span>            : }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : }  // namespace leveldb
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : #endif  // STORAGE_LEVELDB_DB_DBFORMAT_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
