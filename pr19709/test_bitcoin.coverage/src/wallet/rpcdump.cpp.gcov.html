<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - test_bitcoin_coverage.info - src/wallet/rpcdump.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">src/wallet</a> - rpcdump.cpp<span style="font-size: 80%;"> (source / <a href="rpcdump.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">test_bitcoin_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">360</td>
            <td class="headerCovTableEntry">1075</td>
            <td class="headerCovTableEntryLo">33.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-08-14 02:46:54</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">37.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2009-2020 The Bitcoin Core developers</a>
<span class="lineNum">       2 </span>            : // Distributed under the MIT software license, see the accompanying
<span class="lineNum">       3 </span>            : // file COPYING or http://www.opensource.org/licenses/mit-license.php.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #include &lt;chain.h&gt;
<span class="lineNum">       6 </span>            : #include &lt;core_io.h&gt;
<span class="lineNum">       7 </span>            : #include &lt;interfaces/chain.h&gt;
<span class="lineNum">       8 </span>            : #include &lt;key_io.h&gt;
<span class="lineNum">       9 </span>            : #include &lt;merkleblock.h&gt;
<span class="lineNum">      10 </span>            : #include &lt;rpc/util.h&gt;
<span class="lineNum">      11 </span>            : #include &lt;script/descriptor.h&gt;
<span class="lineNum">      12 </span>            : #include &lt;script/script.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;script/standard.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;sync.h&gt;
<span class="lineNum">      15 </span>            : #include &lt;util/bip32.h&gt;
<span class="lineNum">      16 </span>            : #include &lt;util/system.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;util/time.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;util/translation.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;wallet/rpcwallet.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;wallet/wallet.h&gt;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;tuple&gt;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #include &lt;boost/algorithm/string.hpp&gt;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &lt;univalue.h&gt;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : 
<a name="31"><span class="lineNum">      31 </span>            : using interfaces::FoundBlock;</a>
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span><span class="lineNoCov">          0 : std::string static EncodeDumpString(const std::string &amp;str) {</span>
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :     std::stringstream ret;</span>
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :     for (const unsigned char c : str) {</span>
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :         if (c &lt;= 32 || c &gt;= 128 || c == '%') {</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :             ret &lt;&lt; '%' &lt;&lt; HexStr(Span&lt;const unsigned char&gt;(&amp;c, 1));</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :             ret &lt;&lt; c;</span>
<span class="lineNum">      40 </span>            :         }
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :     return ret.str();</span>
<a name="43"><span class="lineNum">      43 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span><span class="lineNoCov">          0 : static std::string DecodeDumpString(const std::string &amp;str) {</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :     std::stringstream ret;</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :     for (unsigned int pos = 0; pos &lt; str.length(); pos++) {</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :         unsigned char c = str[pos];</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :         if (c == '%' &amp;&amp; pos+2 &lt; str.length()) {</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :             c = (((str[pos+1]&gt;&gt;6)*9+((str[pos+1]-'0')&amp;15)) &lt;&lt; 4) |</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :                 ((str[pos+2]&gt;&gt;6)*9+((str[pos+2]-'0')&amp;15));</span>
<span class="lineNum">      52 </span>            :             pos += 2;
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :         ret &lt;&lt; c;</span>
<span class="lineNum">      55 </span>            :     }
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :     return ret.str();</span>
<a name="57"><span class="lineNum">      57 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span><span class="lineCov">          1 : static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWallet* const pwallet, const CKeyID&amp; keyid, std::string&amp; strAddr, std::string&amp; strLabel) EXCLUSIVE_LOCKS_REQUIRED(pwallet-&gt;cs_wallet)</span>
<span class="lineNum">      60 </span>            : {
<span class="lineNum">      61 </span>            :     bool fLabelFound = false;
<span class="lineNum">      62 </span><span class="lineCov">          1 :     CKey key;</span>
<span class="lineNum">      63 </span><span class="lineCov">          1 :     spk_man-&gt;GetKey(keyid, key);</span>
<span class="lineNum">      64 </span><span class="lineCov">          4 :     for (const auto&amp; dest : GetAllDestinationsForKey(key.GetPubKey())) {</span>
<span class="lineNum">      65 </span><span class="lineCov">          3 :         const auto* address_book_entry = pwallet-&gt;FindAddressBookEntry(dest);</span>
<span class="lineNum">      66 </span><span class="lineCov">          3 :         if (address_book_entry) {</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :             if (!strAddr.empty()) {</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :                 strAddr += &quot;,&quot;;</span>
<span class="lineNum">      69 </span>            :             }
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :             strAddr += EncodeDestination(dest);</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :             strLabel = EncodeDumpString(address_book_entry-&gt;GetLabel());</span>
<span class="lineNum">      72 </span>            :             fLabelFound = true;
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">      74 </span>            :     }
<span class="lineNum">      75 </span><span class="lineCov">          1 :     if (!fLabelFound) {</span>
<span class="lineNum">      76 </span><span class="lineCov">          1 :         strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), pwallet-&gt;m_default_address_type));</span>
<span class="lineNum">      77 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">      78 </span>            :     return fLabelFound;
<span class="lineNum">      79 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">      80 </span>            : 
<a name="81"><span class="lineNum">      81 </span>            : static const int64_t TIMESTAMP_MIN = 0;</a>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span><span class="lineCov">          1 : static void RescanWallet(CWallet&amp; wallet, const WalletRescanReserver&amp; reserver, int64_t time_begin = TIMESTAMP_MIN, bool update = true)</span>
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span><span class="lineCov">          1 :     int64_t scanned_time = wallet.RescanFromTime(time_begin, reserver, update);</span>
<span class="lineNum">      86 </span><span class="lineCov">          1 :     if (wallet.IsAbortingRescan()) {</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_MISC_ERROR, &quot;Rescan aborted by user.&quot;);</span>
<span class="lineNum">      88 </span><span class="lineCov">          1 :     } else if (scanned_time &gt; time_begin) {</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Rescan was unable to fully rescan the blockchain. Some transactions may be missing.&quot;);</span>
<span class="lineNum">      90 </span>            :     }
<a name="91"><span class="lineNum">      91 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : UniValue importprivkey(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;importprivkey&quot;,</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :                 &quot;\nAdds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.\n&quot;</span>
<span class="lineNum">      97 </span>            :                 &quot;Hint: use importmulti to import more than one private key.\n&quot;
<span class="lineNum">      98 </span>            :             &quot;\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n&quot;
<span class="lineNum">      99 </span>            :             &quot;may report that the imported key exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n&quot;
<span class="lineNum">     100 </span>            :             &quot;Note: Use \&quot;getwalletinfo\&quot; to query the scanning progress.\n&quot;,
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                     {&quot;privkey&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;The private key (see dumpprivkey)&quot;},</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                     {&quot;label&quot;, RPCArg::Type::STR, /* default */ &quot;current label if address exists, otherwise \&quot;\&quot;&quot;, &quot;An optional label&quot;},</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :                     {&quot;rescan&quot;, RPCArg::Type::BOOL, /* default */ &quot;true&quot;, &quot;Rescan the wallet for transactions&quot;},</span>
<span class="lineNum">     105 </span>            :                 },
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :                 RPCResult{RPCResult::Type::NONE, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :             &quot;\nDump a private key\n&quot;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;dumpprivkey&quot;, &quot;\&quot;myaddress\&quot;&quot;) +</span>
<span class="lineNum">     110 </span>            :             &quot;\nImport the private key with rescan\n&quot;
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importprivkey&quot;, &quot;\&quot;mykey\&quot;&quot;) +</span>
<span class="lineNum">     112 </span>            :             &quot;\nImport using a label and without rescan\n&quot;
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importprivkey&quot;, &quot;\&quot;mykey\&quot; \&quot;testing\&quot; false&quot;) +</span>
<span class="lineNum">     114 </span>            :             &quot;\nImport using default blank label and without rescan\n&quot;
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importprivkey&quot;, &quot;\&quot;mykey\&quot; \&quot;\&quot; false&quot;) +</span>
<span class="lineNum">     116 </span>            :             &quot;\nAs a JSON-RPC call\n&quot;
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :             + HelpExampleRpc(&quot;importprivkey&quot;, &quot;\&quot;mykey\&quot;, \&quot;testing\&quot;, false&quot;)</span>
<span class="lineNum">     118 </span>            :                 },
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Cannot import private keys to a wallet with private keys disabled&quot;);</span>
<span class="lineNum">     127 </span>            :     }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     EnsureLegacyScriptPubKeyMan(*wallet, true);</span>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     WalletRescanReserver reserver(*pwallet);</span>
<span class="lineNum">     132 </span>            :     bool fRescan = true;
<span class="lineNum">     133 </span>            :     {
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :         LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         EnsureWalletIsUnlocked(pwallet);</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         std::string strSecret = request.params[0].get_str();</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         std::string strLabel = &quot;&quot;;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :         if (!request.params[1].isNull())</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :             strLabel = request.params[1].get_str();</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :         // Whether to perform rescan after import
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         if (!request.params[2].isNull())</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :             fRescan = request.params[2].get_bool();</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :         if (fRescan &amp;&amp; pwallet-&gt;chain().havePruned()) {</span>
<span class="lineNum">     148 </span>            :             // Exit early and print an error.
<span class="lineNum">     149 </span>            :             // If a block is pruned after this check, we will import the key(s),
<span class="lineNum">     150 </span>            :             // but fail the rescan with a generic error.
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Rescan is disabled when blocks are pruned&quot;);</span>
<span class="lineNum">     152 </span>            :         }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         if (fRescan &amp;&amp; !reserver.reserve()) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Wallet is currently rescanning. Abort existing rescan or wait.&quot;);</span>
<span class="lineNum">     156 </span>            :         }
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         CKey key = DecodeSecret(strSecret);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         if (!key.IsValid()) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid private key encoding&quot;);</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :         CPubKey pubkey = key.GetPubKey();</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :         CHECK_NONFATAL(key.VerifyPubKey(pubkey));</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :         CKeyID vchAddress = pubkey.GetID();</span>
<span class="lineNum">     164 </span>            :         {
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :             pwallet-&gt;MarkDirty();</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :             // We don't know which corresponding address will be used;
<span class="lineNum">     168 </span>            :             // label all new addresses, and label existing addresses if a
<span class="lineNum">     169 </span>            :             // label was passed.
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :             for (const auto&amp; dest : GetAllDestinationsForKey(pubkey)) {</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 if (!request.params[1].isNull() || !pwallet-&gt;FindAddressBookEntry(dest)) {</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                     pwallet-&gt;SetAddressBook(dest, strLabel, &quot;receive&quot;);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     174 </span>            :             }
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :             // Use timestamp of 1 to scan the whole chain
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :             if (!pwallet-&gt;ImportPrivKeys({{vchAddress, key}}, 1)) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error adding key to wallet&quot;);</span>
<span class="lineNum">     179 </span>            :             }
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            :             // Add the wpkh script for this key if possible
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :             if (pubkey.IsCompressed()) {</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :                 pwallet-&gt;ImportScripts({GetScriptForDestination(WitnessV0KeyHash(vchAddress))}, 0 /* timestamp */);</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     185 </span>            :         }
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     if (fRescan) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         RescanWallet(*pwallet, reserver);</span>
<span class="lineNum">     189 </span>            :     }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     return NullUniValue;</span>
<a name="192"><span class="lineNum">     192 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : UniValue abortrescan(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;abortrescan&quot;,</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                 &quot;\nStops current wallet rescan triggered by an RPC call, e.g. by an importprivkey call.\n&quot;</span>
<span class="lineNum">     198 </span>            :                 &quot;Note: Use \&quot;getwalletinfo\&quot; to query the scanning progress.\n&quot;,
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 {},</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :                 RPCResult{RPCResult::Type::BOOL, &quot;&quot;, &quot;Whether the abort was successful&quot;},</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :             &quot;\nImport a private key\n&quot;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importprivkey&quot;, &quot;\&quot;mykey\&quot;&quot;) +</span>
<span class="lineNum">     204 </span>            :             &quot;\nAbort the running wallet rescan\n&quot;
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;abortrescan&quot;, &quot;&quot;) +</span>
<span class="lineNum">     206 </span>            :             &quot;\nAs a JSON-RPC call\n&quot;
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :             + HelpExampleRpc(&quot;abortrescan&quot;, &quot;&quot;)</span>
<span class="lineNum">     208 </span>            :                 },
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     if (!pwallet-&gt;IsScanning() || pwallet-&gt;IsAbortingRescan()) return false;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     pwallet-&gt;AbortRescan();</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="218"><span class="lineNum">     218 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 : UniValue importaddress(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     221 </span>            : {
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;importaddress&quot;,</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                 &quot;\nAdds an address or script (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\n&quot;</span>
<span class="lineNum">     224 </span>            :             &quot;\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n&quot;
<span class="lineNum">     225 </span>            :             &quot;may report that the imported address exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n&quot;
<span class="lineNum">     226 </span>            :             &quot;If you have the full public key, you should call importpubkey instead of this.\n&quot;
<span class="lineNum">     227 </span>            :             &quot;Hint: use importmulti to import more than one address.\n&quot;
<span class="lineNum">     228 </span>            :             &quot;\nNote: If you import a non-standard raw script in hex form, outputs sending to it will be treated\n&quot;
<span class="lineNum">     229 </span>            :             &quot;as change, and not show up in many RPCs.\n&quot;
<span class="lineNum">     230 </span>            :             &quot;Note: Use \&quot;getwalletinfo\&quot; to query the scanning progress.\n&quot;,
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :                     {&quot;address&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;The Bitcoin address (or hex-encoded script)&quot;},</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                     {&quot;label&quot;, RPCArg::Type::STR, /* default */ &quot;\&quot;\&quot;&quot;, &quot;An optional label&quot;},</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :                     {&quot;rescan&quot;, RPCArg::Type::BOOL, /* default */ &quot;true&quot;, &quot;Rescan the wallet for transactions&quot;},</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :                     {&quot;p2sh&quot;, RPCArg::Type::BOOL, /* default */ &quot;false&quot;, &quot;Add the P2SH version of the script as well&quot;},</span>
<span class="lineNum">     236 </span>            :                 },
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                 RPCResult{RPCResult::Type::NONE, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :             &quot;\nImport an address with rescan\n&quot;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importaddress&quot;, &quot;\&quot;myaddress\&quot;&quot;) +</span>
<span class="lineNum">     241 </span>            :             &quot;\nImport using a label without rescan\n&quot;
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importaddress&quot;, &quot;\&quot;myaddress\&quot; \&quot;testing\&quot; false&quot;) +</span>
<span class="lineNum">     243 </span>            :             &quot;\nAs a JSON-RPC call\n&quot;
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :             + HelpExampleRpc(&quot;importaddress&quot;, &quot;\&quot;myaddress\&quot;, \&quot;testing\&quot;, false&quot;)</span>
<span class="lineNum">     245 </span>            :                 },
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     EnsureLegacyScriptPubKeyMan(*pwallet, true);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     std::string strLabel;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     if (!request.params[1].isNull())</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         strLabel = request.params[1].get_str();</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :     // Whether to perform rescan after import
<span class="lineNum">     259 </span>            :     bool fRescan = true;
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     if (!request.params[2].isNull())</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         fRescan = request.params[2].get_bool();</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     if (fRescan &amp;&amp; pwallet-&gt;chain().havePruned()) {</span>
<span class="lineNum">     264 </span>            :         // Exit early and print an error.
<span class="lineNum">     265 </span>            :         // If a block is pruned after this check, we will import the key(s),
<span class="lineNum">     266 </span>            :         // but fail the rescan with a generic error.
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Rescan is disabled when blocks are pruned&quot;);</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     WalletRescanReserver reserver(*pwallet);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     if (fRescan &amp;&amp; !reserver.reserve()) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Wallet is currently rescanning. Abort existing rescan or wait.&quot;);</span>
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     // Whether to import a p2sh version, too
<span class="lineNum">     276 </span>            :     bool fP2SH = false;
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     if (!request.params[3].isNull())</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         fP2SH = request.params[3].get_bool();</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :     {
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         CTxDestination dest = DecodeDestination(request.params[0].get_str());</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         if (IsValidDestination(dest)) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :             if (fP2SH) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Cannot use the p2sh flag with an address - use a script instead&quot;);</span>
<span class="lineNum">     287 </span>            :             }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :             pwallet-&gt;MarkDirty();</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :             pwallet-&gt;ImportScriptPubKeys(strLabel, {GetScriptForDestination(dest)}, false /* have_solving_data */, true /* apply_label */, 1 /* timestamp */);</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         } else if (IsHex(request.params[0].get_str())) {</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :             std::vector&lt;unsigned char&gt; data(ParseHex(request.params[0].get_str()));</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :             CScript redeem_script(data.begin(), data.end());</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :             std::set&lt;CScript&gt; scripts = {redeem_script};</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :             pwallet-&gt;ImportScripts(scripts, 0 /* timestamp */);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :             if (fP2SH) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                 scripts.insert(GetScriptForDestination(ScriptHash(redeem_script)));</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :             pwallet-&gt;ImportScriptPubKeys(strLabel, scripts, false /* have_solving_data */, true /* apply_label */, 1 /* timestamp */);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid Bitcoin address or script&quot;);</span>
<span class="lineNum">     306 </span>            :         }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     if (fRescan)</span>
<span class="lineNum">     309 </span>            :     {
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         RescanWallet(*pwallet, reserver);</span>
<span class="lineNum">     311 </span>            :         {
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :             LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :             pwallet-&gt;ReacceptWalletTransactions();</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     return NullUniValue;</span>
<a name="318"><span class="lineNum">     318 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 : UniValue importprunedfunds(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     321 </span>            : {
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;importprunedfunds&quot;,</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :                 &quot;\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\n&quot;,</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :                     {&quot;rawtransaction&quot;, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, &quot;A raw transaction in hex funding an already-existing address in wallet&quot;},</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                     {&quot;txoutproof&quot;, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, &quot;The hex output from gettxoutproof that contains the transaction&quot;},</span>
<span class="lineNum">     327 </span>            :                 },
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 RPCResult{RPCResult::Type::NONE, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                 RPCExamples{&quot;&quot;},</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     CMutableTransaction tx;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     if (!DecodeHexTx(tx, request.params[0].get_str()))</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, &quot;TX decode failed&quot;);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     uint256 hashTx = tx.GetHash();</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     CDataStream ssMB(ParseHexV(request.params[1], &quot;proof&quot;), SER_NETWORK, PROTOCOL_VERSION);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     CMerkleBlock merkleBlock;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     ssMB &gt;&gt; merkleBlock;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :     //Search partial merkle tree in proof for our transaction and index in valid block
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     std::vector&lt;uint256&gt; vMatch;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     std::vector&lt;unsigned int&gt; vIndex;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Something wrong with merkleblock&quot;);</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     int height;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     if (!pwallet-&gt;chain().findAncestorByHash(pwallet-&gt;GetLastBlockHash(), merkleBlock.header.GetHash(), FoundBlock().height(height))) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Block not found in chain&quot;);</span>
<span class="lineNum">     356 </span>            :     }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     std::vector&lt;uint256&gt;::const_iterator it;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if ((it = std::find(vMatch.begin(), vMatch.end(), hashTx)) == vMatch.end()) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Transaction given doesn't exist in proof&quot;);</span>
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     unsigned int txnIndex = vIndex[it - vMatch.begin()];</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     CWalletTx::Confirmation confirm(CWalletTx::Status::CONFIRMED, height, merkleBlock.header.GetHash(), txnIndex);</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     CTransactionRef tx_ref = MakeTransactionRef(tx);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     if (pwallet-&gt;IsMine(*tx_ref)) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         pwallet-&gt;AddToWallet(std::move(tx_ref), confirm);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         return NullUniValue;</span>
<span class="lineNum">     371 </span>            :     }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;No addresses in wallet correspond to included transaction&quot;);</span>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 : UniValue removeprunedfunds(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;removeprunedfunds&quot;,</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 &quot;\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.\n&quot;,</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :                     {&quot;txid&quot;, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, &quot;The hex-encoded id of the transaction you are deleting&quot;},</span>
<span class="lineNum">     382 </span>            :                 },
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :                 RPCResult{RPCResult::Type::NONE, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                     HelpExampleCli(&quot;removeprunedfunds&quot;, &quot;\&quot;a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\&quot;&quot;) +</span>
<span class="lineNum">     386 </span>            :             &quot;\nAs a JSON-RPC call\n&quot;
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :             + HelpExampleRpc(&quot;removeprunedfunds&quot;, &quot;\&quot;a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\&quot;&quot;)</span>
<span class="lineNum">     388 </span>            :                 },
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     uint256 hash(ParseHashV(request.params[0], &quot;txid&quot;));</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     std::vector&lt;uint256&gt; vHash;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     vHash.push_back(hash);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     std::vector&lt;uint256&gt; vHashOut;</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     if (pwallet-&gt;ZapSelectTx(vHash, vHashOut) != DBErrors::LOAD_OK) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Could not properly delete the transaction.&quot;);</span>
<span class="lineNum">     404 </span>            :     }
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     if(vHashOut.empty()) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Transaction does not exist in wallet.&quot;);</span>
<span class="lineNum">     408 </span>            :     }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     return NullUniValue;</span>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 : UniValue importpubkey(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     414 </span>            : {
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;importpubkey&quot;,</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                 &quot;\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\n&quot;</span>
<span class="lineNum">     417 </span>            :                 &quot;Hint: use importmulti to import more than one public key.\n&quot;
<span class="lineNum">     418 </span>            :             &quot;\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n&quot;
<span class="lineNum">     419 </span>            :             &quot;may report that the imported pubkey exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n&quot;
<span class="lineNum">     420 </span>            :             &quot;Note: Use \&quot;getwalletinfo\&quot; to query the scanning progress.\n&quot;,
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                     {&quot;pubkey&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;The hex-encoded public key&quot;},</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                     {&quot;label&quot;, RPCArg::Type::STR, /* default */ &quot;\&quot;\&quot;&quot;, &quot;An optional label&quot;},</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                     {&quot;rescan&quot;, RPCArg::Type::BOOL, /* default */ &quot;true&quot;, &quot;Rescan the wallet for transactions&quot;},</span>
<span class="lineNum">     425 </span>            :                 },
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                 RPCResult{RPCResult::Type::NONE, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :             &quot;\nImport a public key with rescan\n&quot;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importpubkey&quot;, &quot;\&quot;mypubkey\&quot;&quot;) +</span>
<span class="lineNum">     430 </span>            :             &quot;\nImport using a label without rescan\n&quot;
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importpubkey&quot;, &quot;\&quot;mypubkey\&quot; \&quot;testing\&quot; false&quot;) +</span>
<span class="lineNum">     432 </span>            :             &quot;\nAs a JSON-RPC call\n&quot;
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :             + HelpExampleRpc(&quot;importpubkey&quot;, &quot;\&quot;mypubkey\&quot;, \&quot;testing\&quot;, false&quot;)</span>
<span class="lineNum">     434 </span>            :                 },
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     EnsureLegacyScriptPubKeyMan(*wallet, true);</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     std::string strLabel;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     if (!request.params[1].isNull())</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         strLabel = request.params[1].get_str();</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :     // Whether to perform rescan after import
<span class="lineNum">     448 </span>            :     bool fRescan = true;
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     if (!request.params[2].isNull())</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         fRescan = request.params[2].get_bool();</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     if (fRescan &amp;&amp; pwallet-&gt;chain().havePruned()) {</span>
<span class="lineNum">     453 </span>            :         // Exit early and print an error.
<span class="lineNum">     454 </span>            :         // If a block is pruned after this check, we will import the key(s),
<span class="lineNum">     455 </span>            :         // but fail the rescan with a generic error.
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Rescan is disabled when blocks are pruned&quot;);</span>
<span class="lineNum">     457 </span>            :     }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     WalletRescanReserver reserver(*pwallet);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     if (fRescan &amp;&amp; !reserver.reserve()) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Wallet is currently rescanning. Abort existing rescan or wait.&quot;);</span>
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     if (!IsHex(request.params[0].get_str()))</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Pubkey must be a hex string&quot;);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     std::vector&lt;unsigned char&gt; data(ParseHex(request.params[0].get_str()));</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     CPubKey pubKey(data.begin(), data.end());</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     if (!pubKey.IsFullyValid())</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Pubkey is not a valid public key&quot;);</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :     {
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :         LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         std::set&lt;CScript&gt; script_pub_keys;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         for (const auto&amp; dest : GetAllDestinationsForKey(pubKey)) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :             script_pub_keys.insert(GetScriptForDestination(dest));</span>
<span class="lineNum">     477 </span>            :         }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         pwallet-&gt;MarkDirty();</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         pwallet-&gt;ImportScriptPubKeys(strLabel, script_pub_keys, true /* have_solving_data */, true /* apply_label */, 1 /* timestamp */);</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :         pwallet-&gt;ImportPubKeys({pubKey.GetID()}, {{pubKey.GetID(), pubKey}} , {} /* key_origins */, false /* add_keypool */, false /* internal */, 1 /* timestamp */);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     if (fRescan)</span>
<span class="lineNum">     486 </span>            :     {
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         RescanWallet(*pwallet, reserver);</span>
<span class="lineNum">     488 </span>            :         {
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :             LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :             pwallet-&gt;ReacceptWalletTransactions();</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     return NullUniValue;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 : }</span>
<a name="496"><span class="lineNum">     496 </span>            : </a>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineCov">          1 : UniValue importwallet(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     499 </span>            : {
<span class="lineNum">     500 </span><span class="lineCov">          3 :             RPCHelpMan{&quot;importwallet&quot;,</span>
<span class="lineNum">     501 </span><span class="lineCov">          1 :                 &quot;\nImports keys from a wallet dump file (see dumpwallet). Requires a new wallet backup to include imported keys.\n&quot;</span>
<span class="lineNum">     502 </span>            :                 &quot;Note: Use \&quot;getwalletinfo\&quot; to query the scanning progress.\n&quot;,
<span class="lineNum">     503 </span><span class="lineCov">          2 :                 {</span>
<span class="lineNum">     504 </span><span class="lineCov">          1 :                     {&quot;filename&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;The wallet file&quot;},</span>
<span class="lineNum">     505 </span>            :                 },
<span class="lineNum">     506 </span><span class="lineCov">          1 :                 RPCResult{RPCResult::Type::NONE, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">     507 </span><span class="lineCov">          1 :                 RPCExamples{</span>
<span class="lineNum">     508 </span><span class="lineCov">          1 :             &quot;\nDump the wallet\n&quot;</span>
<span class="lineNum">     509 </span><span class="lineCov">          1 :             + HelpExampleCli(&quot;dumpwallet&quot;, &quot;\&quot;test\&quot;&quot;) +</span>
<span class="lineNum">     510 </span>            :             &quot;\nImport the wallet\n&quot;
<span class="lineNum">     511 </span><span class="lineCov">          1 :             + HelpExampleCli(&quot;importwallet&quot;, &quot;\&quot;test\&quot;&quot;) +</span>
<span class="lineNum">     512 </span>            :             &quot;\nImport using the json rpc call\n&quot;
<span class="lineNum">     513 </span><span class="lineCov">          1 :             + HelpExampleRpc(&quot;importwallet&quot;, &quot;\&quot;test\&quot;&quot;)</span>
<span class="lineNum">     514 </span>            :                 },
<span class="lineNum">     515 </span><span class="lineCov">          1 :             }.Check(request);</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">          1 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     518 </span><span class="lineCov">          1 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     519 </span><span class="lineCov">          1 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineCov">          1 :     EnsureLegacyScriptPubKeyMan(*wallet, true);</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineCov">          1 :     if (pwallet-&gt;chain().havePruned()) {</span>
<span class="lineNum">     524 </span>            :         // Exit early and print an error.
<span class="lineNum">     525 </span>            :         // If a block is pruned after this check, we will import the key(s),
<span class="lineNum">     526 </span>            :         // but fail the rescan with a generic error.
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Importing wallets is disabled when blocks are pruned&quot;);</span>
<span class="lineNum">     528 </span>            :     }
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineCov">          1 :     WalletRescanReserver reserver(*pwallet);</span>
<span class="lineNum">     531 </span><span class="lineCov">          1 :     if (!reserver.reserve()) {</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Wallet is currently rescanning. Abort existing rescan or wait.&quot;);</span>
<span class="lineNum">     533 </span>            :     }
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineCov">          1 :     int64_t nTimeBegin = 0;</span>
<span class="lineNum">     536 </span>            :     bool fGood = true;
<span class="lineNum">     537 </span>            :     {
<span class="lineNum">     538 </span><span class="lineCov">          1 :         LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineCov">          1 :         EnsureWalletIsUnlocked(pwallet);</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineCov">          1 :         fsbridge::ifstream file;</span>
<span class="lineNum">     543 </span><span class="lineCov">          1 :         file.open(request.params[0].get_str(), std::ios::in | std::ios::ate);</span>
<span class="lineNum">     544 </span><span class="lineCov">          1 :         if (!file.is_open()) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Cannot open wallet dump file&quot;);</span>
<span class="lineNum">     546 </span>            :         }
<span class="lineNum">     547 </span><span class="lineCov">          1 :         CHECK_NONFATAL(pwallet-&gt;chain().findBlock(pwallet-&gt;GetLastBlockHash(), FoundBlock().time(nTimeBegin)));</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">          1 :         int64_t nFilesize = std::max((int64_t)1, (int64_t)file.tellg());</span>
<span class="lineNum">     550 </span><span class="lineCov">          1 :         file.seekg(0, file.beg);</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :         // Use uiInterface.ShowProgress instead of pwallet.ShowProgress because pwallet.ShowProgress has a cancel button tied to AbortRescan which
<span class="lineNum">     553 </span>            :         // we don't want for this progress bar showing the import progress. uiInterface.ShowProgress does not have a cancel button.
<span class="lineNum">     554 </span><span class="lineCov">          1 :         pwallet-&gt;chain().showProgress(strprintf(&quot;%s &quot; + _(&quot;Importing...&quot;).translated, pwallet-&gt;GetDisplayName()), 0, false); // show progress dialog in GUI</span>
<span class="lineNum">     555 </span><span class="lineCov">          1 :         std::vector&lt;std::tuple&lt;CKey, int64_t, bool, std::string&gt;&gt; keys;</span>
<span class="lineNum">     556 </span><span class="lineCov">          1 :         std::vector&lt;std::pair&lt;CScript, int64_t&gt;&gt; scripts;</span>
<span class="lineNum">     557 </span><span class="lineCov">         12 :         while (file.good()) {</span>
<span class="lineNum">     558 </span><span class="lineCov">         11 :             pwallet-&gt;chain().showProgress(&quot;&quot;, std::max(1, std::min(50, (int)(((double)file.tellg() / (double)nFilesize) * 100))), false);</span>
<span class="lineNum">     559 </span><span class="lineCov">         11 :             std::string line;</span>
<span class="lineNum">     560 </span><span class="lineCov">         11 :             std::getline(file, line);</span>
<span class="lineNum">     561 </span><span class="lineCov">         11 :             if (line.empty() || line[0] == '#')</span>
<span class="lineNum">     562 </span><span class="lineCov">          9 :                 continue;</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span><span class="lineCov">          2 :             std::vector&lt;std::string&gt; vstr;</span>
<span class="lineNum">     565 </span><span class="lineCov">          2 :             boost::split(vstr, line, boost::is_any_of(&quot; &quot;));</span>
<span class="lineNum">     566 </span><span class="lineCov">          2 :             if (vstr.size() &lt; 2)</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     568 </span><span class="lineCov">          2 :             CKey key = DecodeSecret(vstr[0]);</span>
<span class="lineNum">     569 </span><span class="lineCov">          2 :             if (key.IsValid()) {</span>
<span class="lineNum">     570 </span><span class="lineCov">          1 :                 int64_t nTime = ParseISO8601DateTime(vstr[1]);</span>
<span class="lineNum">     571 </span><span class="lineCov">          1 :                 std::string strLabel;</span>
<span class="lineNum">     572 </span><span class="lineCov">          1 :                 bool fLabel = true;</span>
<span class="lineNum">     573 </span><span class="lineCov">          2 :                 for (unsigned int nStr = 2; nStr &lt; vstr.size(); nStr++) {</span>
<span class="lineNum">     574 </span><span class="lineCov">          2 :                     if (vstr[nStr].front() == '#')</span>
<span class="lineNum">     575 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">     576 </span><span class="lineCov">          1 :                     if (vstr[nStr] == &quot;change=1&quot;)</span>
<span class="lineNum">     577 </span><span class="lineCov">          1 :                         fLabel = false;</span>
<span class="lineNum">     578 </span><span class="lineCov">          1 :                     if (vstr[nStr] == &quot;reserve=1&quot;)</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :                         fLabel = false;</span>
<span class="lineNum">     580 </span><span class="lineCov">          1 :                     if (vstr[nStr].substr(0,6) == &quot;label=&quot;) {</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                         strLabel = DecodeDumpString(vstr[nStr].substr(6));</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                         fLabel = true;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                     }</span>
<span class="lineNum">     584 </span>            :                 }
<span class="lineNum">     585 </span><span class="lineCov">          1 :                 keys.push_back(std::make_tuple(key, nTime, fLabel, strLabel));</span>
<span class="lineNum">     586 </span><span class="lineCov">          2 :             } else if(IsHex(vstr[0])) {</span>
<span class="lineNum">     587 </span><span class="lineCov">          1 :                 std::vector&lt;unsigned char&gt; vData(ParseHex(vstr[0]));</span>
<span class="lineNum">     588 </span><span class="lineCov">          1 :                 CScript script = CScript(vData.begin(), vData.end());</span>
<span class="lineNum">     589 </span><span class="lineCov">          1 :                 int64_t birth_time = ParseISO8601DateTime(vstr[1]);</span>
<span class="lineNum">     590 </span><span class="lineCov">          1 :                 scripts.push_back(std::pair&lt;CScript, int64_t&gt;(script, birth_time));</span>
<span class="lineNum">     591 </span><span class="lineCov">          1 :             }</span>
<span class="lineNum">     592 </span><span class="lineCov">         11 :         }</span>
<span class="lineNum">     593 </span><span class="lineCov">          1 :         file.close();</span>
<span class="lineNum">     594 </span>            :         // We now know whether we are importing private keys, so we can error if private keys are disabled
<span class="lineNum">     595 </span><span class="lineCov">          1 :         if (keys.size() &gt; 0 &amp;&amp; pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :             pwallet-&gt;chain().showProgress(&quot;&quot;, 100, false); // hide progress dialog in GUI</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Importing wallets is disabled when private keys are disabled&quot;);</span>
<span class="lineNum">     598 </span>            :         }
<span class="lineNum">     599 </span><span class="lineCov">          1 :         double total = (double)(keys.size() + scripts.size());</span>
<span class="lineNum">     600 </span><span class="lineCov">          4 :         double progress = 0;</span>
<span class="lineNum">     601 </span><span class="lineCov">          2 :         for (const auto&amp; key_tuple : keys) {</span>
<span class="lineNum">     602 </span><span class="lineCov">          1 :             pwallet-&gt;chain().showProgress(&quot;&quot;, std::max(50, std::min(75, (int)((progress / total) * 100) + 50)), false);</span>
<span class="lineNum">     603 </span><span class="lineCov">          1 :             const CKey&amp; key = std::get&lt;0&gt;(key_tuple);</span>
<span class="lineNum">     604 </span><span class="lineCov">          1 :             int64_t time = std::get&lt;1&gt;(key_tuple);</span>
<span class="lineNum">     605 </span><span class="lineCov">          1 :             bool has_label = std::get&lt;2&gt;(key_tuple);</span>
<span class="lineNum">     606 </span><span class="lineCov">          1 :             std::string label = std::get&lt;3&gt;(key_tuple);</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineCov">          1 :             CPubKey pubkey = key.GetPubKey();</span>
<span class="lineNum">     609 </span><span class="lineCov">          1 :             CHECK_NONFATAL(key.VerifyPubKey(pubkey));</span>
<span class="lineNum">     610 </span><span class="lineCov">          1 :             CKeyID keyid = pubkey.GetID();</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineCov">          1 :             pwallet-&gt;WalletLogPrintf(&quot;Importing %s...\n&quot;, EncodeDestination(PKHash(keyid)));</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span><span class="lineCov">          1 :             if (!pwallet-&gt;ImportPrivKeys({{keyid, key}}, time)) {</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :                 pwallet-&gt;WalletLogPrintf(&quot;Error importing key for %s\n&quot;, EncodeDestination(PKHash(keyid)));</span>
<span class="lineNum">     616 </span>            :                 fGood = false;
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     618 </span>            :             }
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">          1 :             if (has_label)</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                 pwallet-&gt;SetAddressBook(PKHash(keyid), label, &quot;receive&quot;);</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineCov">          1 :             nTimeBegin = std::min(nTimeBegin, time);</span>
<span class="lineNum">     624 </span><span class="lineCov">          1 :             progress++;</span>
<span class="lineNum">     625 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     626 </span><span class="lineCov">          2 :         for (const auto&amp; script_pair : scripts) {</span>
<span class="lineNum">     627 </span><span class="lineCov">          1 :             pwallet-&gt;chain().showProgress(&quot;&quot;, std::max(50, std::min(75, (int)((progress / total) * 100) + 50)), false);</span>
<span class="lineNum">     628 </span><span class="lineCov">          1 :             const CScript&amp; script = script_pair.first;</span>
<span class="lineNum">     629 </span><span class="lineCov">          1 :             int64_t time = script_pair.second;</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineCov">          1 :             if (!pwallet-&gt;ImportScripts({script}, time)) {</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :                 pwallet-&gt;WalletLogPrintf(&quot;Error importing script %s\n&quot;, HexStr(script));</span>
<span class="lineNum">     633 </span>            :                 fGood = false;
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     635 </span>            :             }
<span class="lineNum">     636 </span><span class="lineCov">          1 :             if (time &gt; 0) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                 nTimeBegin = std::min(nTimeBegin, time);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineCov">          1 :             progress++;</span>
<span class="lineNum">     641 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     642 </span><span class="lineCov">          1 :         pwallet-&gt;chain().showProgress(&quot;&quot;, 100, false); // hide progress dialog in GUI</span>
<span class="lineNum">     643 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     644 </span><span class="lineCov">          1 :     pwallet-&gt;chain().showProgress(&quot;&quot;, 100, false); // hide progress dialog in GUI</span>
<span class="lineNum">     645 </span><span class="lineCov">          1 :     RescanWallet(*pwallet, reserver, nTimeBegin, false /* update */);</span>
<span class="lineNum">     646 </span><span class="lineCov">          1 :     pwallet-&gt;MarkDirty();</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineCov">          1 :     if (!fGood)</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error adding some keys/scripts to wallet&quot;);</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineCov">          1 :     return NullUniValue;</span>
<a name="652"><span class="lineNum">     652 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineNoCov">          0 : UniValue dumpprivkey(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     655 </span>            : {
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;dumpprivkey&quot;,</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                 &quot;\nReveals the private key corresponding to 'address'.\n&quot;</span>
<span class="lineNum">     658 </span>            :                 &quot;Then the importprivkey can be used with this output\n&quot;,
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                     {&quot;address&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;The bitcoin address for the private key&quot;},</span>
<span class="lineNum">     661 </span>            :                 },
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :                 RPCResult{</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                     RPCResult::Type::STR, &quot;key&quot;, &quot;The private key&quot;</span>
<span class="lineNum">     664 </span>            :                 },
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                     HelpExampleCli(&quot;dumpprivkey&quot;, &quot;\&quot;myaddress\&quot;&quot;)</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :             + HelpExampleCli(&quot;importprivkey&quot;, &quot;\&quot;mykey\&quot;&quot;)</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :             + HelpExampleRpc(&quot;dumpprivkey&quot;, &quot;\&quot;myaddress\&quot;&quot;)</span>
<span class="lineNum">     669 </span>            :                 },
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :             }.Check(request);</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     const CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     LegacyScriptPubKeyMan&amp; spk_man = EnsureLegacyScriptPubKeyMan(*wallet);</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     LOCK2(pwallet-&gt;cs_wallet, spk_man.cs_KeyStore);</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     EnsureWalletIsUnlocked(pwallet);</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     std::string strAddress = request.params[0].get_str();</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     CTxDestination dest = DecodeDestination(strAddress);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     if (!IsValidDestination(dest)) {</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid Bitcoin address&quot;);</span>
<span class="lineNum">     686 </span>            :     }
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     auto keyid = GetKeyForDestination(spk_man, dest);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     if (keyid.IsNull()) {</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_TYPE_ERROR, &quot;Address does not refer to a key&quot;);</span>
<span class="lineNum">     690 </span>            :     }
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     CKey vchSecret;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     if (!spk_man.GetKey(keyid, vchSecret)) {</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Private key for address &quot; + strAddress + &quot; is not known&quot;);</span>
<span class="lineNum">     694 </span>            :     }
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     return EncodeSecret(vchSecret);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 : }</span>
<a name="697"><span class="lineNum">     697 </span>            : </a>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">          1 : UniValue dumpwallet(const JSONRPCRequest&amp; request)</span>
<span class="lineNum">     700 </span>            : {
<span class="lineNum">     701 </span><span class="lineCov">          3 :             RPCHelpMan{&quot;dumpwallet&quot;,</span>
<span class="lineNum">     702 </span><span class="lineCov">          1 :                 &quot;\nDumps all wallet keys in a human-readable format to a server-side file. This does not allow overwriting existing files.\n&quot;</span>
<span class="lineNum">     703 </span>            :                 &quot;Imported scripts are included in the dumpfile, but corresponding BIP173 addresses, etc. may not be added automatically by importwallet.\n&quot;
<span class="lineNum">     704 </span>            :                 &quot;Note that if your wallet contains keys which are not derived from your HD seed (e.g. imported keys), these are not covered by\n&quot;
<span class="lineNum">     705 </span>            :                 &quot;only backing up the seed itself, and must be backed up too (e.g. ensure you back up the whole dumpfile).\n&quot;,
<span class="lineNum">     706 </span><span class="lineCov">          2 :                 {</span>
<span class="lineNum">     707 </span><span class="lineCov">          1 :                     {&quot;filename&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;The filename with path (absolute path recommended)&quot;},</span>
<span class="lineNum">     708 </span>            :                 },
<span class="lineNum">     709 </span><span class="lineCov">          1 :                 RPCResult{</span>
<span class="lineNum">     710 </span><span class="lineCov">          1 :                     RPCResult::Type::OBJ, &quot;&quot;, &quot;&quot;,</span>
<span class="lineNum">     711 </span><span class="lineCov">          2 :                     {</span>
<span class="lineNum">     712 </span><span class="lineCov">          1 :                         {RPCResult::Type::STR, &quot;filename&quot;, &quot;The filename with full absolute path&quot;},</span>
<span class="lineNum">     713 </span>            :                     }
<span class="lineNum">     714 </span>            :                 },
<span class="lineNum">     715 </span><span class="lineCov">          1 :                 RPCExamples{</span>
<span class="lineNum">     716 </span><span class="lineCov">          1 :                     HelpExampleCli(&quot;dumpwallet&quot;, &quot;\&quot;test\&quot;&quot;)</span>
<span class="lineNum">     717 </span><span class="lineCov">          1 :             + HelpExampleRpc(&quot;dumpwallet&quot;, &quot;\&quot;test\&quot;&quot;)</span>
<span class="lineNum">     718 </span>            :                 },
<span class="lineNum">     719 </span><span class="lineCov">          1 :             }.Check(request);</span>
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineCov">          1 :     std::shared_ptr&lt;CWallet&gt; const pwallet = GetWalletForJSONRPCRequest(request);</span>
<span class="lineNum">     722 </span><span class="lineCov">          1 :     if (!pwallet) return NullUniValue;</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">          1 :     CWallet&amp; wallet = *pwallet;</span>
<span class="lineNum">     725 </span><span class="lineCov">          1 :     LegacyScriptPubKeyMan&amp; spk_man = EnsureLegacyScriptPubKeyMan(wallet);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     // Make sure the results are valid at least up to the most recent block
<span class="lineNum">     728 </span>            :     // the user could have gotten from another RPC command prior to now
<span class="lineNum">     729 </span><span class="lineCov">          1 :     wallet.BlockUntilSyncedToCurrentChain();</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineCov">          1 :     LOCK2(wallet.cs_wallet, spk_man.cs_KeyStore);</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineCov">          1 :     EnsureWalletIsUnlocked(&amp;wallet);</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineCov">          1 :     fs::path filepath = request.params[0].get_str();</span>
<span class="lineNum">     736 </span><span class="lineCov">          1 :     filepath = fs::absolute(filepath);</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :     /* Prevent arbitrary files from being overwritten. There have been reports
<span class="lineNum">     739 </span>            :      * that users have overwritten wallet files this way:
<span class="lineNum">     740 </span>            :      * https://github.com/bitcoin/bitcoin/issues/9934
<span class="lineNum">     741 </span>            :      * It may also avoid other security issues.
<span class="lineNum">     742 </span>            :      */
<span class="lineNum">     743 </span><span class="lineCov">          1 :     if (fs::exists(filepath)) {</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_PARAMETER, filepath.string() + &quot; already exists. If you are sure this is what you want, move it out of the way first&quot;);</span>
<span class="lineNum">     745 </span>            :     }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineCov">          1 :     fsbridge::ofstream file;</span>
<span class="lineNum">     748 </span><span class="lineCov">          1 :     file.open(filepath);</span>
<span class="lineNum">     749 </span><span class="lineCov">          1 :     if (!file.is_open())</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Cannot open wallet dump file&quot;);</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineCov">          1 :     std::map&lt;CKeyID, int64_t&gt; mapKeyBirth;</span>
<span class="lineNum">     753 </span><span class="lineCov">          1 :     const std::map&lt;CKeyID, int64_t&gt;&amp; mapKeyPool = spk_man.GetAllReserveKeys();</span>
<span class="lineNum">     754 </span><span class="lineCov">          1 :     wallet.GetKeyBirthTimes(mapKeyBirth);</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineCov">          1 :     std::set&lt;CScriptID&gt; scripts = spk_man.GetCScripts();</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :     // sort time/key pairs
<span class="lineNum">     759 </span><span class="lineCov">          1 :     std::vector&lt;std::pair&lt;int64_t, CKeyID&gt; &gt; vKeyBirth;</span>
<span class="lineNum">     760 </span><span class="lineCov">          2 :     for (const auto&amp; entry : mapKeyBirth) {</span>
<span class="lineNum">     761 </span><span class="lineCov">          1 :         vKeyBirth.push_back(std::make_pair(entry.second, entry.first));</span>
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span><span class="lineCov">          1 :     mapKeyBirth.clear();</span>
<span class="lineNum">     764 </span><span class="lineCov">          1 :     std::sort(vKeyBirth.begin(), vKeyBirth.end());</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :     // produce output
<span class="lineNum">     767 </span><span class="lineCov">          1 :     file &lt;&lt; strprintf(&quot;# Wallet dump created by Bitcoin %s\n&quot;, CLIENT_BUILD);</span>
<span class="lineNum">     768 </span><span class="lineCov">          1 :     file &lt;&lt; strprintf(&quot;# * Created on %s\n&quot;, FormatISO8601DateTime(GetTime()));</span>
<span class="lineNum">     769 </span><span class="lineCov">          1 :     file &lt;&lt; strprintf(&quot;# * Best block at time of backup was %i (%s),\n&quot;, wallet.GetLastBlockHeight(), wallet.GetLastBlockHash().ToString());</span>
<span class="lineNum">     770 </span><span class="lineCov">          1 :     int64_t block_time = 0;</span>
<span class="lineNum">     771 </span><span class="lineCov">          1 :     CHECK_NONFATAL(wallet.chain().findBlock(wallet.GetLastBlockHash(), FoundBlock().time(block_time)));</span>
<span class="lineNum">     772 </span><span class="lineCov">          1 :     file &lt;&lt; strprintf(&quot;#   mined on %s\n&quot;, FormatISO8601DateTime(block_time));</span>
<span class="lineNum">     773 </span><span class="lineCov">          1 :     file &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :     // add the base58check encoded extended master if the wallet uses HD
<span class="lineNum">     776 </span><span class="lineCov">          1 :     CKeyID seed_id = spk_man.GetHDChain().seed_id;</span>
<span class="lineNum">     777 </span><span class="lineCov">          1 :     if (!seed_id.IsNull())</span>
<span class="lineNum">     778 </span>            :     {
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         CKey seed;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :         if (spk_man.GetKey(seed_id, seed)) {</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :             CExtKey masterKey;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :             masterKey.SetSeed(seed.begin(), seed.size());</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :             file &lt;&lt; &quot;# extended private masterkey: &quot; &lt;&lt; EncodeExtKey(masterKey) &lt;&lt; &quot;\n\n&quot;;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     787 </span><span class="lineCov">          2 :     for (std::vector&lt;std::pair&lt;int64_t, CKeyID&gt; &gt;::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {</span>
<span class="lineNum">     788 </span><span class="lineCov">          1 :         const CKeyID &amp;keyid = it-&gt;second;</span>
<span class="lineNum">     789 </span><span class="lineCov">          1 :         std::string strTime = FormatISO8601DateTime(it-&gt;first);</span>
<span class="lineNum">     790 </span><span class="lineCov">          1 :         std::string strAddr;</span>
<span class="lineNum">     791 </span><span class="lineCov">          1 :         std::string strLabel;</span>
<span class="lineNum">     792 </span><span class="lineCov">          1 :         CKey key;</span>
<span class="lineNum">     793 </span><span class="lineCov">          1 :         if (spk_man.GetKey(keyid, key)) {</span>
<span class="lineNum">     794 </span><span class="lineCov">          1 :             file &lt;&lt; strprintf(&quot;%s %s &quot;, EncodeSecret(key), strTime);</span>
<span class="lineNum">     795 </span><span class="lineCov">          1 :             if (GetWalletAddressesForKey(&amp;spk_man, &amp;wallet, keyid, strAddr, strLabel)) {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                 file &lt;&lt; strprintf(&quot;label=%s&quot;, strLabel);</span>
<span class="lineNum">     797 </span><span class="lineCov">          1 :             } else if (keyid == seed_id) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                 file &lt;&lt; &quot;hdseed=1&quot;;</span>
<span class="lineNum">     799 </span><span class="lineCov">          1 :             } else if (mapKeyPool.count(keyid)) {</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :                 file &lt;&lt; &quot;reserve=1&quot;;</span>
<span class="lineNum">     801 </span><span class="lineCov">          1 :             } else if (spk_man.mapKeyMetadata[keyid].hdKeypath == &quot;s&quot;) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :                 file &lt;&lt; &quot;inactivehdseed=1&quot;;</span>
<span class="lineNum">     803 </span>            :             } else {
<span class="lineNum">     804 </span><span class="lineCov">          1 :                 file &lt;&lt; &quot;change=1&quot;;</span>
<span class="lineNum">     805 </span>            :             }
<span class="lineNum">     806 </span><span class="lineCov">          1 :             file &lt;&lt; strprintf(&quot; # addr=%s%s\n&quot;, strAddr, (spk_man.mapKeyMetadata[keyid].has_key_origin ? &quot; hdkeypath=&quot;+WriteHDKeypath(spk_man.mapKeyMetadata[keyid].key_origin.path) : &quot;&quot;));</span>
<span class="lineNum">     807 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     808 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     809 </span><span class="lineCov">          1 :     file &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     810 </span><span class="lineCov">          2 :     for (const CScriptID &amp;scriptid : scripts) {</span>
<span class="lineNum">     811 </span><span class="lineCov">          1 :         CScript script;</span>
<span class="lineNum">     812 </span><span class="lineCov">          1 :         std::string create_time = &quot;0&quot;;</span>
<span class="lineNum">     813 </span><span class="lineCov">          1 :         std::string address = EncodeDestination(ScriptHash(scriptid));</span>
<span class="lineNum">     814 </span>            :         // get birth times for scripts with metadata
<span class="lineNum">     815 </span><span class="lineCov">          1 :         auto it = spk_man.m_script_metadata.find(scriptid);</span>
<span class="lineNum">     816 </span><span class="lineCov">          1 :         if (it != spk_man.m_script_metadata.end()) {</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :             create_time = FormatISO8601DateTime(it-&gt;second.nCreateTime);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     819 </span><span class="lineCov">          1 :         if(spk_man.GetCScript(scriptid, script)) {</span>
<span class="lineNum">     820 </span><span class="lineCov">          1 :             file &lt;&lt; strprintf(&quot;%s %s script=1&quot;, HexStr(script), create_time);</span>
<span class="lineNum">     821 </span><span class="lineCov">          1 :             file &lt;&lt; strprintf(&quot; # addr=%s\n&quot;, address);</span>
<span class="lineNum">     822 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     823 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     824 </span><span class="lineCov">          1 :     file &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     825 </span><span class="lineCov">          1 :     file &lt;&lt; &quot;# End of dump\n&quot;;</span>
<span class="lineNum">     826 </span><span class="lineCov">          1 :     file.close();</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineCov">          1 :     UniValue reply(UniValue::VOBJ);</span>
<span class="lineNum">     829 </span><span class="lineCov">          1 :     reply.pushKV(&quot;filename&quot;, filepath.string());</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineCov">          1 :     return reply;</span>
<a name="832"><span class="lineNum">     832 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineCov">          4 : struct ImportData</span>
<span class="lineNum">     835 </span>            : {
<span class="lineNum">     836 </span>            :     // Input data
<span class="lineNum">     837 </span>            :     std::unique_ptr&lt;CScript&gt; redeemscript; //!&lt; Provided redeemScript; will be moved to `import_scripts` if relevant.
<span class="lineNum">     838 </span>            :     std::unique_ptr&lt;CScript&gt; witnessscript; //!&lt; Provided witnessScript; will be moved to `import_scripts` if relevant.
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :     // Output data
<span class="lineNum">     841 </span>            :     std::set&lt;CScript&gt; import_scripts;
<span class="lineNum">     842 </span>            :     std::map&lt;CKeyID, bool&gt; used_keys; //!&lt; Import these private keys if available (the value indicates whether if the key is required for solvability)
<span class="lineNum">     843 </span>            :     std::map&lt;CKeyID, std::pair&lt;CPubKey, KeyOriginInfo&gt;&gt; key_origins;
<span class="lineNum">     844 </span>            : };
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : enum class ScriptContext
<span class="lineNum">     847 </span>            : {
<span class="lineNum">     848 </span>            :     TOP, //!&lt; Top-level scriptPubKey
<span class="lineNum">     849 </span>            :     P2SH, //!&lt; P2SH redeemScript
<span class="lineNum">     850 </span>            :     WITNESS_V0, //!&lt; P2WSH witnessScript
<span class="lineNum">     851 </span>            : };
<span class="lineNum">     852 </span>            : 
<a name="853"><span class="lineNum">     853 </span>            : // Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.</a>
<span class="lineNum">     854 </span>            : // Returns an error string, or the empty string for success.
<span class="lineNum">     855 </span><span class="lineNoCov">          0 : static std::string RecurseImportData(const CScript&amp; script, ImportData&amp; import_data, const ScriptContext script_ctx)</span>
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span>            :     // Use Solver to obtain script type and parsed pubkeys or hashes:
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     std::vector&lt;std::vector&lt;unsigned char&gt;&gt; solverdata;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     TxoutType script_type = Solver(script, solverdata);</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     switch (script_type) {</span>
<span class="lineNum">     862 </span>            :     case TxoutType::PUBKEY: {
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :         CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         import_data.used_keys.emplace(pubkey.GetID(), false);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :         return &quot;&quot;;</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     867 </span>            :     case TxoutType::PUBKEYHASH: {
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         CKeyID id = CKeyID(uint160(solverdata[0]));</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :         import_data.used_keys[id] = true;</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :         return &quot;&quot;;</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     872 </span>            :     case TxoutType::SCRIPTHASH: {
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Trying to nest P2SH inside another P2SH&quot;);</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Trying to nest P2SH inside a P2WSH&quot;);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         CHECK_NONFATAL(script_ctx == ScriptContext::TOP);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         CScriptID id = CScriptID(uint160(solverdata[0]));</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :         auto subscript = std::move(import_data.redeemscript); // Remove redeemscript from import_data to check for superfluous script later.</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         if (!subscript) return &quot;missing redeemscript&quot;;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         if (CScriptID(*subscript) != id) return &quot;redeemScript does not match the scriptPubKey&quot;;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :         import_data.import_scripts.emplace(*subscript);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     883 </span>            :     case TxoutType::MULTISIG: {
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :         for (size_t i = 1; i + 1&lt; solverdata.size(); ++i) {</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :             import_data.used_keys.emplace(pubkey.GetID(), false);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         return &quot;&quot;;</span>
<span class="lineNum">     889 </span>            :     }
<span class="lineNum">     890 </span>            :     case TxoutType::WITNESS_V0_SCRIPTHASH: {
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Trying to nest P2WSH inside another P2WSH&quot;);</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         uint256 fullid(solverdata[0]);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         CScriptID id;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         auto subscript = std::move(import_data.witnessscript); // Remove redeemscript from import_data to check for superfluous script later.</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :         if (!subscript) return &quot;missing witnessscript&quot;;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         if (CScriptID(*subscript) != id) return &quot;witnessScript does not match the scriptPubKey or redeemScript&quot;;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         if (script_ctx == ScriptContext::TOP) {</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :             import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         import_data.import_scripts.emplace(*subscript);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     904 </span>            :     case TxoutType::WITNESS_V0_KEYHASH: {
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :         if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Trying to nest P2WPKH inside P2WSH&quot;);</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :         CKeyID id = CKeyID(uint160(solverdata[0]));</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :         import_data.used_keys[id] = true;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :         if (script_ctx == ScriptContext::TOP) {</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :             import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :         return &quot;&quot;;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     913 </span>            :     case TxoutType::NULL_DATA:
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :         return &quot;unspendable script&quot;;</span>
<span class="lineNum">     915 </span>            :     case TxoutType::NONSTANDARD:
<span class="lineNum">     916 </span>            :     case TxoutType::WITNESS_UNKNOWN:
<span class="lineNum">     917 </span>            :     default:
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         return &quot;unrecognized script&quot;;</span>
<span class="lineNum">     919 </span>            :     }
<a name="920"><span class="lineNum">     920 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineCov">          2 : static UniValue ProcessImportLegacy(ImportData&amp; import_data, std::map&lt;CKeyID, CPubKey&gt;&amp; pubkey_map, std::map&lt;CKeyID, CKey&gt;&amp; privkey_map, std::set&lt;CScript&gt;&amp; script_pub_keys, bool&amp; have_solving_data, const UniValue&amp; data, std::vector&lt;CKeyID&gt;&amp; ordered_pubkeys)</span>
<span class="lineNum">     923 </span>            : {
<span class="lineNum">     924 </span><span class="lineCov">          2 :     UniValue warnings(UniValue::VARR);</span>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :     // First ensure scriptPubKey has either a script or JSON with &quot;address&quot; string
<span class="lineNum">     927 </span><span class="lineCov">          2 :     const UniValue&amp; scriptPubKey = data[&quot;scriptPubKey&quot;];</span>
<span class="lineNum">     928 </span><span class="lineCov">          2 :     bool isScript = scriptPubKey.getType() == UniValue::VSTR;</span>
<span class="lineNum">     929 </span><span class="lineCov">          2 :     if (!isScript &amp;&amp; !(scriptPubKey.getType() == UniValue::VOBJ &amp;&amp; scriptPubKey.exists(&quot;address&quot;))) {</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;scriptPubKey must be string with script or JSON with address string&quot;);</span>
<span class="lineNum">     931 </span>            :     }
<span class="lineNum">     932 </span><span class="lineCov">          2 :     const std::string&amp; output = isScript ? scriptPubKey.get_str() : scriptPubKey[&quot;address&quot;].get_str();</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :     // Optional fields.
<span class="lineNum">     935 </span><span class="lineCov">          2 :     const std::string&amp; strRedeemScript = data.exists(&quot;redeemscript&quot;) ? data[&quot;redeemscript&quot;].get_str() : &quot;&quot;;</span>
<span class="lineNum">     936 </span><span class="lineCov">          2 :     const std::string&amp; witness_script_hex = data.exists(&quot;witnessscript&quot;) ? data[&quot;witnessscript&quot;].get_str() : &quot;&quot;;</span>
<span class="lineNum">     937 </span><span class="lineCov">          2 :     const UniValue&amp; pubKeys = data.exists(&quot;pubkeys&quot;) ? data[&quot;pubkeys&quot;].get_array() : UniValue();</span>
<span class="lineNum">     938 </span><span class="lineCov">          2 :     const UniValue&amp; keys = data.exists(&quot;keys&quot;) ? data[&quot;keys&quot;].get_array() : UniValue();</span>
<span class="lineNum">     939 </span><span class="lineCov">          2 :     const bool internal = data.exists(&quot;internal&quot;) ? data[&quot;internal&quot;].get_bool() : false;</span>
<span class="lineNum">     940 </span><span class="lineCov">          2 :     const bool watchOnly = data.exists(&quot;watchonly&quot;) ? data[&quot;watchonly&quot;].get_bool() : false;</span>
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineCov">          2 :     if (data.exists(&quot;range&quot;)) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Range should not be specified for a non-descriptor import&quot;);</span>
<span class="lineNum">     944 </span>            :     }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :     // Generate the script and destination for the scriptPubKey provided
<span class="lineNum">     947 </span><span class="lineCov">          2 :     CScript script;</span>
<span class="lineNum">     948 </span><span class="lineCov">          2 :     if (!isScript) {</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :         CTxDestination dest = DecodeDestination(output);</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         if (!IsValidDestination(dest)) {</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid address \&quot;&quot; + output + &quot;\&quot;&quot;);</span>
<span class="lineNum">     952 </span>            :         }
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         script = GetScriptForDestination(dest);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     955 </span><span class="lineCov">          2 :         if (!IsHex(output)) {</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid scriptPubKey \&quot;&quot; + output + &quot;\&quot;&quot;);</span>
<span class="lineNum">     957 </span>            :         }
<span class="lineNum">     958 </span><span class="lineCov">          2 :         std::vector&lt;unsigned char&gt; vData(ParseHex(output));</span>
<span class="lineNum">     959 </span><span class="lineCov">          2 :         script = CScript(vData.begin(), vData.end());</span>
<span class="lineNum">     960 </span><span class="lineCov">          2 :         CTxDestination dest;</span>
<span class="lineNum">     961 </span><span class="lineCov">          2 :         if (!ExtractDestination(script, dest) &amp;&amp; !internal) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Internal must be set to true for nonstandard scriptPubKey imports.&quot;);</span>
<span class="lineNum">     963 </span>            :         }
<span class="lineNum">     964 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">     965 </span><span class="lineCov">          2 :     script_pub_keys.emplace(script);</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     // Parse all arguments
<span class="lineNum">     968 </span><span class="lineCov">          2 :     if (strRedeemScript.size()) {</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         if (!IsHex(strRedeemScript)) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid redeem script \&quot;&quot; + strRedeemScript + &quot;\&quot;: must be hex string&quot;);</span>
<span class="lineNum">     971 </span>            :         }
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         auto parsed_redeemscript = ParseHex(strRedeemScript);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         import_data.redeemscript = MakeUnique&lt;CScript&gt;(parsed_redeemscript.begin(), parsed_redeemscript.end());</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     975 </span><span class="lineCov">          2 :     if (witness_script_hex.size()) {</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :         if (!IsHex(witness_script_hex)) {</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid witness script \&quot;&quot; + witness_script_hex + &quot;\&quot;: must be hex string&quot;);</span>
<span class="lineNum">     978 </span>            :         }
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         auto parsed_witnessscript = ParseHex(witness_script_hex);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         import_data.witnessscript = MakeUnique&lt;CScript&gt;(parsed_witnessscript.begin(), parsed_witnessscript.end());</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     982 </span><span class="lineCov">          2 :     for (size_t i = 0; i &lt; pubKeys.size(); ++i) {</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         const auto&amp; str = pubKeys[i].get_str();</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         if (!IsHex(str)) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Pubkey \&quot;&quot; + str + &quot;\&quot; must be a hex string&quot;);</span>
<span class="lineNum">     986 </span>            :         }
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :         auto parsed_pubkey = ParseHex(str);</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :         CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         if (!pubkey.IsFullyValid()) {</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Pubkey \&quot;&quot; + str + &quot;\&quot; is not a valid public key&quot;);</span>
<span class="lineNum">     991 </span>            :         }
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         pubkey_map.emplace(pubkey.GetID(), pubkey);</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :         ordered_pubkeys.push_back(pubkey.GetID());</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     995 </span><span class="lineCov">          2 :     for (size_t i = 0; i &lt; keys.size(); ++i) {</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         const auto&amp; str = keys[i].get_str();</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :         CKey key = DecodeSecret(str);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :         if (!key.IsValid()) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid private key encoding&quot;);</span>
<span class="lineNum">    1000 </span>            :         }
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :         CPubKey pubkey = key.GetPubKey();</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         CKeyID id = pubkey.GetID();</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         if (pubkey_map.count(id)) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :             pubkey_map.erase(id);</span>
<span class="lineNum">    1005 </span>            :         }
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         privkey_map.emplace(id, key);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :     // Verify and process input data
<span class="lineNum">    1011 </span><span class="lineCov">          2 :     have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();</span>
<span class="lineNum">    1012 </span><span class="lineCov">          2 :     if (have_solving_data) {</span>
<span class="lineNum">    1013 </span>            :         // Match up data in import_data with the scriptPubKey in script.
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         auto error = RecurseImportData(script, import_data, ScriptContext::TOP);</span>
<a name="1015"><span class="lineNum">    1015 </span>            : </a>
<span class="lineNum">    1016 </span>            :         // Verify whether the watchonly option corresponds to the availability of private keys.
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&amp;](const std::pair&lt;CKeyID, bool&gt;&amp; used_key){ return privkey_map.count(used_key.first) &gt; 0; });</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         if (!watchOnly &amp;&amp; !spendable) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :             warnings.push_back(&quot;Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.&quot;);</span>
<span class="lineNum">    1020 </span>            :         }
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :         if (watchOnly &amp;&amp; spendable) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :             warnings.push_back(&quot;All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.&quot;);</span>
<span class="lineNum">    1023 </span>            :         }
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :         // Check that all required keys for solvability are provided.
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :         if (error.empty()) {</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :             for (const auto&amp; require_key : import_data.used_keys) {</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                 if (!require_key.second) continue; // Not a required key</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                 if (pubkey_map.count(require_key.first) == 0 &amp;&amp; privkey_map.count(require_key.first) == 0) {</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                     error = &quot;some required keys are missing&quot;;</span>
<span class="lineNum">    1031 </span>            :                 }
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         if (!error.empty()) {</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :             warnings.push_back(&quot;Importing as non-solvable: &quot; + error + &quot;. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.&quot;);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :             import_data = ImportData();</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :             pubkey_map.clear();</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :             privkey_map.clear();</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :             have_solving_data = false;</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    1042 </span>            :             // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :             if (import_data.redeemscript) warnings.push_back(&quot;Ignoring redeemscript as this is not a P2SH script.&quot;);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :             if (import_data.witnessscript) warnings.push_back(&quot;Ignoring witnessscript as this is not a (P2SH-)P2WSH script.&quot;);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :             for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                 auto oldit = it++;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                 if (import_data.used_keys.count(oldit-&gt;first) == 0) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :                     warnings.push_back(&quot;Ignoring irrelevant private key.&quot;);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                     privkey_map.erase(oldit);</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :             for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :                 auto oldit = it++;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                 auto key_data_it = import_data.used_keys.find(oldit-&gt;first);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                 if (key_data_it == import_data.used_keys.end() || !key_data_it-&gt;second) {</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :                     warnings.push_back(&quot;Ignoring public key \&quot;&quot; + HexStr(oldit-&gt;first) + &quot;\&quot; as it doesn't appear inside P2PKH or P2WPKH.&quot;);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :                     pubkey_map.erase(oldit);</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1060 </span>            :         }
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :     return warnings;
<a name="1064"><span class="lineNum">    1064 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 : static UniValue ProcessImportDescriptor(ImportData&amp; import_data, std::map&lt;CKeyID, CPubKey&gt;&amp; pubkey_map, std::map&lt;CKeyID, CKey&gt;&amp; privkey_map, std::set&lt;CScript&gt;&amp; script_pub_keys, bool&amp; have_solving_data, const UniValue&amp; data, std::vector&lt;CKeyID&gt;&amp; ordered_pubkeys)</span>
<span class="lineNum">    1067 </span>            : {
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     UniValue warnings(UniValue::VARR);</span>
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     const std::string&amp; descriptor = data[&quot;desc&quot;].get_str();</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     FlatSigningProvider keys;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     std::string error;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     if (!parsed_desc) {</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);</span>
<span class="lineNum">    1076 </span>            :     }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     have_solving_data = parsed_desc-&gt;IsSolvable();</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     const bool watch_only = data.exists(&quot;watchonly&quot;) ? data[&quot;watchonly&quot;].get_bool() : false;</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     int64_t range_start = 0, range_end = 0;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     if (!parsed_desc-&gt;IsRange() &amp;&amp; data.exists(&quot;range&quot;)) {</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Range should not be specified for an un-ranged descriptor&quot;);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :     } else if (parsed_desc-&gt;IsRange()) {</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         if (!data.exists(&quot;range&quot;)) {</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Descriptor is ranged, please specify the range&quot;);</span>
<span class="lineNum">    1087 </span>            :         }
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         std::tie(range_start, range_end) = ParseDescriptorRange(data[&quot;range&quot;]);</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     const UniValue&amp; priv_keys = data.exists(&quot;keys&quot;) ? data[&quot;keys&quot;].get_array() : UniValue();</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :     // Expand all descriptors to get public keys and scripts, and private keys if available.
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     for (int i = range_start; i &lt;= range_end; ++i) {</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         FlatSigningProvider out_keys;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         std::vector&lt;CScript&gt; scripts_temp;</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         parsed_desc-&gt;Expand(i, keys, scripts_temp, out_keys);</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         for (const auto&amp; key_pair : out_keys.pubkeys) {</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :             ordered_pubkeys.push_back(key_pair.first);</span>
<span class="lineNum">    1101 </span>            :         }
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         for (const auto&amp; x : out_keys.scripts) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :             import_data.import_scripts.emplace(x.second);</span>
<span class="lineNum">    1105 </span>            :         }
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         parsed_desc-&gt;ExpandPrivate(i, keys, out_keys);</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :         std::copy(out_keys.keys.begin(), out_keys.keys.end(), std::inserter(privkey_map, privkey_map.end()));</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :         import_data.key_origins.insert(out_keys.origins.begin(), out_keys.origins.end());</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; priv_keys.size(); ++i) {</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         const auto&amp; str = priv_keys[i].get_str();</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :         CKey key = DecodeSecret(str);</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         if (!key.IsValid()) {</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, &quot;Invalid private key encoding&quot;);</span>
<span class="lineNum">    1119 </span>            :         }
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         CPubKey pubkey = key.GetPubKey();</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         CKeyID id = pubkey.GetID();</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :         // Check if this private key corresponds to a public key from the descriptor
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :         if (!pubkey_map.count(id)) {</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :             warnings.push_back(&quot;Ignoring irrelevant private key.&quot;);</span>
<span class="lineNum">    1126 </span>            :         } else {
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :             privkey_map.emplace(id, key);</span>
<span class="lineNum">    1128 </span>            :         }
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span>            :     // Check if all the public keys have corresponding private keys in the import for spendability.
<span class="lineNum">    1132 </span>            :     // This does not take into account threshold multisigs which could be spendable without all keys.
<span class="lineNum">    1133 </span>            :     // Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,
<a name="1134"><span class="lineNum">    1134 </span>            :     // perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.</a>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(),</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         [&amp;](const std::pair&lt;CKeyID, CPubKey&gt;&amp; used_key) {</span>
<a name="1137"><span class="lineNum">    1137 </span><span class="lineNoCov">          0 :             return privkey_map.count(used_key.first) &gt; 0;</span></a>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :         }) &amp;&amp; std::all_of(import_data.key_origins.begin(), import_data.key_origins.end(),</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         [&amp;](const std::pair&lt;CKeyID, std::pair&lt;CPubKey, KeyOriginInfo&gt;&gt;&amp; entry) {</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :             return privkey_map.count(entry.first) &gt; 0;</span>
<span class="lineNum">    1141 </span>            :         });
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     if (!watch_only &amp;&amp; !spendable) {</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :         warnings.push_back(&quot;Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.&quot;);</span>
<span class="lineNum">    1144 </span>            :     }
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     if (watch_only &amp;&amp; spendable) {</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         warnings.push_back(&quot;All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.&quot;);</span>
<span class="lineNum">    1147 </span>            :     }
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span>            :     return warnings;
<a name="1150"><span class="lineNum">    1150 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineCov">          2 : static UniValue ProcessImport(CWallet * const pwallet, const UniValue&amp; data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet-&gt;cs_wallet)</span>
<span class="lineNum">    1153 </span>            : {
<span class="lineNum">    1154 </span><span class="lineCov">          2 :     UniValue warnings(UniValue::VARR);</span>
<span class="lineNum">    1155 </span><span class="lineCov">          2 :     UniValue result(UniValue::VOBJ);</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            :     try {
<span class="lineNum">    1158 </span><span class="lineCov">          2 :         const bool internal = data.exists(&quot;internal&quot;) ? data[&quot;internal&quot;].get_bool() : false;</span>
<span class="lineNum">    1159 </span>            :         // Internal addresses should not have a label
<span class="lineNum">    1160 </span><span class="lineCov">          2 :         if (internal &amp;&amp; data.exists(&quot;label&quot;)) {</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Internal addresses should not have a label&quot;);</span>
<span class="lineNum">    1162 </span>            :         }
<span class="lineNum">    1163 </span><span class="lineCov">          2 :         const std::string&amp; label = data.exists(&quot;label&quot;) ? data[&quot;label&quot;].get_str() : &quot;&quot;;</span>
<span class="lineNum">    1164 </span><span class="lineCov">          2 :         const bool add_keypool = data.exists(&quot;keypool&quot;) ? data[&quot;keypool&quot;].get_bool() : false;</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            :         // Add to keypool only works with privkeys disabled
<span class="lineNum">    1167 </span><span class="lineCov">          2 :         if (add_keypool &amp;&amp; !pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Keys can only be imported to the keypool when private keys are disabled&quot;);</span>
<span class="lineNum">    1169 </span>            :         }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineCov">          2 :         ImportData import_data;</span>
<span class="lineNum">    1172 </span><span class="lineCov">          2 :         std::map&lt;CKeyID, CPubKey&gt; pubkey_map;</span>
<span class="lineNum">    1173 </span><span class="lineCov">          2 :         std::map&lt;CKeyID, CKey&gt; privkey_map;</span>
<span class="lineNum">    1174 </span><span class="lineCov">          2 :         std::set&lt;CScript&gt; script_pub_keys;</span>
<span class="lineNum">    1175 </span><span class="lineCov">          2 :         std::vector&lt;CKeyID&gt; ordered_pubkeys;</span>
<span class="lineNum">    1176 </span><span class="lineCov">          2 :         bool have_solving_data;</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineCov">          2 :         if (data.exists(&quot;scriptPubKey&quot;) &amp;&amp; data.exists(&quot;desc&quot;)) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Both a descriptor and a scriptPubKey should not be provided.&quot;);</span>
<span class="lineNum">    1180 </span><span class="lineCov">          2 :         } else if (data.exists(&quot;scriptPubKey&quot;)) {</span>
<span class="lineNum">    1181 </span><span class="lineCov">          2 :             warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data, ordered_pubkeys);</span>
<span class="lineNum">    1182 </span><span class="lineCov">          2 :         } else if (data.exists(&quot;desc&quot;)) {</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :             warnings = ProcessImportDescriptor(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data, ordered_pubkeys);</span>
<span class="lineNum">    1184 </span>            :         } else {
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Either a descriptor or scriptPubKey must be provided.&quot;);</span>
<span class="lineNum">    1186 </span>            :         }
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :         // If private keys are disabled, abort if private keys are being imported
<span class="lineNum">    1189 </span><span class="lineCov">          2 :         if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) &amp;&amp; !privkey_map.empty()) {</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Cannot import private keys to a wallet with private keys disabled&quot;);</span>
<span class="lineNum">    1191 </span>            :         }
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :         // Check whether we have any work to do
<span class="lineNum">    1194 </span><span class="lineCov">          4 :         for (const CScript&amp; script : script_pub_keys) {</span>
<span class="lineNum">    1195 </span><span class="lineCov">          2 :             if (pwallet-&gt;IsMine(script) &amp; ISMINE_SPENDABLE) {</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :                 throw JSONRPCError(RPC_WALLET_ERROR, &quot;The wallet already contains the private key for this address or script (\&quot;&quot; + HexStr(script) + &quot;\&quot;)&quot;);</span>
<span class="lineNum">    1197 </span>            :             }
<span class="lineNum">    1198 </span>            :         }
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :         // All good, time to import
<span class="lineNum">    1201 </span><span class="lineCov">          2 :         pwallet-&gt;MarkDirty();</span>
<span class="lineNum">    1202 </span><span class="lineCov">          2 :         if (!pwallet-&gt;ImportScripts(import_data.import_scripts, timestamp)) {</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error adding script to wallet&quot;);</span>
<span class="lineNum">    1204 </span>            :         }
<span class="lineNum">    1205 </span><span class="lineCov">          2 :         if (!pwallet-&gt;ImportPrivKeys(privkey_map, timestamp)) {</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error adding key to wallet&quot;);</span>
<span class="lineNum">    1207 </span>            :         }
<span class="lineNum">    1208 </span><span class="lineCov">          2 :         if (!pwallet-&gt;ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, internal, timestamp)) {</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error adding address to wallet&quot;);</span>
<span class="lineNum">    1210 </span>            :         }
<span class="lineNum">    1211 </span><span class="lineCov">          2 :         if (!pwallet-&gt;ImportScriptPubKeys(label, script_pub_keys, have_solving_data, !internal, timestamp)) {</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error adding address to wallet&quot;);</span>
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineCov">          2 :         result.pushKV(&quot;success&quot;, UniValue(true));</span>
<span class="lineNum">    1216 </span><span class="lineCov">          2 :     } catch (const UniValue&amp; e) {</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;success&quot;, UniValue(false));</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;error&quot;, e);</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     } catch (...) {</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;success&quot;, UniValue(false));</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;error&quot;, JSONRPCError(RPC_MISC_ERROR, &quot;Missing required fields&quot;));</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1224 </span><span class="lineCov">          2 :     if (warnings.size()) result.pushKV(&quot;warnings&quot;, warnings);</span>
<span class="lineNum">    1225 </span>            :     return result;
<a name="1226"><span class="lineNum">    1226 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineCov">          7 : static int64_t GetImportTimestamp(const UniValue&amp; data, int64_t now)</span>
<span class="lineNum">    1229 </span>            : {
<span class="lineNum">    1230 </span><span class="lineCov">          7 :     if (data.exists(&quot;timestamp&quot;)) {</span>
<span class="lineNum">    1231 </span><span class="lineCov">          7 :         const UniValue&amp; timestamp = data[&quot;timestamp&quot;];</span>
<span class="lineNum">    1232 </span><span class="lineCov">          7 :         if (timestamp.isNum()) {</span>
<span class="lineNum">    1233 </span><span class="lineCov">          7 :             return timestamp.get_int64();</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :         } else if (timestamp.isStr() &amp;&amp; timestamp.get_str() == &quot;now&quot;) {</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :             return now;</span>
<span class="lineNum">    1236 </span>            :         }
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_TYPE_ERROR, strprintf(&quot;Expected number or \&quot;now\&quot; timestamp value for key. got type %s&quot;, uvTypeName(timestamp.type())));</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     throw JSONRPCError(RPC_TYPE_ERROR, &quot;Missing required timestamp field for key&quot;);</span>
<a name="1240"><span class="lineNum">    1240 </span><span class="lineCov">          7 : }</span></a>
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span><span class="lineCov">          1 : UniValue importmulti(const JSONRPCRequest&amp; mainRequest)</span>
<span class="lineNum">    1243 </span>            : {
<span class="lineNum">    1244 </span><span class="lineCov">         19 :             RPCHelpMan{&quot;importmulti&quot;,</span>
<span class="lineNum">    1245 </span><span class="lineCov">          1 :                 &quot;\nImport addresses/scripts (with private or public keys, redeem script (P2SH)), optionally rescanning the blockchain from the earliest creation time of the imported scripts. Requires a new wallet backup.\n&quot;</span>
<span class="lineNum">    1246 </span>            :                 &quot;If an address/script is imported without all of the private keys required to spend from that address, it will be watchonly. The 'watchonly' option must be set to true in this case or a warning will be returned.\n&quot;
<span class="lineNum">    1247 </span>            :                 &quot;Conversely, if all the private keys are provided and the address/script is spendable, the watchonly option must be set to false, or a warning will be returned.\n&quot;
<span class="lineNum">    1248 </span>            :             &quot;\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n&quot;
<span class="lineNum">    1249 </span>            :             &quot;may report that the imported keys, addresses or scripts exist but related transactions are still missing.\n&quot;
<span class="lineNum">    1250 </span>            :             &quot;Note: Use \&quot;getwalletinfo\&quot; to query the scanning progress.\n&quot;,
<span class="lineNum">    1251 </span><span class="lineCov">          3 :                 {</span>
<span class="lineNum">    1252 </span><span class="lineCov">          2 :                     {&quot;requests&quot;, RPCArg::Type::ARR, RPCArg::Optional::NO, &quot;Data to be imported&quot;,</span>
<span class="lineNum">    1253 </span><span class="lineCov">          2 :                         {</span>
<span class="lineNum">    1254 </span><span class="lineCov">          2 :                             {&quot;&quot;, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, &quot;&quot;,</span>
<span class="lineNum">    1255 </span><span class="lineCov">         13 :                                 {</span>
<span class="lineNum">    1256 </span><span class="lineCov">          1 :                                     {&quot;desc&quot;, RPCArg::Type::STR, RPCArg::Optional::OMITTED, &quot;Descriptor to import. If using descriptor, do not also provide address/scriptPubKey, scripts, or pubkeys&quot;},</span>
<span class="lineNum">    1257 </span><span class="lineCov">          2 :                                     {&quot;scriptPubKey&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;Type of scriptPubKey (string for script, json for address). Should not be provided if using a descriptor&quot;,</span>
<span class="lineNum">    1258 </span><span class="lineCov">          1 :                                         /* oneline_description */ &quot;&quot;, {&quot;\&quot;&lt;script&gt;\&quot; | { \&quot;address\&quot;:\&quot;&lt;address&gt;\&quot; }&quot;, &quot;string / json&quot;}</span>
<span class="lineNum">    1259 </span>            :                                     },
<span class="lineNum">    1260 </span><span class="lineCov">          2 :                                     {&quot;timestamp&quot;, RPCArg::Type::NUM, RPCArg::Optional::NO, &quot;Creation time of the key expressed in &quot; + UNIX_EPOCH_TIME + &quot;,\n&quot;</span>
<span class="lineNum">    1261 </span>            :         &quot;                                                              or the string \&quot;now\&quot; to substitute the current synced blockchain time. The timestamp of the oldest\n&quot;
<span class="lineNum">    1262 </span>            :         &quot;                                                              key will determine how far back blockchain rescans need to begin for missing wallet transactions.\n&quot;
<span class="lineNum">    1263 </span>            :         &quot;                                                              \&quot;now\&quot; can be specified to bypass scanning, for keys which are known to never have been used, and\n&quot;
<span class="lineNum">    1264 </span>            :         &quot;                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\n&quot;
<span class="lineNum">    1265 </span>            :         &quot;                                                              creation time of all keys being imported by the importmulti call will be scanned.&quot;,
<span class="lineNum">    1266 </span><span class="lineCov">          1 :                                         /* oneline_description */ &quot;&quot;, {&quot;timestamp | \&quot;now\&quot;&quot;, &quot;integer / string&quot;}</span>
<span class="lineNum">    1267 </span>            :                                     },
<span class="lineNum">    1268 </span><span class="lineCov">          1 :                                     {&quot;redeemscript&quot;, RPCArg::Type::STR, RPCArg::Optional::OMITTED, &quot;Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey&quot;},</span>
<span class="lineNum">    1269 </span><span class="lineCov">          1 :                                     {&quot;witnessscript&quot;, RPCArg::Type::STR, RPCArg::Optional::OMITTED, &quot;Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey&quot;},</span>
<span class="lineNum">    1270 </span><span class="lineCov">          2 :                                     {&quot;pubkeys&quot;, RPCArg::Type::ARR, /* default */ &quot;empty array&quot;, &quot;Array of strings giving pubkeys to import. They must occur in P2PKH or P2WPKH scripts. They are not required when the private key is also provided (see the \&quot;keys\&quot; argument).&quot;,</span>
<span class="lineNum">    1271 </span><span class="lineCov">          2 :                                         {</span>
<span class="lineNum">    1272 </span><span class="lineCov">          1 :                                             {&quot;pubKey&quot;, RPCArg::Type::STR, RPCArg::Optional::OMITTED, &quot;&quot;},</span>
<span class="lineNum">    1273 </span>            :                                         }
<span class="lineNum">    1274 </span>            :                                     },
<span class="lineNum">    1275 </span><span class="lineCov">          2 :                                     {&quot;keys&quot;, RPCArg::Type::ARR, /* default */ &quot;empty array&quot;, &quot;Array of strings giving private keys to import. The corresponding public keys must occur in the output or redeemscript.&quot;,</span>
<span class="lineNum">    1276 </span><span class="lineCov">          2 :                                         {</span>
<span class="lineNum">    1277 </span><span class="lineCov">          1 :                                             {&quot;key&quot;, RPCArg::Type::STR, RPCArg::Optional::OMITTED, &quot;&quot;},</span>
<span class="lineNum">    1278 </span>            :                                         }
<span class="lineNum">    1279 </span>            :                                     },
<span class="lineNum">    1280 </span><span class="lineCov">          1 :                                     {&quot;range&quot;, RPCArg::Type::RANGE, RPCArg::Optional::OMITTED, &quot;If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import&quot;},</span>
<span class="lineNum">    1281 </span><span class="lineCov">          1 :                                     {&quot;internal&quot;, RPCArg::Type::BOOL, /* default */ &quot;false&quot;, &quot;Stating whether matching outputs should be treated as not incoming payments (also known as change)&quot;},</span>
<span class="lineNum">    1282 </span><span class="lineCov">          1 :                                     {&quot;watchonly&quot;, RPCArg::Type::BOOL, /* default */ &quot;false&quot;, &quot;Stating whether matching outputs should be considered watchonly.&quot;},</span>
<span class="lineNum">    1283 </span><span class="lineCov">          1 :                                     {&quot;label&quot;, RPCArg::Type::STR, /* default */ &quot;''&quot;, &quot;Label to assign to the address, only allowed with internal=false&quot;},</span>
<span class="lineNum">    1284 </span><span class="lineCov">          1 :                                     {&quot;keypool&quot;, RPCArg::Type::BOOL, /* default */ &quot;false&quot;, &quot;Stating whether imported public keys should be added to the keypool for when users request new addresses. Only allowed when wallet private keys are disabled&quot;},</span>
<span class="lineNum">    1285 </span>            :                                 },
<span class="lineNum">    1286 </span>            :                             },
<span class="lineNum">    1287 </span>            :                         },
<span class="lineNum">    1288 </span><span class="lineCov">          1 :                         &quot;\&quot;requests\&quot;&quot;},</span>
<span class="lineNum">    1289 </span><span class="lineCov">          2 :                     {&quot;options&quot;, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, &quot;&quot;,</span>
<span class="lineNum">    1290 </span><span class="lineCov">          2 :                         {</span>
<span class="lineNum">    1291 </span><span class="lineCov">          1 :                             {&quot;rescan&quot;, RPCArg::Type::BOOL, /* default */ &quot;true&quot;, &quot;Stating if should rescan the blockchain after all imports&quot;},</span>
<span class="lineNum">    1292 </span>            :                         },
<span class="lineNum">    1293 </span><span class="lineCov">          1 :                         &quot;\&quot;options\&quot;&quot;},</span>
<span class="lineNum">    1294 </span>            :                 },
<span class="lineNum">    1295 </span><span class="lineCov">          1 :                 RPCResult{</span>
<span class="lineNum">    1296 </span><span class="lineCov">          1 :                     RPCResult::Type::ARR, &quot;&quot;, &quot;Response is an array with the same size as the input that has the execution result&quot;,</span>
<span class="lineNum">    1297 </span><span class="lineCov">          2 :                     {</span>
<span class="lineNum">    1298 </span><span class="lineCov">          2 :                         {RPCResult::Type::OBJ, &quot;&quot;, &quot;&quot;,</span>
<span class="lineNum">    1299 </span><span class="lineCov">          4 :                         {</span>
<span class="lineNum">    1300 </span><span class="lineCov">          1 :                             {RPCResult::Type::BOOL, &quot;success&quot;, &quot;&quot;},</span>
<span class="lineNum">    1301 </span><span class="lineCov">          2 :                             {RPCResult::Type::ARR, &quot;warnings&quot;, /* optional */ true, &quot;&quot;,</span>
<span class="lineNum">    1302 </span><span class="lineCov">          2 :                             {</span>
<span class="lineNum">    1303 </span><span class="lineCov">          1 :                                 {RPCResult::Type::STR, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">    1304 </span>            :                             }},
<span class="lineNum">    1305 </span><span class="lineCov">          2 :                             {RPCResult::Type::OBJ, &quot;error&quot;, /* optional */ true, &quot;&quot;,</span>
<span class="lineNum">    1306 </span><span class="lineCov">          2 :                             {</span>
<span class="lineNum">    1307 </span><span class="lineCov">          1 :                                 {RPCResult::Type::ELISION, &quot;&quot;, &quot;JSONRPC error&quot;},</span>
<span class="lineNum">    1308 </span>            :                             }},
<span class="lineNum">    1309 </span>            :                         }},
<span class="lineNum">    1310 </span>            :                     }
<span class="lineNum">    1311 </span>            :                 },
<span class="lineNum">    1312 </span><span class="lineCov">          1 :                 RPCExamples{</span>
<span class="lineNum">    1313 </span><span class="lineCov">          1 :                     HelpExampleCli(&quot;importmulti&quot;, &quot;'[{ \&quot;scriptPubKey\&quot;: { \&quot;address\&quot;: \&quot;&lt;my address&gt;\&quot; }, \&quot;timestamp\&quot;:1455191478 }, &quot;</span>
<span class="lineNum">    1314 </span><span class="lineCov">          1 :                                           &quot;{ \&quot;scriptPubKey\&quot;: { \&quot;address\&quot;: \&quot;&lt;my 2nd address&gt;\&quot; }, \&quot;label\&quot;: \&quot;example 2\&quot;, \&quot;timestamp\&quot;: 1455191480 }]'&quot;) +</span>
<span class="lineNum">    1315 </span><span class="lineCov">          1 :                     HelpExampleCli(&quot;importmulti&quot;, &quot;'[{ \&quot;scriptPubKey\&quot;: { \&quot;address\&quot;: \&quot;&lt;my address&gt;\&quot; }, \&quot;timestamp\&quot;:1455191478 }]' '{ \&quot;rescan\&quot;: false}'&quot;)</span>
<span class="lineNum">    1316 </span>            :                 },
<span class="lineNum">    1317 </span><span class="lineCov">          1 :             }.Check(mainRequest);</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span><span class="lineCov">          1 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(mainRequest);</span>
<span class="lineNum">    1320 </span><span class="lineCov">          1 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">    1321 </span><span class="lineCov">          1 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineCov">          1 :     RPCTypeCheck(mainRequest.params, {UniValue::VARR, UniValue::VOBJ});</span>
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span><span class="lineCov">          1 :     EnsureLegacyScriptPubKeyMan(*wallet, true);</span>
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineCov">          1 :     const UniValue&amp; requests = mainRequest.params[0];</span>
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :     //Default options
<span class="lineNum">    1330 </span>            :     bool fRescan = true;
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineCov">          1 :     if (!mainRequest.params[1].isNull()) {</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :         const UniValue&amp; options = mainRequest.params[1];</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :         if (options.exists(&quot;rescan&quot;)) {</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :             fRescan = options[&quot;rescan&quot;].get_bool();</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineCov">          1 :     WalletRescanReserver reserver(*pwallet);</span>
<span class="lineNum">    1341 </span><span class="lineCov">          1 :     if (fRescan &amp;&amp; !reserver.reserve()) {</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Wallet is currently rescanning. Abort existing rescan or wait.&quot;);</span>
<span class="lineNum">    1343 </span>            :     }
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineCov">          1 :     int64_t now = 0;</span>
<span class="lineNum">    1346 </span>            :     bool fRunScan = false;
<span class="lineNum">    1347 </span><span class="lineCov">          1 :     int64_t nLowestTimestamp = 0;</span>
<span class="lineNum">    1348 </span><span class="lineCov">          1 :     UniValue response(UniValue::VARR);</span>
<span class="lineNum">    1349 </span>            :     {
<span class="lineNum">    1350 </span><span class="lineCov">          1 :         LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">    1351 </span><span class="lineCov">          1 :         EnsureWalletIsUnlocked(pwallet);</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :         // Verify all timestamps are present before importing any keys.
<span class="lineNum">    1354 </span><span class="lineCov">          1 :         CHECK_NONFATAL(pwallet-&gt;chain().findBlock(pwallet-&gt;GetLastBlockHash(), FoundBlock().time(nLowestTimestamp).mtpTime(now)));</span>
<span class="lineNum">    1355 </span><span class="lineCov">          3 :         for (const UniValue&amp; data : requests.getValues()) {</span>
<span class="lineNum">    1356 </span><span class="lineCov">          2 :             GetImportTimestamp(data, now);</span>
<span class="lineNum">    1357 </span>            :         }
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineCov">          1 :         const int64_t minimumTimestamp = 1;</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineCov">          3 :         for (const UniValue&amp; data : requests.getValues()) {</span>
<span class="lineNum">    1362 </span><span class="lineCov">          2 :             const int64_t timestamp = std::max(GetImportTimestamp(data, now), minimumTimestamp);</span>
<span class="lineNum">    1363 </span><span class="lineCov">          2 :             const UniValue result = ProcessImport(pwallet, data, timestamp);</span>
<span class="lineNum">    1364 </span><span class="lineCov">          2 :             response.push_back(result);</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">          2 :             if (!fRescan) {</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1368 </span>            :             }
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :             // If at least one request was successful then allow rescan.
<span class="lineNum">    1371 </span><span class="lineCov">          2 :             if (result[&quot;success&quot;].get_bool()) {</span>
<span class="lineNum">    1372 </span>            :                 fRunScan = true;
<span class="lineNum">    1373 </span><span class="lineCov">          2 :             }</span>
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span>            :             // Get the lowest timestamp.
<span class="lineNum">    1376 </span><span class="lineCov">          2 :             if (timestamp &lt; nLowestTimestamp) {</span>
<span class="lineNum">    1377 </span><span class="lineCov">          1 :                 nLowestTimestamp = timestamp;</span>
<span class="lineNum">    1378 </span><span class="lineCov">          1 :             }</span>
<span class="lineNum">    1379 </span><span class="lineCov">          2 :         }</span>
<span class="lineNum">    1380 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    1381 </span><span class="lineCov">          1 :     if (fRescan &amp;&amp; fRunScan &amp;&amp; requests.size()) {</span>
<span class="lineNum">    1382 </span><span class="lineCov">          1 :         int64_t scannedTime = pwallet-&gt;RescanFromTime(nLowestTimestamp, reserver, true /* update */);</span>
<span class="lineNum">    1383 </span>            :         {
<span class="lineNum">    1384 </span><span class="lineCov">          1 :             LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">    1385 </span><span class="lineCov">          1 :             pwallet-&gt;ReacceptWalletTransactions();</span>
<span class="lineNum">    1386 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineCov">          1 :         if (pwallet-&gt;IsAbortingRescan()) {</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_MISC_ERROR, &quot;Rescan aborted by user.&quot;);</span>
<span class="lineNum">    1390 </span>            :         }
<span class="lineNum">    1391 </span><span class="lineCov">          1 :         if (scannedTime &gt; nLowestTimestamp) {</span>
<span class="lineNum">    1392 </span><span class="lineCov">          1 :             std::vector&lt;UniValue&gt; results = response.getValues();</span>
<span class="lineNum">    1393 </span><span class="lineCov">          1 :             response.clear();</span>
<span class="lineNum">    1394 </span><span class="lineCov">          1 :             response.setArray();</span>
<span class="lineNum">    1395 </span>            :             size_t i = 0;
<span class="lineNum">    1396 </span><span class="lineCov">          3 :             for (const UniValue&amp; request : requests.getValues()) {</span>
<span class="lineNum">    1397 </span>            :                 // If key creation date is within the successfully scanned
<span class="lineNum">    1398 </span>            :                 // range, or if the import result already has an error set, let
<span class="lineNum">    1399 </span>            :                 // the result stand unmodified. Otherwise replace the result
<span class="lineNum">    1400 </span>            :                 // with an error message.
<span class="lineNum">    1401 </span><span class="lineCov">          2 :                 if (scannedTime &lt;= GetImportTimestamp(request, now) || results.at(i).exists(&quot;error&quot;)) {</span>
<span class="lineNum">    1402 </span><span class="lineCov">          1 :                     response.push_back(results.at(i));</span>
<span class="lineNum">    1403 </span>            :                 } else {
<span class="lineNum">    1404 </span><span class="lineCov">          1 :                     UniValue result = UniValue(UniValue::VOBJ);</span>
<span class="lineNum">    1405 </span><span class="lineCov">          1 :                     result.pushKV(&quot;success&quot;, UniValue(false));</span>
<span class="lineNum">    1406 </span><span class="lineCov">          1 :                     result.pushKV(</span>
<span class="lineNum">    1407 </span><span class="lineCov">          1 :                         &quot;error&quot;,</span>
<span class="lineNum">    1408 </span><span class="lineCov">          2 :                         JSONRPCError(</span>
<span class="lineNum">    1409 </span>            :                             RPC_MISC_ERROR,
<span class="lineNum">    1410 </span><span class="lineCov">          1 :                             strprintf(&quot;Rescan failed for key with creation timestamp %d. There was an error reading a &quot;</span>
<span class="lineNum">    1411 </span>            :                                       &quot;block from time %d, which is after or within %d seconds of key creation, and &quot;
<span class="lineNum">    1412 </span>            :                                       &quot;could contain transactions pertaining to the key. As a result, transactions &quot;
<span class="lineNum">    1413 </span>            :                                       &quot;and coins using this key may not appear in the wallet. This error could be &quot;
<span class="lineNum">    1414 </span>            :                                       &quot;caused by pruning or data corruption (see bitcoind log for details) and could &quot;
<span class="lineNum">    1415 </span>            :                                       &quot;be dealt with by downloading and rescanning the relevant blocks (see -reindex &quot;
<span class="lineNum">    1416 </span>            :                                       &quot;and -rescan options).&quot;,
<span class="lineNum">    1417 </span><span class="lineCov">          1 :                                 GetImportTimestamp(request, now), scannedTime - TIMESTAMP_WINDOW - 1, TIMESTAMP_WINDOW)));</span>
<span class="lineNum">    1418 </span><span class="lineCov">          1 :                     response.push_back(std::move(result));</span>
<span class="lineNum">    1419 </span><span class="lineCov">          1 :                 }</span>
<span class="lineNum">    1420 </span><span class="lineCov">          2 :                 ++i;</span>
<span class="lineNum">    1421 </span>            :             }
<span class="lineNum">    1422 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">    1423 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span><span class="lineCov">          1 :     return response;</span>
<a name="1426"><span class="lineNum">    1426 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 : static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&amp; data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet-&gt;cs_wallet)</span>
<span class="lineNum">    1429 </span>            : {
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     UniValue warnings(UniValue::VARR);</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     UniValue result(UniValue::VOBJ);</span>
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :     try {
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         if (!data.exists(&quot;desc&quot;)) {</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Descriptor not found.&quot;);</span>
<span class="lineNum">    1436 </span>            :         }
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :         const std::string&amp; descriptor = data[&quot;desc&quot;].get_str();</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :         const bool active = data.exists(&quot;active&quot;) ? data[&quot;active&quot;].get_bool() : false;</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :         const bool internal = data.exists(&quot;internal&quot;) ? data[&quot;internal&quot;].get_bool() : false;</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :         const std::string&amp; label = data.exists(&quot;label&quot;) ? data[&quot;label&quot;].get_str() : &quot;&quot;;</span>
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            :         // Parse descriptor string
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :         FlatSigningProvider keys;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :         std::string error;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :         auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :         if (!parsed_desc) {</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);</span>
<span class="lineNum">    1449 </span>            :         }
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :         // Range check
<span class="lineNum">    1452 </span>            :         int64_t range_start = 0, range_end = 1, next_index = 0;
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :         if (!parsed_desc-&gt;IsRange() &amp;&amp; data.exists(&quot;range&quot;)) {</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Range should not be specified for an un-ranged descriptor&quot;);</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :         } else if (parsed_desc-&gt;IsRange()) {</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :             if (data.exists(&quot;range&quot;)) {</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                 auto range = ParseDescriptorRange(data[&quot;range&quot;]);</span>
<span class="lineNum">    1458 </span>            :                 range_start = range.first;
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                 range_end = range.second + 1; // Specified range end is inclusive, but we need range end as exclusive</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :             } else {</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :                 warnings.push_back(&quot;Range not given, using default keypool range&quot;);</span>
<span class="lineNum">    1462 </span>            :                 range_start = 0;
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                 range_end = gArgs.GetArg(&quot;-keypool&quot;, DEFAULT_KEYPOOL_SIZE);</span>
<span class="lineNum">    1464 </span>            :             }
<span class="lineNum">    1465 </span>            :             next_index = range_start;
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :             if (data.exists(&quot;next_index&quot;)) {</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :                 next_index = data[&quot;next_index&quot;].get_int64();</span>
<span class="lineNum">    1469 </span>            :                 // bound checks
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :                 if (next_index &lt; range_start || next_index &gt;= range_end) {</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :                     throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;next_index is out of range&quot;);</span>
<span class="lineNum">    1472 </span>            :                 }
<span class="lineNum">    1473 </span>            :             }
<span class="lineNum">    1474 </span>            :         }
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :         // Active descriptors must be ranged
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :         if (active &amp;&amp; !parsed_desc-&gt;IsRange()) {</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Active descriptors must be ranged&quot;);</span>
<span class="lineNum">    1479 </span>            :         }
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            :         // Ranged descriptors should not have a label
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :         if (data.exists(&quot;range&quot;) &amp;&amp; data.exists(&quot;label&quot;)) {</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Ranged descriptors should not have a label&quot;);</span>
<span class="lineNum">    1484 </span>            :         }
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span>            :         // Internal addresses should not have a label either
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :         if (internal &amp;&amp; data.exists(&quot;label&quot;)) {</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Internal addresses should not have a label&quot;);</span>
<span class="lineNum">    1489 </span>            :         }
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            :         // Combo descriptor check
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         if (active &amp;&amp; !parsed_desc-&gt;IsSingleType()) {</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Combo descriptors cannot be set to active&quot;);</span>
<span class="lineNum">    1494 </span>            :         }
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :         // If the wallet disabled private keys, abort if private keys exist
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :         if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) &amp;&amp; !keys.keys.empty()) {</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, &quot;Cannot import private keys to a wallet with private keys disabled&quot;);</span>
<span class="lineNum">    1499 </span>            :         }
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span>            :         // Need to ExpandPrivate to check if private keys are available for all pubkeys
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :         FlatSigningProvider expand_keys;</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :         std::vector&lt;CScript&gt; scripts;</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :         parsed_desc-&gt;Expand(0, keys, scripts, expand_keys);</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :         parsed_desc-&gt;ExpandPrivate(0, keys, expand_keys);</span>
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span>            :         // Check if all private keys are provided
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :         bool have_all_privkeys = !expand_keys.keys.empty();</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :         for (const auto&amp; entry : expand_keys.origins) {</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :             const CKeyID&amp; key_id = entry.first;</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :             CKey key;</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :             if (!expand_keys.GetKey(key_id, key)) {</span>
<span class="lineNum">    1513 </span>            :                 have_all_privkeys = false;
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1515 </span>            :             }
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span>            :         // If private keys are enabled, check some things.
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :         if (!pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :            if (keys.keys.empty()) {</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :                 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Cannot import descriptor without private keys to a wallet with private keys enabled&quot;);</span>
<span class="lineNum">    1522 </span>            :            }
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :            if (!have_all_privkeys) {</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :                warnings.push_back(&quot;Not all private keys provided. Some wallet functionality may return unexpected errors&quot;);</span>
<span class="lineNum">    1525 </span>            :            }
<span class="lineNum">    1526 </span>            :         }
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         WalletDescriptor w_desc(std::move(parsed_desc), timestamp, range_start, range_end, next_index);</span>
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            :         // Check if the wallet already contains the descriptor
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :         auto existing_spk_manager = pwallet-&gt;GetDescriptorScriptPubKeyMan(w_desc);</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :         if (existing_spk_manager) {</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :             LOCK(existing_spk_manager-&gt;cs_desc_man);</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :             if (range_start &gt; existing_spk_manager-&gt;GetWalletDescriptor().range_start) {</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :                 throw JSONRPCError(RPC_INVALID_PARAMS, strprintf(&quot;range_start can only decrease; current range = [%d,%d]&quot;, existing_spk_manager-&gt;GetWalletDescriptor().range_start, existing_spk_manager-&gt;GetWalletDescriptor().range_end));</span>
<span class="lineNum">    1536 </span>            :             }
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span>            :         // Add descriptor to the wallet
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :         auto spk_manager = pwallet-&gt;AddWalletDescriptor(w_desc, keys, label);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :         if (spk_manager == nullptr) {</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_WALLET_ERROR, strprintf(&quot;Could not add descriptor '%s'&quot;, descriptor));</span>
<span class="lineNum">    1543 </span>            :         }
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            :         // Set descriptor as active if necessary
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :         if (active) {</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :             if (!w_desc.descriptor-&gt;GetOutputType()) {</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :                 warnings.push_back(&quot;Unknown output type, cannot set descriptor to active.&quot;);</span>
<span class="lineNum">    1549 </span>            :             } else {
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :                 pwallet-&gt;AddActiveScriptPubKeyMan(spk_manager-&gt;GetID(), *w_desc.descriptor-&gt;GetOutputType(), internal);</span>
<span class="lineNum">    1551 </span>            :             }
<span class="lineNum">    1552 </span>            :         }
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;success&quot;, UniValue(true));</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     } catch (const UniValue&amp; e) {</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;success&quot;, UniValue(false));</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;error&quot;, e);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :     } catch (...) {</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;success&quot;, UniValue(false));</span>
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :         result.pushKV(&quot;error&quot;, JSONRPCError(RPC_MISC_ERROR, &quot;Missing required fields&quot;));</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :     if (warnings.size()) result.pushKV(&quot;warnings&quot;, warnings);</span>
<span class="lineNum">    1564 </span>            :     return result;
<a name="1565"><span class="lineNum">    1565 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 : UniValue importdescriptors(const JSONRPCRequest&amp; main_request)</span>
<span class="lineNum">    1568 </span>            : {
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :             RPCHelpMan{&quot;importdescriptors&quot;,</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                 &quot;\nImport descriptors. This will trigger a rescan of the blockchain based on the earliest timestamp of all descriptors being imported. Requires a new wallet backup.\n&quot;</span>
<span class="lineNum">    1571 </span>            :             &quot;\nNote: This call can take over an hour to complete if using an early timestamp; during that time, other rpc calls\n&quot;
<span class="lineNum">    1572 </span>            :             &quot;may report that the imported keys, addresses or scripts exist but related transactions are still missing.\n&quot;,
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :                     {&quot;requests&quot;, RPCArg::Type::ARR, RPCArg::Optional::NO, &quot;Data to be imported&quot;,</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :                         {</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :                             {&quot;&quot;, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, &quot;&quot;,</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :                                 {</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                                     {&quot;desc&quot;, RPCArg::Type::STR, RPCArg::Optional::NO, &quot;Descriptor to import.&quot;},</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :                                     {&quot;active&quot;, RPCArg::Type::BOOL, /* default */ &quot;false&quot;, &quot;Set this descriptor to be the active descriptor for the corresponding output type/externality&quot;},</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :                                     {&quot;range&quot;, RPCArg::Type::RANGE, RPCArg::Optional::OMITTED, &quot;If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import&quot;},</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :                                     {&quot;next_index&quot;, RPCArg::Type::NUM, RPCArg::Optional::OMITTED, &quot;If a ranged descriptor is set to active, this specifies the next index to generate addresses from&quot;},</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :                                     {&quot;timestamp&quot;, RPCArg::Type::NUM, RPCArg::Optional::NO, &quot;Time from which to start rescanning the blockchain for this descriptor, in &quot; + UNIX_EPOCH_TIME + &quot;\n&quot;</span>
<span class="lineNum">    1583 </span>            :         &quot;                                                              Use the string \&quot;now\&quot; to substitute the current synced blockchain time.\n&quot;
<span class="lineNum">    1584 </span>            :         &quot;                                                              \&quot;now\&quot; can be specified to bypass scanning, for outputs which are known to never have been used, and\n&quot;
<span class="lineNum">    1585 </span>            :         &quot;                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest timestamp\n&quot;
<span class="lineNum">    1586 </span>            :         &quot;                                                              of all descriptors being imported will be scanned.&quot;,
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :                                         /* oneline_description */ &quot;&quot;, {&quot;timestamp | \&quot;now\&quot;&quot;, &quot;integer / string&quot;}</span>
<span class="lineNum">    1588 </span>            :                                     },
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :                                     {&quot;internal&quot;, RPCArg::Type::BOOL, /* default */ &quot;false&quot;, &quot;Whether matching outputs should be treated as not incoming payments (e.g. change)&quot;},</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :                                     {&quot;label&quot;, RPCArg::Type::STR, /* default */ &quot;''&quot;, &quot;Label to assign to the address, only allowed with internal=false&quot;},</span>
<span class="lineNum">    1591 </span>            :                                 },
<span class="lineNum">    1592 </span>            :                             },
<span class="lineNum">    1593 </span>            :                         },
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :                         &quot;\&quot;requests\&quot;&quot;},</span>
<span class="lineNum">    1595 </span>            :                 },
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :                 RPCResult{</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                     RPCResult::Type::ARR, &quot;&quot;, &quot;Response is an array with the same size as the input that has the execution result&quot;,</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :                     {</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :                         {RPCResult::Type::OBJ, &quot;&quot;, &quot;&quot;,</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :                         {</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :                             {RPCResult::Type::BOOL, &quot;success&quot;, &quot;&quot;},</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :                             {RPCResult::Type::ARR, &quot;warnings&quot;, /* optional */ true, &quot;&quot;,</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :                             {</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :                                 {RPCResult::Type::STR, &quot;&quot;, &quot;&quot;},</span>
<span class="lineNum">    1605 </span>            :                             }},
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :                             {RPCResult::Type::OBJ, &quot;error&quot;, /* optional */ true, &quot;&quot;,</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :                             {</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :                                 {RPCResult::Type::ELISION, &quot;&quot;, &quot;JSONRPC error&quot;},</span>
<span class="lineNum">    1609 </span>            :                             }},
<span class="lineNum">    1610 </span>            :                         }},
<span class="lineNum">    1611 </span>            :                     }
<span class="lineNum">    1612 </span>            :                 },
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :                 RPCExamples{</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :                     HelpExampleCli(&quot;importdescriptors&quot;, &quot;'[{ \&quot;desc\&quot;: \&quot;&lt;my descriptor&gt;\&quot;, \&quot;timestamp\&quot;:1455191478, \&quot;internal\&quot;: true }, &quot;</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                                           &quot;{ \&quot;desc\&quot;: \&quot;&lt;my desccriptor 2&gt;\&quot;, \&quot;label\&quot;: \&quot;example 2\&quot;, \&quot;timestamp\&quot;: 1455191480 }]'&quot;) +</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :                     HelpExampleCli(&quot;importdescriptors&quot;, &quot;'[{ \&quot;desc\&quot;: \&quot;&lt;my descriptor&gt;\&quot;, \&quot;timestamp\&quot;:1455191478, \&quot;active\&quot;: true, \&quot;range\&quot;: [0,100], \&quot;label\&quot;: \&quot;&lt;my bech32 wallet&gt;\&quot; }]'&quot;)</span>
<span class="lineNum">    1617 </span>            :                 },
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :             }.Check(main_request);</span>
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :     std::shared_ptr&lt;CWallet&gt; const wallet = GetWalletForJSONRPCRequest(main_request);</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :     if (!wallet) return NullUniValue;</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     CWallet* const pwallet = wallet.get();</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            :     //  Make sure wallet is a descriptor wallet
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :     if (!pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;importdescriptors is not available for non-descriptor wallets&quot;);</span>
<span class="lineNum">    1627 </span>            :     }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     RPCTypeCheck(main_request.params, {UniValue::VARR, UniValue::VOBJ});</span>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :     WalletRescanReserver reserver(*pwallet);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :     if (!reserver.reserve()) {</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :         throw JSONRPCError(RPC_WALLET_ERROR, &quot;Wallet is currently rescanning. Abort existing rescan or wait.&quot;);</span>
<span class="lineNum">    1634 </span>            :     }
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :     const UniValue&amp; requests = main_request.params[0];</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     const int64_t minimum_timestamp = 1;</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     int64_t now = 0;</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :     int64_t lowest_timestamp = 0;</span>
<span class="lineNum">    1640 </span>            :     bool rescan = false;
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :     UniValue response(UniValue::VARR);</span>
<span class="lineNum">    1642 </span>            :     {
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :         LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :         EnsureWalletIsUnlocked(pwallet);</span>
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :         CHECK_NONFATAL(pwallet-&gt;chain().findBlock(pwallet-&gt;GetLastBlockHash(), FoundBlock().time(lowest_timestamp).mtpTime(now)));</span>
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span>            :         // Get all timestamps and extract the lowest timestamp
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         for (const UniValue&amp; request : requests.getValues()) {</span>
<span class="lineNum">    1650 </span>            :             // This throws an error if &quot;timestamp&quot; doesn't exist
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :             const int64_t timestamp = std::max(GetImportTimestamp(request, now), minimum_timestamp);</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :             const UniValue result = ProcessDescriptorImport(pwallet, request, timestamp);</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :             response.push_back(result);</span>
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :             if (lowest_timestamp &gt; timestamp ) {</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :                 lowest_timestamp = timestamp;</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :             // If we know the chain tip, and at least one request was successful then allow rescan
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :             if (!rescan &amp;&amp; result[&quot;success&quot;].get_bool()) {</span>
<span class="lineNum">    1661 </span>            :                 rescan = true;
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :         pwallet-&gt;ConnectScriptPubKeyManNotifiers();</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :     // Rescan the blockchain using the lowest timestamp
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :     if (rescan) {</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :         int64_t scanned_time = pwallet-&gt;RescanFromTime(lowest_timestamp, reserver, true /* update */);</span>
<span class="lineNum">    1670 </span>            :         {
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :             LOCK(pwallet-&gt;cs_wallet);</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :             pwallet-&gt;ReacceptWalletTransactions();</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :         if (pwallet-&gt;IsAbortingRescan()) {</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :             throw JSONRPCError(RPC_MISC_ERROR, &quot;Rescan aborted by user.&quot;);</span>
<span class="lineNum">    1677 </span>            :         }
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :         if (scanned_time &gt; lowest_timestamp) {</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :             std::vector&lt;UniValue&gt; results = response.getValues();</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :             response.clear();</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :             response.setArray();</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :             // Compose the response
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :             for (unsigned int i = 0; i &lt; requests.size(); ++i) {</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :                 const UniValue&amp; request = requests.getValues().at(i);</span>
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span>            :                 // If the descriptor timestamp is within the successfully scanned
<span class="lineNum">    1689 </span>            :                 // range, or if the import result already has an error set, let
<span class="lineNum">    1690 </span>            :                 // the result stand unmodified. Otherwise replace the result
<span class="lineNum">    1691 </span>            :                 // with an error message.
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :                 if (scanned_time &lt;= GetImportTimestamp(request, now) || results.at(i).exists(&quot;error&quot;)) {</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                     response.push_back(results.at(i));</span>
<span class="lineNum">    1694 </span>            :                 } else {
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :                     UniValue result = UniValue(UniValue::VOBJ);</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :                     result.pushKV(&quot;success&quot;, UniValue(false));</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :                     result.pushKV(</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                         &quot;error&quot;,</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :                         JSONRPCError(</span>
<span class="lineNum">    1700 </span>            :                             RPC_MISC_ERROR,
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :                             strprintf(&quot;Rescan failed for descriptor with timestamp %d. There was an error reading a &quot;</span>
<span class="lineNum">    1702 </span>            :                                       &quot;block from time %d, which is after or within %d seconds of key creation, and &quot;
<span class="lineNum">    1703 </span>            :                                       &quot;could contain transactions pertaining to the desc. As a result, transactions &quot;
<span class="lineNum">    1704 </span>            :                                       &quot;and coins using this desc may not appear in the wallet. This error could be &quot;
<span class="lineNum">    1705 </span>            :                                       &quot;caused by pruning or data corruption (see bitcoind log for details) and could &quot;
<span class="lineNum">    1706 </span>            :                                       &quot;be dealt with by downloading and rescanning the relevant blocks (see -reindex &quot;
<span class="lineNum">    1707 </span>            :                                       &quot;and -rescan options).&quot;,
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :                                 GetImportTimestamp(request, now), scanned_time - TIMESTAMP_WINDOW - 1, TIMESTAMP_WINDOW)));</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                     response.push_back(std::move(result));</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1711 </span>            :             }
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :     return response;</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
