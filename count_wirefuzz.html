
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lightningnetwork/lnd/lnwire/accept_channel.go (100.0%)</option>
				
				<option value="file1">github.com/lightningnetwork/lnd/lnwire/announcement_signatures.go (83.3%)</option>
				
				<option value="file2">github.com/lightningnetwork/lnd/lnwire/channel_announcement.go (58.8%)</option>
				
				<option value="file3">github.com/lightningnetwork/lnd/lnwire/channel_id.go (0.0%)</option>
				
				<option value="file4">github.com/lightningnetwork/lnd/lnwire/channel_idtest.go (0.0%)</option>
				
				<option value="file5">github.com/lightningnetwork/lnd/lnwire/channel_reestablish.go (88.0%)</option>
				
				<option value="file6">github.com/lightningnetwork/lnd/lnwire/channel_update.go (58.8%)</option>
				
				<option value="file7">github.com/lightningnetwork/lnd/lnwire/closing_signed.go (88.9%)</option>
				
				<option value="file8">github.com/lightningnetwork/lnd/lnwire/commit_sig.go (80.0%)</option>
				
				<option value="file9">github.com/lightningnetwork/lnd/lnwire/error.go (33.3%)</option>
				
				<option value="file10">github.com/lightningnetwork/lnd/lnwire/features.go (57.6%)</option>
				
				<option value="file11">github.com/lightningnetwork/lnd/lnwire/featurestest.go (0.0%)</option>
				
				<option value="file12">github.com/lightningnetwork/lnd/lnwire/funding_created.go (100.0%)</option>
				
				<option value="file13">github.com/lightningnetwork/lnd/lnwire/funding_locked.go (87.5%)</option>
				
				<option value="file14">github.com/lightningnetwork/lnd/lnwire/funding_signed.go (100.0%)</option>
				
				<option value="file15">github.com/lightningnetwork/lnd/lnwire/gossip_timestamp_range.go (80.0%)</option>
				
				<option value="file16">github.com/lightningnetwork/lnd/lnwire/init_message.go (80.0%)</option>
				
				<option value="file17">github.com/lightningnetwork/lnd/lnwire/lnwire.go (51.3%)</option>
				
				<option value="file18">github.com/lightningnetwork/lnd/lnwire/lnwiretest.go (0.2%)</option>
				
				<option value="file19">github.com/lightningnetwork/lnd/lnwire/message.go (59.1%)</option>
				
				<option value="file20">github.com/lightningnetwork/lnd/lnwire/msat.go (0.0%)</option>
				
				<option value="file21">github.com/lightningnetwork/lnd/lnwire/msattest.go (0.0%)</option>
				
				<option value="file22">github.com/lightningnetwork/lnd/lnwire/netaddress.go (0.0%)</option>
				
				<option value="file23">github.com/lightningnetwork/lnd/lnwire/netaddresstest.go (0.0%)</option>
				
				<option value="file24">github.com/lightningnetwork/lnd/lnwire/node_announcement.go (58.6%)</option>
				
				<option value="file25">github.com/lightningnetwork/lnd/lnwire/node_announcementtest.go (0.0%)</option>
				
				<option value="file26">github.com/lightningnetwork/lnd/lnwire/onion_error.go (4.7%)</option>
				
				<option value="file27">github.com/lightningnetwork/lnd/lnwire/onion_errortest.go (0.0%)</option>
				
				<option value="file28">github.com/lightningnetwork/lnd/lnwire/open_channel.go (100.0%)</option>
				
				<option value="file29">github.com/lightningnetwork/lnd/lnwire/ping.go (80.0%)</option>
				
				<option value="file30">github.com/lightningnetwork/lnd/lnwire/pong.go (80.0%)</option>
				
				<option value="file31">github.com/lightningnetwork/lnd/lnwire/query_channel_range.go (80.0%)</option>
				
				<option value="file32">github.com/lightningnetwork/lnd/lnwire/query_short_chan_ids.go (53.7%)</option>
				
				<option value="file33">github.com/lightningnetwork/lnd/lnwire/reply_channel_range.go (66.7%)</option>
				
				<option value="file34">github.com/lightningnetwork/lnd/lnwire/reply_short_chan_ids_end.go (80.0%)</option>
				
				<option value="file35">github.com/lightningnetwork/lnd/lnwire/revoke_and_ack.go (80.0%)</option>
				
				<option value="file36">github.com/lightningnetwork/lnd/lnwire/short_channel_id.go (66.7%)</option>
				
				<option value="file37">github.com/lightningnetwork/lnd/lnwire/short_channel_idtest.go (0.0%)</option>
				
				<option value="file38">github.com/lightningnetwork/lnd/lnwire/shutdown.go (88.9%)</option>
				
				<option value="file39">github.com/lightningnetwork/lnd/lnwire/signature.go (28.3%)</option>
				
				<option value="file40">github.com/lightningnetwork/lnd/lnwire/signaturetest.go (0.0%)</option>
				
				<option value="file41">github.com/lightningnetwork/lnd/lnwire/update_add_htlc.go (80.0%)</option>
				
				<option value="file42">github.com/lightningnetwork/lnd/lnwire/update_fail_htlc.go (100.0%)</option>
				
				<option value="file43">github.com/lightningnetwork/lnd/lnwire/update_fail_malformed_htlc.go (100.0%)</option>
				
				<option value="file44">github.com/lightningnetwork/lnd/lnwire/update_fee.go (80.0%)</option>
				
				<option value="file45">github.com/lightningnetwork/lnd/lnwire/update_fulfill_htlc.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcutil"
)

// AcceptChannel is the message Bob sends to Alice after she initiates the
// single funder channel workflow via an AcceptChannel message. Once Alice
// receives Bob's response, then she has all the items necessary to construct
// the funding transaction, and both commitment transactions.
type AcceptChannel struct {
        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // DustLimit is the specific dust limit the sender of this message
        // would like enforced on their version of the commitment transaction.
        // Any output below this value will be "trimmed" from the commitment
        // transaction, with the amount of the HTLC going to dust.
        DustLimit btcutil.Amount

        // MaxValueInFlight represents the maximum amount of coins that can be
        // pending within the channel at any given time. If the amount of funds
        // in limbo exceeds this amount, then the channel will be failed.
        MaxValueInFlight MilliSatoshi

        // ChannelReserve is the amount of BTC that the receiving party MUST
        // maintain a balance above at all times. This is a safety mechanism to
        // ensure that both sides always have skin in the game during the
        // channel's lifetime.
        ChannelReserve btcutil.Amount

        // HtlcMinimum is the smallest HTLC that the sender of this message
        // will accept.
        HtlcMinimum MilliSatoshi

        // MinAcceptDepth is the minimum depth that the initiator of the
        // channel should wait before considering the channel open.
        MinAcceptDepth uint32

        // CsvDelay is the number of blocks to use for the relative time lock
        // in the pay-to-self output of both commitment transactions.
        CsvDelay uint16

        // MaxAcceptedHTLCs is the total number of incoming HTLC's that the
        // sender of this channel will accept.
        //
        // TODO(roasbeef): acks the initiator's, same with max in flight?
        MaxAcceptedHTLCs uint16

        // FundingKey is the key that should be used on behalf of the sender
        // within the 2-of-2 multi-sig output that it contained within the
        // funding transaction.
        FundingKey *btcec.PublicKey

        // RevocationPoint is the base revocation point for the sending party.
        // Any commitment transaction belonging to the receiver of this message
        // should use this key and their per-commitment point to derive the
        // revocation key for the commitment transaction.
        RevocationPoint *btcec.PublicKey

        // PaymentPoint is the base payment point for the sending party. This
        // key should be combined with the per commitment point for a
        // particular commitment state in order to create the key that should
        // be used in any output that pays directly to the sending party, and
        // also within the HTLC covenant transactions.
        PaymentPoint *btcec.PublicKey

        // DelayedPaymentPoint is the delay point for the sending party. This
        // key should be combined with the per commitment point to derive the
        // keys that are used in outputs of the sender's commitment transaction
        // where they claim funds.
        DelayedPaymentPoint *btcec.PublicKey

        // HtlcPoint is the base point used to derive the set of keys for this
        // party that will be used within the HTLC public key scripts.  This
        // value is combined with the receiver's revocation base point in order
        // to derive the keys that are used within HTLC scripts.
        HtlcPoint *btcec.PublicKey

        // FirstCommitmentPoint is the first commitment point for the sending
        // party. This value should be combined with the receiver's revocation
        // base point in order to derive the revocation keys that are placed
        // within the commitment transaction of the sender.
        FirstCommitmentPoint *btcec.PublicKey
}

// A compile time check to ensure AcceptChannel implements the lnwire.Message
// interface.
var _ Message = (*AcceptChannel)(nil)

// Encode serializes the target AcceptChannel into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) Encode(w io.Writer, pver uint32) error <span class="cov6" title="5">{
        return WriteElements(w,
                a.PendingChannelID[:],
                a.DustLimit,
                a.MaxValueInFlight,
                a.ChannelReserve,
                a.HtlcMinimum,
                a.MinAcceptDepth,
                a.CsvDelay,
                a.MaxAcceptedHTLCs,
                a.FundingKey,
                a.RevocationPoint,
                a.PaymentPoint,
                a.DelayedPaymentPoint,
                a.HtlcPoint,
                a.FirstCommitmentPoint,
        )
}</span>

// Decode deserializes the serialized AcceptChannel stored in the passed
// io.Reader into the target AcceptChannel using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error <span class="cov10" title="12">{
        return ReadElements(r,
                a.PendingChannelID[:],
                &amp;a.DustLimit,
                &amp;a.MaxValueInFlight,
                &amp;a.ChannelReserve,
                &amp;a.HtlcMinimum,
                &amp;a.MinAcceptDepth,
                &amp;a.CsvDelay,
                &amp;a.MaxAcceptedHTLCs,
                &amp;a.FundingKey,
                &amp;a.RevocationPoint,
                &amp;a.PaymentPoint,
                &amp;a.DelayedPaymentPoint,
                &amp;a.HtlcPoint,
                &amp;a.FirstCommitmentPoint,
        )
}</span>

// MsgType returns the MessageType code which uniquely identifies this message
// as an AcceptChannel on the wire.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) MsgType() MessageType <span class="cov6" title="5">{
        return MsgAcceptChannel
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// AcceptChannel message.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) MaxPayloadLength(uint32) uint32 <span class="cov10" title="12">{
        // 32 + (8 * 4) + (4 * 1) + (2 * 2) + (33 * 6)
        return 270
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package lnwire

import (
        "io"
        "io/ioutil"
)

// AnnounceSignatures this is a direct message between two endpoints of a
// channel and serves as an opt-in mechanism to allow the announcement of
// the channel to the rest of the network. It contains the necessary
// signatures by the sender to construct the channel announcement message.
type AnnounceSignatures struct {
        // ChannelID is the unique description of the funding transaction.
        // Channel id is better for users and debugging and short channel id is
        // used for quick test on existence of the particular utxo inside the
        // block chain, because it contains information about block.
        ChannelID ChannelID

        // ShortChannelID is the unique description of the funding
        // transaction. It is constructed with the most significant 3 bytes
        // as the block height, the next 3 bytes indicating the transaction
        // index within the block, and the least significant two bytes
        // indicating the output index which pays to the channel.
        ShortChannelID ShortChannelID

        // NodeSignature is the signature which contains the signed announce
        // channel message, by this signature we proof that we possess of the
        // node pub key and creating the reference node_key -&gt; bitcoin_key.
        NodeSignature Sig

        // BitcoinSignature is the signature which contains the signed node
        // public key, by this signature we proof that we possess of the
        // bitcoin key and and creating the reverse reference bitcoin_key -&gt;
        // node_key.
        BitcoinSignature Sig

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// A compile time check to ensure AnnounceSignatures implements the
// lnwire.Message interface.
var _ Message = (*AnnounceSignatures)(nil)

// Decode deserializes a serialized AnnounceSignatures stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        err := ReadElements(r,
                &amp;a.ChannelID,
                &amp;a.ShortChannelID,
                &amp;a.NodeSignature,
                &amp;a.BitcoinSignature,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov10" title="4">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="4">if len(a.ExtraOpaqueData) == 0 </span><span class="cov5" title="2">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov10" title="4">return nil</span>
}

// Encode serializes the target AnnounceSignatures into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) Encode(w io.Writer, pver uint32) error <span class="cov5" title="2">{
        return WriteElements(w,
                a.ChannelID,
                a.ShortChannelID,
                a.NodeSignature,
                a.BitcoinSignature,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) MsgType() MessageType <span class="cov5" title="2">{
        return MsgAnnounceSignatures
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="4">{
        return 65533
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package lnwire

import (
        "bytes"
        "io"
        "io/ioutil"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ChannelAnnouncement message is used to announce the existence of a channel
// between two peers in the overlay, which is propagated by the discovery
// service over broadcast handler.
type ChannelAnnouncement struct {
        // This signatures are used by nodes in order to create cross
        // references between node's channel and node. Requiring both nodes
        // to sign indicates they are both willing to route other payments via
        // this node.
        NodeSig1 Sig
        NodeSig2 Sig

        // This signatures are used by nodes in order to create cross
        // references between node's channel and node. Requiring the bitcoin
        // signatures proves they control the channel.
        BitcoinSig1 Sig
        BitcoinSig2 Sig

        // Features is the feature vector that encodes the features supported
        // by the target node. This field can be used to signal the type of the
        // channel, or modifications to the fields that would normally follow
        // this vector.
        Features *RawFeatureVector

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        ChainHash chainhash.Hash

        // ShortChannelID is the unique description of the funding transaction,
        // or where exactly it's located within the target blockchain.
        ShortChannelID ShortChannelID

        // The public keys of the two nodes who are operating the channel, such
        // that is NodeID1 the numerically-lesser than NodeID2 (ascending
        // numerical order).
        NodeID1 [33]byte
        NodeID2 [33]byte

        // Public keys which corresponds to the keys which was declared in
        // multisig funding transaction output.
        BitcoinKey1 [33]byte
        BitcoinKey2 [33]byte

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// A compile time check to ensure ChannelAnnouncement implements the
// lnwire.Message interface.
var _ Message = (*ChannelAnnouncement)(nil)

// Decode deserializes a serialized ChannelAnnouncement stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) Decode(r io.Reader, pver uint32) error <span class="cov10" title="6">{
        err := ReadElements(r,
                &amp;a.NodeSig1,
                &amp;a.NodeSig2,
                &amp;a.BitcoinSig1,
                &amp;a.BitcoinSig2,
                &amp;a.Features,
                a.ChainHash[:],
                &amp;a.ShortChannelID,
                &amp;a.NodeID1,
                &amp;a.NodeID2,
                &amp;a.BitcoinKey1,
                &amp;a.BitcoinKey2,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov10" title="6">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="6">if len(a.ExtraOpaqueData) == 0 </span><span class="cov4" title="2">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov10" title="6">return nil</span>
}

// Encode serializes the target ChannelAnnouncement into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) Encode(w io.Writer, pver uint32) error <span class="cov6" title="3">{
        return WriteElements(w,
                a.NodeSig1,
                a.NodeSig2,
                a.BitcoinSig1,
                a.BitcoinSig2,
                a.Features,
                a.ChainHash[:],
                a.ShortChannelID,
                a.NodeID1,
                a.NodeID2,
                a.BitcoinKey1,
                a.BitcoinKey2,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) MsgType() MessageType <span class="cov6" title="3">{
        return MsgChannelAnnouncement
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="6">{
        return 65533
}</span>

// DataToSign is used to retrieve part of the announcement message which should
// be signed.
func (a *ChannelAnnouncement) DataToSign() ([]byte, error) <span class="cov0" title="0">{
        // We should not include the signatures itself.
        var w bytes.Buffer
        err := WriteElements(&amp;w,
                a.Features,
                a.ChainHash[:],
                a.ShortChannelID,
                a.NodeID1,
                a.NodeID2,
                a.BitcoinKey1,
                a.BitcoinKey2,
                a.ExtraOpaqueData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package lnwire

import (
        "encoding/binary"
        "encoding/hex"
        "math"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
)

const (
        // MaxFundingTxOutputs is the maximum number of allowed outputs on a
        // funding transaction within the protocol. This is due to the fact
        // that we use 2-bytes to encode the index within the funding output
        // during the funding workflow. Funding transaction with more outputs
        // than this are considered invalid within the protocol.
        MaxFundingTxOutputs = math.MaxUint16
)

// ChannelID is a series of 32-bytes that uniquely identifies all channels
// within the network. The ChannelID is computed using the outpoint of the
// funding transaction (the txid, and output index). Given a funding output the
// ChannelID can be calculated by XOR'ing the big-endian serialization of the
// txid and the big-endian serialization of the output index, truncated to
// 2 bytes.
type ChannelID [32]byte

// ConnectionWideID is an all-zero ChannelID, which is used to represent a
// message intended for all channels to specific peer.
var ConnectionWideID = ChannelID{}

// String returns the string representation of the ChannelID. This is just the
// hex string encoding of the ChannelID itself.
func (c ChannelID) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(c[:])
}</span>

// NewChanIDFromOutPoint converts a target OutPoint into a ChannelID that is
// usable within the network. In order to convert the OutPoint into a ChannelID,
// we XOR the lower 2-bytes of the txid within the OutPoint with the big-endian
// serialization of the Index of the OutPoint, truncated to 2-bytes.
func NewChanIDFromOutPoint(op *wire.OutPoint) ChannelID <span class="cov0" title="0">{
        // First we'll copy the txid of the outpoint into our channel ID slice.
        var cid ChannelID
        copy(cid[:], op.Hash[:])

        // With the txid copied over, we'll now XOR the lower 2-bytes of the
        // partial channelID with big-endian serialization of output index.
        xorTxid(&amp;cid, uint16(op.Index))

        return cid
}</span>

// xorTxid performs the transformation needed to transform an OutPoint into a
// ChannelID. To do this, we expect the cid parameter to contain the txid
// unaltered and the outputIndex to be the output index
func xorTxid(cid *ChannelID, outputIndex uint16) <span class="cov0" title="0">{
        var buf [32]byte
        binary.BigEndian.PutUint16(buf[30:], outputIndex)

        cid[30] = cid[30] ^ buf[30]
        cid[31] = cid[31] ^ buf[31]
}</span>

// GenPossibleOutPoints generates all the possible outputs given a channel ID.
// In order to generate these possible outpoints, we perform a brute-force
// search through the candidate output index space, performing a reverse
// mapping from channelID back to OutPoint.
func (c *ChannelID) GenPossibleOutPoints() [MaxFundingTxOutputs]wire.OutPoint <span class="cov0" title="0">{
        var possiblePoints [MaxFundingTxOutputs]wire.OutPoint
        for i := uint32(0); i &lt; MaxFundingTxOutputs; i++ </span><span class="cov0" title="0">{
                cidCopy := *c
                xorTxid(&amp;cidCopy, uint16(i))

                possiblePoints[i] = wire.OutPoint{
                        Hash:  chainhash.Hash(cidCopy),
                        Index: i,
                }
        }</span>

        <span class="cov0" title="0">return possiblePoints</span>
}

// IsChanPoint returns true if the OutPoint passed corresponds to the target
// ChannelID.
func (c ChannelID) IsChanPoint(op *wire.OutPoint) bool <span class="cov0" title="0">{
        candidateCid := NewChanIDFromOutPoint(op)

        return candidateCid == c
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package lnwire

import "testing"

// TestChannelIDOutPointConversion ensures that the IsChanPoint always
// recognizes its seed OutPoint for all possible values of an output index.
func TestChannelIDOutPointConversion(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        testChanPoint := *outpoint1

        // For a given OutPoint, we'll run through all the possible output
        // index values, mutating our test outpoint to match that output index.
        var prevChanID ChannelID
        for i := uint32(0); i &lt; MaxFundingTxOutputs; i++ </span><span class="cov0" title="0">{
                testChanPoint.Index = i

                // With the output index mutated, we'll convert it into a
                // ChannelID.
                cid := NewChanIDFromOutPoint(&amp;testChanPoint)

                // Once the channel point has been converted to a channelID, it
                // should recognize its original outpoint.
                if !cid.IsChanPoint(&amp;testChanPoint) </span><span class="cov0" title="0">{
                        t.Fatalf("channelID not recognized as seed channel "+
                                "point: cid=%v, op=%v", cid, testChanPoint)
                }</span>

                // We also ensure that the channel ID itself have changed
                // between iterations. This case is meant to catch an issue
                // where the transformation function itself is a no-op.
                <span class="cov0" title="0">if prevChanID == cid </span><span class="cov0" title="0">{
                        t.Fatalf("#%v: channelID not modified: old=%v, new=%v",
                                i, prevChanID, cid)
                }</span>

                <span class="cov0" title="0">prevChanID = cid</span>
        }
}

// TestGenPossibleOutPoints ensures that the GenPossibleOutPoints generates a
// valid set of outpoints for a channelID. A set of outpoints is valid iff, the
// root outpoint (the outpoint that generated the ChannelID) is included in the
// returned set of outpoints.
func TestGenPossibleOutPoints(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        // We'll first convert out test outpoint into a ChannelID.
        testChanPoint := *outpoint1
        testChanPoint.Index = 24
        chanID := NewChanIDFromOutPoint(&amp;testChanPoint)

        // With the chan ID created, we'll generate all possible root outpoints
        // given this channel ID.
        possibleOutPoints := chanID.GenPossibleOutPoints()

        // If we run through the generated possible outpoints, the original
        // root outpoint MUST be found in this generated set.
        var opFound bool
        for _, op := range possibleOutPoints </span><span class="cov0" title="0">{
                if op == testChanPoint </span><span class="cov0" title="0">{
                        opFound = true
                        break</span>
                }
        }

        // If we weren't able to locate the original outpoint in the set of
        // possible outpoints, then we'll fail the test.
        <span class="cov0" title="0">if !opFound </span><span class="cov0" title="0">{
                t.Fatalf("possible outpoints did not contain the root outpoint")
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
)

// ChannelReestablish is a message sent between peers that have an existing
// open channel upon connection reestablishment. This message allows both sides
// to report their local state, and their current knowledge of the state of the
// remote commitment chain. If a deviation is detected and can be recovered
// from, then the necessary messages will be retransmitted. If the level of
// desynchronization if irreconcilable, then the channel will be force closed.
type ChannelReestablish struct {
        // ChanID is the channel ID of the channel state we're attempting
        // synchronize with the remote party.
        ChanID ChannelID

        // NextLocalCommitHeight is the next local commitment height of the
        // sending party. If the height of the sender's commitment chain from
        // the receiver's Pov is one less that this number, then the sender
        // should re-send the *exact* same proposed commitment.
        //
        // In other words, the receiver should re-send their last sent
        // commitment iff:
        //
        //  * NextLocalCommitHeight == remoteCommitChain.Height
        //
        // This covers the case of a lost commitment which was sent by the
        // sender of this message, but never received by the receiver of this
        // message.
        NextLocalCommitHeight uint64

        // RemoteCommitTailHeight is the height of the receiving party's
        // unrevoked commitment from the PoV of the sender of this message. If
        // the height of the receiver's commitment is *one more* than this
        // value, then their prior RevokeAndAck message should be
        // retransmitted.
        //
        // In other words, the receiver should re-send their last sent
        // RevokeAndAck message iff:
        //
        //  * localCommitChain.tail().Height == RemoteCommitTailHeight + 1
        //
        // This covers the case of a lost revocation, wherein the receiver of
        // the message sent a revocation for a prior state, but the sender of
        // the message never fully processed it.
        RemoteCommitTailHeight uint64

        // LastRemoteCommitSecret is the last commitment secret that the
        // receiving node has sent to the sending party. This will be the
        // secret of the last revoked commitment transaction. Including this
        // provides proof that the sending node at least knows of this state,
        // as they couldn't have produced it if it wasn't sent, as the value
        // can be authenticated by querying the shachain or the receiving
        // party.
        LastRemoteCommitSecret [32]byte

        // LocalUnrevokedCommitPoint is the commitment point used in the
        // current un-revoked commitment transaction of the sending party.
        LocalUnrevokedCommitPoint *btcec.PublicKey
}

// A compile time check to ensure ChannelReestablish implements the
// lnwire.Message interface.
var _ Message = (*ChannelReestablish)(nil)

// Encode serializes the target ChannelReestablish into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) Encode(w io.Writer, pver uint32) error <span class="cov5" title="2">{
        err := WriteElements(w,
                a.ChanID,
                a.NextLocalCommitHeight,
                a.RemoteCommitTailHeight,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the commit point wasn't sent, then we won't write out any of the
        // remaining fields as they're optional.
        <span class="cov5" title="2">if a.LocalUnrevokedCommitPoint == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Otherwise, we'll write out the remaining elements.
        <span class="cov1" title="1">return WriteElements(w, a.LastRemoteCommitSecret[:],
                a.LocalUnrevokedCommitPoint)</span>
}

// Decode deserializes a serialized ChannelReestablish stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        err := ReadElements(r,
                &amp;a.ChanID,
                &amp;a.NextLocalCommitHeight,
                &amp;a.RemoteCommitTailHeight,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This message has to currently defined optional fields. As a result,
        // we'll only proceed if there's still bytes remaining within the
        // reader.
        //
        // We'll manually parse out the optional fields in order to be able to
        // still utilize the io.Reader interface.

        // We'll first attempt to read the optional commit secret, if we're at
        // the EOF, then this means the field wasn't included so we can exit
        // early.
        <span class="cov10" title="4">var buf [32]byte
        _, err = io.ReadFull(r, buf[:32])
        if err == io.EOF </span><span class="cov5" title="2">{
                return nil
        }</span> else<span class="cov5" title="2"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the field is present, then we'll copy it over and proceed.
        <span class="cov5" title="2">copy(a.LastRemoteCommitSecret[:], buf[:])

        // We'll conclude by parsing out the commitment point. We don't check
        // the error in this case, as it hey included the commit secret, then
        // they MUST also include the commit point.
        return ReadElement(r, &amp;a.LocalUnrevokedCommitPoint)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) MsgType() MessageType <span class="cov5" title="2">{
        return MsgChannelReestablish
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="4">{
        var length uint32

        // ChanID - 32 bytes
        length += 32

        // NextLocalCommitHeight - 8 bytes
        length += 8

        // RemoteCommitTailHeight - 8 bytes
        length += 8

        // LastRemoteCommitSecret - 32 bytes
        length += 32

        // LocalUnrevokedCommitPoint - 33 bytes
        length += 33

        return length
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package lnwire

import (
        "bytes"
        "io"
        "io/ioutil"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ChanUpdateFlag is a bitfield that signals various options concerning a
// particular channel edge. Each bit is to be examined in order to determine
// how the ChannelUpdate message is to be interpreted.
type ChanUpdateFlag uint16

const (
        // ChanUpdateDirection indicates the direction of a channel update. If
        // this bit is set to 0 if Node1 (the node with the "smaller" Node ID)
        // is updating the channel, and to 1 otherwise.
        ChanUpdateDirection ChanUpdateFlag = 1 &lt;&lt; iota

        // ChanUpdateDisabled is a bit that indicates if the channel edge
        // selected by the ChanUpdateDirection bit is to be treated as being
        // disabled.
        ChanUpdateDisabled
)

// ChannelUpdate message is used after channel has been initially announced.
// Each side independently announces its fees and minimum expiry for HTLCs and
// other parameters. Also this message is used to redeclare initially set
// channel parameters.
type ChannelUpdate struct {
        // Signature is used to validate the announced data and prove the
        // ownership of node id.
        Signature Sig

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        // Along with the short channel ID, this uniquely identifies the
        // channel globally in a blockchain.
        ChainHash chainhash.Hash

        // ShortChannelID is the unique description of the funding transaction.
        ShortChannelID ShortChannelID

        // Timestamp allows ordering in the case of multiple announcements.  We
        // should ignore the message if timestamp is not greater than
        // the last-received.
        Timestamp uint32

        // Flags is a bitfield that describes additional meta-data concerning
        // how the update is to be interpreted. Currently, the
        // least-significant bit must be set to 0 if the creating node
        // corresponds to the first node in the previously sent channel
        // announcement and 1 otherwise. If the second bit is set, then the
        // channel is set to be disabled.
        Flags ChanUpdateFlag

        // TimeLockDelta is the minimum number of blocks this node requires to
        // be added to the expiry of HTLCs. This is a security parameter
        // determined by the node operator. This value represents the required
        // gap between the time locks of the incoming and outgoing HTLC's set
        // to this node.
        TimeLockDelta uint16

        // HtlcMinimumMsat is the minimum HTLC value which will be accepted.
        HtlcMinimumMsat MilliSatoshi

        // BaseFee is the base fee that must be used for incoming HTLC's to
        // this particular channel. This value will be tacked onto the required
        // for a payment independent of the size of the payment.
        BaseFee uint32

        // FeeRate is the fee rate that will be charged per millionth of a
        // satoshi.
        FeeRate uint32

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// A compile time check to ensure ChannelUpdate implements the lnwire.Message
// interface.
var _ Message = (*ChannelUpdate)(nil)

// Decode deserializes a serialized ChannelUpdate stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        err := ReadElements(r,
                &amp;a.Signature,
                a.ChainHash[:],
                &amp;a.ShortChannelID,
                &amp;a.Timestamp,
                &amp;a.Flags,
                &amp;a.TimeLockDelta,
                &amp;a.HtlcMinimumMsat,
                &amp;a.BaseFee,
                &amp;a.FeeRate,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov10" title="4">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="4">if len(a.ExtraOpaqueData) == 0 </span><span class="cov5" title="2">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov10" title="4">return nil</span>
}

// Encode serializes the target ChannelUpdate into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) Encode(w io.Writer, pver uint32) error <span class="cov5" title="2">{
        return WriteElements(w,
                a.Signature,
                a.ChainHash[:],
                a.ShortChannelID,
                a.Timestamp,
                a.Flags,
                a.TimeLockDelta,
                a.HtlcMinimumMsat,
                a.BaseFee,
                a.FeeRate,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) MsgType() MessageType <span class="cov5" title="2">{
        return MsgChannelUpdate
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="4">{
        return 65533
}</span>

// DataToSign is used to retrieve part of the announcement message which should
// be signed.
func (a *ChannelUpdate) DataToSign() ([]byte, error) <span class="cov0" title="0">{

        // We should not include the signatures itself.
        var w bytes.Buffer
        err := WriteElements(&amp;w,
                a.ChainHash[:],
                a.ShortChannelID,
                a.Timestamp,
                a.Flags,
                a.TimeLockDelta,
                a.HtlcMinimumMsat,
                a.BaseFee,
                a.FeeRate,
                a.ExtraOpaqueData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcutil"
)

// ClosingSigned is sent by both parties to a channel once the channel is clear
// of HTLCs, and is primarily concerned with negotiating fees for the close
// transaction. Each party provides a signature for a transaction with a fee
// that they believe is fair. The process terminates when both sides agree on
// the same fee, or when one side force closes the channel.
//
// NOTE: The responder is able to send a signature without any additional
// messages as all transactions are assembled observing BIP 69 which defines a
// canonical ordering for input/outputs. Therefore, both sides are able to
// arrive at an identical closure transaction as they know the order of the
// inputs/outputs.
type ClosingSigned struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // FeeSatoshis is the total fee in satoshis that the party to the
        // channel would like to propose for the close transaction.
        FeeSatoshis btcutil.Amount

        // Signature is for the proposed channel close transaction.
        Signature Sig
}

// NewClosingSigned creates a new empty ClosingSigned message.
func NewClosingSigned(cid ChannelID, fs btcutil.Amount,
        sig Sig) *ClosingSigned <span class="cov0" title="0">{

        return &amp;ClosingSigned{
                ChannelID:   cid,
                FeeSatoshis: fs,
                Signature:   sig,
        }
}</span>

// A compile time check to ensure ClosingSigned implements the lnwire.Message
// interface.
var _ Message = (*ClosingSigned)(nil)

// Decode deserializes a serialized ClosingSigned message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r, &amp;c.ChannelID, &amp;c.FeeSatoshis, &amp;c.Signature)
}</span>

// Encode serializes the target ClosingSigned into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, c.ChannelID, c.FeeSatoshis, c.Signature)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) MsgType() MessageType <span class="cov1" title="1">{
        return MsgClosingSigned
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// ClosingSigned complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        var length uint32

        // ChannelID - 32 bytes
        length += 32

        // FeeSatoshis - 8 bytes
        length += 8

        // Signature - 64 bytes
        length += 64

        return length
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package lnwire

import "io"

// CommitSig is sent by either side to stage any pending HTLC's in the
// receiver's pending set into a new commitment state.  Implicitly, the new
// commitment transaction constructed which has been signed by CommitSig
// includes all HTLC's in the remote node's pending set. A CommitSig message
// may be sent after a series of UpdateAddHTLC/UpdateFulfillHTLC messages in
// order to batch add several HTLC's with a single signature covering all
// implicitly accepted HTLC's.
type CommitSig struct {
        // ChanID uniquely identifies to which currently active channel this
        // CommitSig applies to.
        ChanID ChannelID

        // CommitSig is Alice's signature for Bob's new commitment transaction.
        // Alice is able to send this signature without requesting any
        // additional data due to the piggybacking of Bob's next revocation
        // hash in his prior RevokeAndAck message, as well as the canonical
        // ordering used for all inputs/outputs within commitment transactions.
        // If initiating a new commitment state, this signature should ONLY
        // cover all of the sending party's pending log updates, and the log
        // updates of the remote party that have been ACK'd.
        CommitSig Sig

        // HtlcSigs is a signature for each relevant HTLC output within the
        // created commitment. The order of the signatures is expected to be
        // identical to the placement of the HTLC's within the BIP 69 sorted
        // commitment transaction. For each outgoing HTLC (from the PoV of the
        // sender of this message), a signature for an HTLC timeout transaction
        // should be signed, for each incoming HTLC the HTLC timeout
        // transaction should be signed.
        HtlcSigs []Sig
}

// NewCommitSig creates a new empty CommitSig message.
func NewCommitSig() *CommitSig <span class="cov0" title="0">{
        return &amp;CommitSig{}
}</span>

// A compile time check to ensure CommitSig implements the lnwire.Message
// interface.
var _ Message = (*CommitSig)(nil)

// Decode deserializes a serialized CommitSig message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.CommitSig,
                &amp;c.HtlcSigs,
        )
}</span>

// Encode serializes the target CommitSig into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) Encode(w io.Writer, pver uint32) error <span class="cov5" title="2">{
        return WriteElements(w,
                c.ChanID,
                c.CommitSig,
                c.HtlcSigs,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) MsgType() MessageType <span class="cov5" title="2">{
        return MsgCommitSig
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// CommitSig complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) MaxPayloadLength(uint32) uint32 <span class="cov10" title="4">{
        // 32 + 64 + 2 + max_allowed_htlcs
        return MaxMessagePayload
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package lnwire

import (
        "io"

        "google.golang.org/grpc/codes"
)

// ErrorCode represents the short error code for each of the defined errors
// within the Lightning Network protocol spec.
type ErrorCode uint8

// ToGrpcCode is used to generate gRPC specific code which will be propagated
// to the ln rpc client. This code is used to have more detailed view of what
// goes wrong and also in order to have the ability pragmatically determine the
// error and take specific actions on the client side.
func (e ErrorCode) ToGrpcCode() codes.Code <span class="cov0" title="0">{
        return (codes.Code)(e) + 100
}</span>

const (
        // ErrMaxPendingChannels is returned by remote peer when the number of
        // active pending channels exceeds their maximum policy limit.
        ErrMaxPendingChannels ErrorCode = 1

        // ErrSynchronizingChain is returned by a remote peer that receives a
        // channel update or a funding request while their still syncing to the
        // latest state of the blockchain.
        ErrSynchronizingChain ErrorCode = 2

        // ErrChanTooLarge is returned by a remote peer that receives a
        // FundingOpen request for a channel that is above their current
        // soft-limit.
        ErrChanTooLarge ErrorCode = 3
)

// String returns a human readable version of the target ErrorCode.
func (e ErrorCode) String() string <span class="cov0" title="0">{
        switch e </span>{
        case ErrMaxPendingChannels:<span class="cov0" title="0">
                return "Number of pending channels exceed maximum"</span>
        case ErrSynchronizingChain:<span class="cov0" title="0">
                return "Synchronizing blockchain"</span>
        case ErrChanTooLarge:<span class="cov0" title="0">
                return "channel too large"</span>
        default:<span class="cov0" title="0">
                return "unknown error"</span>
        }
}

// Error returns the human redable version of the target ErrorCode.
//
// Satisfies the Error interface.
func (e ErrorCode) Error() string <span class="cov0" title="0">{
        return e.String()
}</span>

// ErrorData is a set of bytes associated with a particular sent error. A
// receiving node SHOULD only print out data verbatim if the string is composed
// solely of printable ASCII characters. For reference, the printable character
// set includes byte values 32 through 127 inclusive.
type ErrorData []byte

// Error represents a generic error bound to an exact channel. The message
// format is purposefully general in order to allow expression of a wide array
// of possible errors. Each Error message is directed at a particular open
// channel referenced by ChannelPoint.
//
// TODO(roasbeef): remove the error code
type Error struct {
        // ChanID references the active channel in which the error occurred
        // within. If the ChanID is all zeros, then this error applies to the
        // entire established connection.
        ChanID ChannelID

        // Data is the attached error data that describes the exact failure
        // which caused the error message to be sent.
        Data ErrorData
}

// NewError creates a new Error message.
func NewError() *Error <span class="cov0" title="0">{
        return &amp;Error{}
}</span>

// A compile time check to ensure Error implements the lnwire.Message
// interface.
var _ Message = (*Error)(nil)

// Decode deserializes a serialized Error message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *Error) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.Data,
        )
}</span>

// Encode serializes the target Error into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *Error) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.Data,
        )
}</span>

// MsgType returns the integer uniquely identifying an Error message on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *Error) MsgType() MessageType <span class="cov1" title="1">{
        return MsgError
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an Error
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *Error) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 2 + 655326
        return 65536
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package lnwire

import (
        "encoding/binary"
        "fmt"
        "io"
)

// FeatureBit represents a feature that can be enabled in either a local or
// global feature vector at a specific bit position. Feature bits follow the
// "it's OK to be odd" rule, where features at even bit positions must be known
// to a node receiving them from a peer while odd bits do not. In accordance,
// feature bits are usually assigned in pairs, first being assigned an odd bit
// position which may later be changed to the preceding even position once
// knowledge of the feature becomes required on the network.
type FeatureBit uint16

const (
        // DataLossProtectRequired is a feature bit that indicates that a peer
        // *requires* the other party know about the data-loss-protect optional
        // feature. If the remote peer does not know of such a feature, then
        // the sending peer SHOLUD disconnect them. The data-loss-protect
        // feature allows a peer that's lost partial data to recover their
        // settled funds of the latest commitment state.
        DataLossProtectRequired FeatureBit = 0

        // DataLossProtectOptional is an optional feature bit that indicates
        // that the sending peer knows of this new feature and can activate it
        // it. The data-loss-protect feature allows a peer that's lost partial
        // data to recover their settled funds of the latest commitment state.
        DataLossProtectOptional FeatureBit = 1

        // InitialRoutingSync is a local feature bit meaning that the receiving
        // node should send a complete dump of routing information when a new
        // connection is established.
        InitialRoutingSync FeatureBit = 3

        // GossipQueriesRequired is a feature bit that indicates that the
        // receiving peer MUST know of the set of features that allows nodes to
        // more efficiently query the network view of peers on the network for
        // reconciliation purposes.
        GossipQueriesRequired FeatureBit = 6

        // GossipQueriesOptional is an optional feature bit that signals that
        // the setting peer knows of the set of features that allows more
        // efficient network view reconciliation.
        GossipQueriesOptional FeatureBit = 7

        // maxAllowedSize is a maximum allowed size of feature vector.
        //
        // NOTE: Within the protocol, the maximum allowed message size is 65535
        // bytes. Adding the overhead from the crypto protocol (the 2-byte
        // packet length and 16-byte MAC), we arrive at 65569 bytes. Accounting
        // for the overhead within the feature message to signal the type of
        // the message, that leaves 65567 bytes for the init message itself.
        // Next, we reserve 4-bytes to encode the lengths of both the local and
        // global feature vectors, so 65563 for the global and local features.
        // Knocking off one byte for the sake of the calculation, that leads to
        // a max allowed size of 32781 bytes for each feature vector, or 131124
        // different features.
        maxAllowedSize = 32781
)

// LocalFeatures is a mapping of known connection-local feature bits to a
// descriptive name. All known local feature bits must be assigned a name in
// this mapping. Local features are those which are only sent to the peer and
// not advertised to the entire network. A full description of these feature
// bits is provided in the BOLT-09 specification.
var LocalFeatures = map[FeatureBit]string{
        DataLossProtectRequired: "data-loss-protect-required",
        DataLossProtectOptional: "data-loss-protect-optional",
        InitialRoutingSync:      "initial-routing-sync",
        GossipQueriesRequired:   "gossip-queries-required",
        GossipQueriesOptional:   "gossip-queries-optional",
}

// GlobalFeatures is a mapping of known global feature bits to a descriptive
// name. All known global feature bits must be assigned a name in this mapping.
// Global features are those which are advertised to the entire network. A full
// description of these feature bits is provided in the BOLT-09 specification.
var GlobalFeatures map[FeatureBit]string

// RawFeatureVector represents a set of feature bits as defined in BOLT-09.  A
// RawFeatureVector itself just stores a set of bit flags but can be used to
// construct a FeatureVector which binds meaning to each bit. Feature vectors
// can be serialized and deserialized to/from a byte representation that is
// transmitted in Lightning network messages.
type RawFeatureVector struct {
        features map[FeatureBit]bool
}

// NewRawFeatureVector creates a feature vector with all of the feature bits
// given as arguments enabled.
func NewRawFeatureVector(bits ...FeatureBit) *RawFeatureVector <span class="cov3" title="37">{
        fv := &amp;RawFeatureVector{features: make(map[FeatureBit]bool)}
        for _, bit := range bits </span><span class="cov0" title="0">{
                fv.Set(bit)
        }</span>
        <span class="cov3" title="37">return fv</span>
}

// IsSet returns whether a particular feature bit is enabled in the vector.
func (fv *RawFeatureVector) IsSet(feature FeatureBit) bool <span class="cov0" title="0">{
        return fv.features[feature]
}</span>

// Set marks a feature as enabled in the vector.
func (fv *RawFeatureVector) Set(feature FeatureBit) <span class="cov9" title="92128">{
        fv.features[feature] = true
}</span>

// Unset marks a feature as disabled in the vector.
func (fv *RawFeatureVector) Unset(feature FeatureBit) <span class="cov0" title="0">{
        delete(fv.features, feature)
}</span>

// SerializeSize returns the number of bytes needed to represent feature vector
// in byte format.
func (fv *RawFeatureVector) SerializeSize() int <span class="cov2" title="12">{
        // Find the largest feature bit index
        max := -1
        for feature := range fv.features </span><span class="cov8" title="30330">{
                index := int(feature)
                if index &gt; max </span><span class="cov4" title="112">{
                        max = index
                }</span>
        }
        <span class="cov2" title="12">if max == -1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // We calculate byte-length via the largest bit index
        <span class="cov2" title="12">return max/8 + 1</span>
}

// Encode writes the feature vector in byte representation. Every feature
// encoded as a bit, and the bit vector is serialized using the least number of
// bytes. Since the bit vector length is variable, the first two bytes of the
// serialization represent the length.
func (fv *RawFeatureVector) Encode(w io.Writer) error <span class="cov2" title="12">{
        // Write length of feature vector.
        var l [2]byte
        length := fv.SerializeSize()
        binary.BigEndian.PutUint16(l[:], uint16(length))
        if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate the data and write it.
        <span class="cov2" title="12">data := make([]byte, length)
        for feature := range fv.features </span><span class="cov8" title="30330">{
                byteIndex := int(feature / 8)
                bitIndex := feature % 8
                data[length-byteIndex-1] |= 1 &lt;&lt; bitIndex
        }</span>

        <span class="cov2" title="12">_, err := w.Write(data)
        return err</span>
}

// Decode reads the feature vector from its byte representation. Every feature
// encoded as a bit, and the bit vector is serialized using the least number of
// bytes. Since the bit vector length is variable, the first two bytes of the
// serialization represent the length.
func (fv *RawFeatureVector) Decode(r io.Reader) error <span class="cov3" title="37">{
        // Read the length of the feature vector.
        var l [2]byte
        if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="37">length := binary.BigEndian.Uint16(l[:])

        // Read the feature vector data.
        data := make([]byte, length)
        if _, err := io.ReadFull(r, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set feature bits from parsed data.
        <span class="cov3" title="37">bitsNumber := len(data) * 8
        for i := 0; i &lt; bitsNumber; i++ </span><span class="cov10" title="187560">{
                byteIndex := uint16(i / 8)
                bitIndex := uint(i % 8)
                if (data[length-byteIndex-1]&gt;&gt;bitIndex)&amp;1 == 1 </span><span class="cov9" title="92128">{
                        fv.Set(FeatureBit(i))
                }</span>
        }

        <span class="cov3" title="37">return nil</span>
}

// FeatureVector represents a set of enabled features. The set stores
// information on enabled flags and metadata about the feature names. A feature
// vector is serializable to a compact byte representation that is included in
// Lightning network messages.
type FeatureVector struct {
        *RawFeatureVector
        featureNames map[FeatureBit]string
}

// NewFeatureVector constructs a new FeatureVector from a raw feature vector
// and mapping of feature definitions. If the feature vector argument is nil, a
// new one will be constructed with no enabled features.
func NewFeatureVector(featureVector *RawFeatureVector,
        featureNames map[FeatureBit]string) *FeatureVector <span class="cov0" title="0">{

        if featureVector == nil </span><span class="cov0" title="0">{
                featureVector = NewRawFeatureVector()
        }</span>
        <span class="cov0" title="0">return &amp;FeatureVector{
                RawFeatureVector: featureVector,
                featureNames:     featureNames,
        }</span>
}

// HasFeature returns whether a particular feature is included in the set. The
// feature can be seen as set either if the bit is set directly OR the queried
// bit has the same meaning as its corresponding even/odd bit, which is set
// instead. The second case is because feature bits are generally assigned in
// pairs where both the even and odd position represent the same feature.
func (fv *FeatureVector) HasFeature(feature FeatureBit) bool <span class="cov0" title="0">{
        return fv.IsSet(feature) ||
                (fv.isFeatureBitPair(feature) &amp;&amp; fv.IsSet(feature^1))
}</span>

// UnknownRequiredFeatures returns a list of feature bits set in the vector
// that are unknown and in an even bit position. Feature bits with an even
// index must be known to a node receiving the feature vector in a message.
func (fv *FeatureVector) UnknownRequiredFeatures() []FeatureBit <span class="cov0" title="0">{
        var unknown []FeatureBit
        for feature := range fv.features </span><span class="cov0" title="0">{
                if feature%2 == 0 &amp;&amp; !fv.IsKnown(feature) </span><span class="cov0" title="0">{
                        unknown = append(unknown, feature)
                }</span>
        }
        <span class="cov0" title="0">return unknown</span>
}

// Name returns a string identifier for the feature represented by this bit. If
// the bit does not represent a known feature, this returns a string indicating
// as much.
func (fv *FeatureVector) Name(bit FeatureBit) string <span class="cov0" title="0">{
        name, known := fv.featureNames[bit]
        if !known </span><span class="cov0" title="0">{
                name = "unknown"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s(%d)", name, bit)</span>
}

// IsKnown returns whether this feature bit represents a known feature.
func (fv *FeatureVector) IsKnown(bit FeatureBit) bool <span class="cov0" title="0">{
        _, known := fv.featureNames[bit]
        return known
}</span>

// isFeatureBitPair returns whether this feature bit and its corresponding
// even/odd bit both represent the same feature. This may often be the case as
// bits are generally assigned in pairs, first being assigned an odd bit
// position then being promoted to an even bit position once the network is
// ready.
func (fv *FeatureVector) isFeatureBitPair(bit FeatureBit) bool <span class="cov0" title="0">{
        name1, known1 := fv.featureNames[bit]
        name2, known2 := fv.featureNames[bit^1]
        return known1 &amp;&amp; known2 &amp;&amp; name1 == name2
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package lnwire

import (
        "bytes"
        "reflect"
        "sort"
        "testing"
)

var testFeatureNames = map[FeatureBit]string{
        0: "feature1",
        3: "feature2",
        4: "feature3",
        5: "feature3",
}

func TestFeatureVectorSetUnset(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        tests := []struct {
                bits             []FeatureBit
                expectedFeatures []bool
        }{
                // No features are enabled if no bits are set.
                {
                        bits:             nil,
                        expectedFeatures: []bool{false, false, false, false, false, false, false, false},
                },
                // Test setting an even bit for an even-only bit feature. The
                // corresponding odd bit should not be seen as set.
                {
                        bits:             []FeatureBit{0},
                        expectedFeatures: []bool{true, false, false, false, false, false, false, false},
                },
                // Test setting an odd bit for an even-only bit feature. The
                // corresponding even bit should not be seen as set.
                {
                        bits:             []FeatureBit{1},
                        expectedFeatures: []bool{false, true, false, false, false, false, false, false},
                },
                // Test setting an even bit for an odd-only bit feature. The bit should
                // be seen as set and the odd bit should not.
                {
                        bits:             []FeatureBit{2},
                        expectedFeatures: []bool{false, false, true, false, false, false, false, false},
                },
                // Test setting an odd bit for an odd-only bit feature. The bit should
                // be seen as set and the even bit should not.
                {
                        bits:             []FeatureBit{3},
                        expectedFeatures: []bool{false, false, false, true, false, false, false, false},
                },
                // Test setting an even bit for even-odd pair feature. Both bits in the
                // pair should be seen as set.
                {
                        bits:             []FeatureBit{4},
                        expectedFeatures: []bool{false, false, false, false, true, true, false, false},
                },
                // Test setting an odd bit for even-odd pair feature. Both bits in the
                // pair should be seen as set.
                {
                        bits:             []FeatureBit{5},
                        expectedFeatures: []bool{false, false, false, false, true, true, false, false},
                },
                // Test setting an even bit for an unknown feature. The bit should be
                // seen as set and the odd bit should not.
                {
                        bits:             []FeatureBit{6},
                        expectedFeatures: []bool{false, false, false, false, false, false, true, false},
                },
                // Test setting an odd bit for an unknown feature. The bit should be
                // seen as set and the odd bit should not.
                {
                        bits:             []FeatureBit{7},
                        expectedFeatures: []bool{false, false, false, false, false, false, false, true},
                },
        }

        fv := NewFeatureVector(nil, testFeatureNames)
        for i, test := range tests </span><span class="cov0" title="0">{
                for _, bit := range test.bits </span><span class="cov0" title="0">{
                        fv.Set(bit)
                }</span>

                <span class="cov0" title="0">for j, expectedSet := range test.expectedFeatures </span><span class="cov0" title="0">{
                        if fv.HasFeature(FeatureBit(j)) != expectedSet </span><span class="cov0" title="0">{
                                t.Errorf("Expectation failed in case %d, bit %d", i, j)
                                break</span>
                        }
                }

                <span class="cov0" title="0">for _, bit := range test.bits </span><span class="cov0" title="0">{
                        fv.Unset(bit)
                }</span>
        }
}

func TestFeatureVectorEncodeDecode(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        tests := []struct {
                bits            []FeatureBit
                expectedEncoded []byte
        }{
                {
                        bits:            nil,
                        expectedEncoded: []byte{0x00, 0x00},
                },
                {
                        bits:            []FeatureBit{2, 3, 7},
                        expectedEncoded: []byte{0x00, 0x01, 0x8C},
                },
                {
                        bits:            []FeatureBit{2, 3, 8},
                        expectedEncoded: []byte{0x00, 0x02, 0x01, 0x0C},
                },
        }

        for i, test := range tests </span><span class="cov0" title="0">{
                fv := NewRawFeatureVector(test.bits...)

                // Test that Encode produces the correct serialization.
                buffer := new(bytes.Buffer)
                err := fv.Encode(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to encode feature vector in case %d: %v", i, err)
                        continue</span>
                }

                <span class="cov0" title="0">encoded := buffer.Bytes()
                if !bytes.Equal(encoded, test.expectedEncoded) </span><span class="cov0" title="0">{
                        t.Errorf("Wrong encoding in case %d: got %v, expected %v",
                                i, encoded, test.expectedEncoded)
                        continue</span>
                }

                // Test that decoding then re-encoding produces the same result.
                <span class="cov0" title="0">fv2 := NewRawFeatureVector()
                err = fv2.Decode(bytes.NewReader(encoded))
                if err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to decode feature vector in case %d: %v", i, err)
                        continue</span>
                }

                <span class="cov0" title="0">buffer2 := new(bytes.Buffer)
                err = fv2.Encode(buffer2)
                if err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to re-encode feature vector in case %d: %v",
                                i, err)
                        continue</span>
                }

                <span class="cov0" title="0">reencoded := buffer2.Bytes()
                if !bytes.Equal(reencoded, test.expectedEncoded) </span><span class="cov0" title="0">{
                        t.Errorf("Wrong re-encoding in case %d: got %v, expected %v",
                                i, reencoded, test.expectedEncoded)
                }</span>
        }
}

func TestFeatureVectorUnknownFeatures(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        tests := []struct {
                bits            []FeatureBit
                expectedUnknown []FeatureBit
        }{
                {
                        bits:            nil,
                        expectedUnknown: nil,
                },
                // Since bits {0, 3, 4, 5} are known, and only even bits are considered
                // required (according to the "it's OK to be odd rule"), that leaves
                // {2, 6} as both unknown and required.
                {
                        bits:            []FeatureBit{0, 1, 2, 3, 4, 5, 6, 7},
                        expectedUnknown: []FeatureBit{2, 6},
                },
        }

        for i, test := range tests </span><span class="cov0" title="0">{
                rawVector := NewRawFeatureVector(test.bits...)
                fv := NewFeatureVector(rawVector, testFeatureNames)

                unknown := fv.UnknownRequiredFeatures()

                // Sort to make comparison independent of order
                sort.Slice(unknown, func(i, j int) bool </span><span class="cov0" title="0">{
                        return unknown[i] &lt; unknown[j]
                }</span>)
                <span class="cov0" title="0">if !reflect.DeepEqual(unknown, test.expectedUnknown) </span><span class="cov0" title="0">{
                        t.Errorf("Wrong unknown features in case %d: got %v, expected %v",
                                i, unknown, test.expectedUnknown)
                }</span>
        }
}

func TestFeatureNames(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        tests := []struct {
                bit           FeatureBit
                expectedName  string
                expectedKnown bool
        }{
                {
                        bit:           0,
                        expectedName:  "feature1(0)",
                        expectedKnown: true,
                },
                {
                        bit:           1,
                        expectedName:  "unknown(1)",
                        expectedKnown: false,
                },
                {
                        bit:           2,
                        expectedName:  "unknown(2)",
                        expectedKnown: false,
                },
                {
                        bit:           3,
                        expectedName:  "feature2(3)",
                        expectedKnown: true,
                },
                {
                        bit:           4,
                        expectedName:  "feature3(4)",
                        expectedKnown: true,
                },
                {
                        bit:           5,
                        expectedName:  "feature3(5)",
                        expectedKnown: true,
                },
                {
                        bit:           6,
                        expectedName:  "unknown(6)",
                        expectedKnown: false,
                },
                {
                        bit:           7,
                        expectedName:  "unknown(7)",
                        expectedKnown: false,
                },
        }

        fv := NewFeatureVector(nil, testFeatureNames)
        for _, test := range tests </span><span class="cov0" title="0">{
                name := fv.Name(test.bit)
                if name != test.expectedName </span><span class="cov0" title="0">{
                        t.Errorf("Name for feature bit %d is incorrect: "+
                                "expected %s, got %s", test.bit, name, test.expectedName)
                }</span>

                <span class="cov0" title="0">known := fv.IsKnown(test.bit)
                if known != test.expectedKnown </span><span class="cov0" title="0">{
                        t.Errorf("IsKnown for feature bit %d is incorrect: "+
                                "expected %v, got %v", test.bit, known, test.expectedKnown)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/wire"
)

// FundingCreated is sent from Alice (the initiator) to Bob (the responder),
// once Alice receives Bob's contributions as well as his channel constraints.
// Once bob receives this message, he'll gain access to an immediately
// broadcastable commitment transaction and will reply with a signature for
// Alice's version of the commitment transaction.
type FundingCreated struct {
        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // FundingPoint is the outpoint of the funding transaction created by
        // Alice. With this, Bob is able to generate both his version and
        // Alice's version of the commitment transaction.
        FundingPoint wire.OutPoint

        // CommitSig is Alice's signature from Bob's version of the commitment
        // transaction.
        CommitSig Sig
}

// A compile time check to ensure FundingCreated implements the lnwire.Message
// interface.
var _ Message = (*FundingCreated)(nil)

// Encode serializes the target FundingCreated into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, f.PendingChannelID[:], f.FundingPoint, f.CommitSig)
}</span>

// Decode deserializes the serialized FundingCreated stored in the passed
// io.Reader into the target FundingCreated using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r, f.PendingChannelID[:], &amp;f.FundingPoint, &amp;f.CommitSig)
}</span>

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingCreated on the wire.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) MsgType() MessageType <span class="cov1" title="1">{
        return MsgFundingCreated
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// FundingCreated message.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 32 + 2 + 64
        return 130
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
)

// FundingLocked is the message that both parties to a new channel creation
// send once they have observed the funding transaction being confirmed on the
// blockchain. FundingLocked contains the signatures necessary for the channel
// participants to advertise the existence of the channel to the rest of the
// network.
type FundingLocked struct {
        // ChanID is the outpoint of the channel's funding transaction. This
        // can be used to query for the channel in the database.
        ChanID ChannelID

        // NextPerCommitmentPoint is the secret that can be used to revoke the
        // next commitment transaction for the channel.
        NextPerCommitmentPoint *btcec.PublicKey
}

// NewFundingLocked creates a new FundingLocked message, populating it with the
// necessary IDs and revocation secret.
func NewFundingLocked(cid ChannelID, npcp *btcec.PublicKey) *FundingLocked <span class="cov0" title="0">{
        return &amp;FundingLocked{
                ChanID:                 cid,
                NextPerCommitmentPoint: npcp,
        }
}</span>

// A compile time check to ensure FundingLocked implements the lnwire.Message
// interface.
var _ Message = (*FundingLocked)(nil)

// Decode deserializes the serialized FundingLocked message stored in the
// passed io.Reader into the target FundingLocked using the deserialization
// rules defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.NextPerCommitmentPoint)
}</span>

// Encode serializes the target FundingLocked message into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.NextPerCommitmentPoint)
}</span>

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingLocked message on the wire.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) MsgType() MessageType <span class="cov1" title="1">{
        return MsgFundingLocked
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// FundingLocked message. This is calculated by summing the max length of all
// the fields within a FundingLocked message.
//
// This is part of the lnwire.Message interface.
func (c *FundingLocked) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        var length uint32

        // ChanID - 32 bytes
        length += 32

        // NextPerCommitmentPoint - 33 bytes
        length += 33

        // 65 bytes
        return length
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package lnwire

import "io"

// FundingSigned is sent from Bob (the responder) to Alice (the initiator)
// after receiving the funding outpoint and her signature for Bob's version of
// the commitment transaction.
type FundingSigned struct {
        // ChannelPoint is the particular active channel that this
        // FundingSigned is bound to.
        ChanID ChannelID

        // CommitSig is Bob's signature for Alice's version of the commitment
        // transaction.
        CommitSig Sig
}

// A compile time check to ensure FundingSigned implements the lnwire.Message
// interface.
var _ Message = (*FundingSigned)(nil)

// Encode serializes the target FundingSigned into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, f.ChanID, f.CommitSig)
}</span>

// Decode deserializes the serialized FundingSigned stored in the passed
// io.Reader into the target FundingSigned using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r, &amp;f.ChanID, &amp;f.CommitSig)
}</span>

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingSigned on the wire.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) MsgType() MessageType <span class="cov1" title="1">{
        return MsgFundingSigned
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// FundingSigned message.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 64
        return 96
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// GossipTimestampRange is a message that allows the sender to restrict the set
// of future gossip announcements sent by the receiver. Nodes should send this
// if they have the gossip-queries feature bit active. Nodes are able to send
// new GossipTimestampRange messages to replace the prior window.
type GossipTimestampRange struct {
        // ChainHash denotes the chain that the sender wishes to restrict the
        // set of received announcements of.
        ChainHash chainhash.Hash

        // FirstTimestamp is the timestamp of the earliest announcement message
        // that should be sent by the receiver.
        FirstTimestamp uint32

        // TimestampRange is the horizon beyond the FirstTimestamp that any
        // announcement messages should be sent for. The receiving node MUST
        // NOT send any announcements that have a timestamp greater than
        // FirstTimestamp + TimestampRange.
        TimestampRange uint32
}

// NewGossipTimestampRange creates a new empty GossipTimestampRange message.
func NewGossipTimestampRange() *GossipTimestampRange <span class="cov0" title="0">{
        return &amp;GossipTimestampRange{}
}</span>

// A compile time check to ensure GossipTimestampRange implements the
// lnwire.Message interface.
var _ Message = (*GossipTimestampRange)(nil)

// Decode deserializes a serialized GossipTimestampRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                g.ChainHash[:],
                &amp;g.FirstTimestamp,
                &amp;g.TimestampRange,
        )
}</span>

// Encode serializes the target GossipTimestampRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                g.ChainHash[:],
                g.FirstTimestamp,
                g.TimestampRange,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) MsgType() MessageType <span class="cov1" title="1">{
        return MsgGossipTimestampRange
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// GossipTimestampRange complete message observing the specified protocol
// version.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 4 + 4
        //
        // TODO(roasbeef): update to 8 byte timestmaps?
        return 40
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package lnwire

import "io"

// Init is the first message reveals the features supported or required by this
// node. Nodes wait for receipt of the other's features to simplify error
// diagnosis where features are incompatible. Each node MUST wait to receive
// init before sending any other messages.
type Init struct {
        // GlobalFeatures is feature vector which affects HTLCs and thus are
        // also advertised to other nodes.
        GlobalFeatures *RawFeatureVector

        // LocalFeatures is feature vector which only affect the protocol
        // between two nodes.
        LocalFeatures *RawFeatureVector
}

// NewInitMessage creates new instance of init message object.
func NewInitMessage(gf *RawFeatureVector, lf *RawFeatureVector) *Init <span class="cov0" title="0">{
        return &amp;Init{
                GlobalFeatures: gf,
                LocalFeatures:  lf,
        }
}</span>

// A compile time check to ensure Init implements the lnwire.Message
// interface.
var _ Message = (*Init)(nil)

// Decode deserializes a serialized Init message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (msg *Init) Decode(r io.Reader, pver uint32) error <span class="cov10" title="6">{
        return ReadElements(r,
                &amp;msg.GlobalFeatures,
                &amp;msg.LocalFeatures,
        )
}</span>

// Encode serializes the target Init into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (msg *Init) Encode(w io.Writer, pver uint32) error <span class="cov6" title="3">{
        return WriteElements(w,
                msg.GlobalFeatures,
                msg.LocalFeatures,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (msg *Init) MsgType() MessageType <span class="cov6" title="3">{
        return MsgInit
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an Init
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (msg *Init) MaxPayloadLength(uint32) uint32 <span class="cov10" title="6">{
        return 2 + maxAllowedSize + 2 + maxAllowedSize
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package lnwire

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "image/color"
        "io"
        "math"

        "net"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
        "github.com/btcsuite/btcutil"
        "github.com/go-errors/errors"
        "github.com/lightningnetwork/lnd/tor"
)

// MaxSliceLength is the maximum allowed length for any opaque byte slices in
// the wire protocol.
const MaxSliceLength = 65535

// PkScript is simple type definition which represents a raw serialized public
// key script.
type PkScript []byte

// addressType specifies the network protocol and version that should be used
// when connecting to a node at a particular address.
type addressType uint8

const (
        // noAddr denotes a blank address. An address of this type indicates
        // that a node doesn't have any advertised addresses.
        noAddr addressType = 0

        // tcp4Addr denotes an IPv4 TCP address.
        tcp4Addr addressType = 1

        // tcp6Addr denotes an IPv6 TCP address.
        tcp6Addr addressType = 2

        // v2OnionAddr denotes a version 2 Tor onion service address.
        v2OnionAddr addressType = 3

        // v3OnionAddr denotes a version 3 Tor (prop224) onion service address.
        v3OnionAddr addressType = 4
)

// AddrLen returns the number of bytes that it takes to encode the target
// address.
func (a addressType) AddrLen() uint16 <span class="cov0" title="0">{
        switch a </span>{
        case noAddr:<span class="cov0" title="0">
                return 0</span>
        case tcp4Addr:<span class="cov0" title="0">
                return 6</span>
        case tcp6Addr:<span class="cov0" title="0">
                return 18</span>
        case v2OnionAddr:<span class="cov0" title="0">
                return 12</span>
        case v3OnionAddr:<span class="cov0" title="0">
                return 37</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// WriteElement is a one-stop shop to write the big endian representation of
// any element which is to be serialized for the wire protocol. The passed
// io.Writer should be backed by an appropriately sized byte slice, or be able
// to dynamically expand to accommodate additional data.
//
// TODO(roasbeef): this should eventually draw from a buffer pool for
// serialization.
func WriteElement(w io.Writer, element interface{}) error <span class="cov9" title="21895">{
        switch e := element.(type) </span>{
        case NodeAlias:<span class="cov1" title="3">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ShortChanIDEncoding:<span class="cov3" title="25">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint8:<span class="cov3" title="25">
                var b [1]byte
                b[0] = e
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case FundingFlag:<span class="cov2" title="10">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint16:<span class="cov4" title="62">
                var b [2]byte
                binary.BigEndian.PutUint16(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ChanUpdateFlag:<span class="cov1" title="2">
                var b [2]byte
                binary.BigEndian.PutUint16(b[:], uint16(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ErrorCode:<span class="cov0" title="0">
                var b [2]byte
                binary.BigEndian.PutUint16(b[:], uint16(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case MilliSatoshi:<span class="cov4" title="43">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], uint64(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case btcutil.Amount:<span class="cov4" title="41">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], uint64(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint32:<span class="cov4" title="60">
                var b [4]byte
                binary.BigEndian.PutUint32(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case uint64:<span class="cov2" title="8">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *btcec.PublicKey:<span class="cov4" title="93">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil pubkey")
                }</span>

                <span class="cov4" title="93">var b [33]byte
                serializedPubkey := e.SerializeCompressed()
                copy(b[:], serializedPubkey)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case []Sig:<span class="cov1" title="2">
                var b [2]byte
                numSigs := uint16(len(e))
                binary.BigEndian.PutUint16(b[:], numSigs)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="2">for _, sig := range e </span><span class="cov6" title="555">{
                        if err := WriteElement(w, sig); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case Sig:<span class="cov6" title="581">
                // Write buffer
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case PingPayload:<span class="cov1" title="1">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case PongPayload:<span class="cov1" title="2">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="2">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ErrorData:<span class="cov1" title="1">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case OpaqueReason:<span class="cov1" title="1">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case [33]byte:<span class="cov3" title="15">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case []byte:<span class="cov4" title="75">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case PkScript:<span class="cov0" title="0">
                // The largest script we'll accept is a p2wsh which is exactly
                // 34 bytes long.
                scriptLength := len(e)
                if scriptLength &gt; 34 </span><span class="cov0" title="0">{
                        return fmt.Errorf("'PkScript' too long")
                }</span>

                <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *RawFeatureVector:<span class="cov3" title="12">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil feature vector")
                }</span>

                <span class="cov3" title="12">if err := e.Encode(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case wire.OutPoint:<span class="cov1" title="1">
                var h [32]byte
                copy(h[:], e.Hash[:])
                if _, err := w.Write(h[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if e.Index &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                        return fmt.Errorf("index for outpoint (%v) is "+
                                "greater than max index of %v", e.Index,
                                math.MaxUint16)
                }</span>

                <span class="cov1" title="1">var idx [2]byte
                binary.BigEndian.PutUint16(idx[:], uint16(e.Index))
                if _, err := w.Write(idx[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ChannelID:<span class="cov3" title="17">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case FailCode:<span class="cov1" title="1">
                if err := WriteElement(w, uint16(e)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case ShortChannelID:<span class="cov9" title="20807">
                // Check that field fit in 3 bytes and write the blockHeight
                if e.BlockHeight &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                        return errors.New("block height should fit in 3 bytes")
                }</span>

                <span class="cov9" title="20807">var blockHeight [4]byte
                binary.BigEndian.PutUint32(blockHeight[:], e.BlockHeight)

                if _, err := w.Write(blockHeight[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check that field fit in 3 bytes and write the txIndex
                <span class="cov9" title="20807">if e.TxIndex &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                        return errors.New("tx index should fit in 3 bytes")
                }</span>

                <span class="cov9" title="20807">var txIndex [4]byte
                binary.BigEndian.PutUint32(txIndex[:], e.TxIndex)
                if _, err := w.Write(txIndex[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write the txPosition
                <span class="cov9" title="20807">var txPosition [2]byte
                binary.BigEndian.PutUint16(txPosition[:], e.TxPosition)
                if _, err := w.Write(txPosition[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *net.TCPAddr:<span class="cov0" title="0">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil TCPAddr")
                }</span>

                <span class="cov0" title="0">if e.IP.To4() != nil </span><span class="cov0" title="0">{
                        var descriptor [1]byte
                        descriptor[0] = uint8(tcp4Addr)
                        if _, err := w.Write(descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">var ip [4]byte
                        copy(ip[:], e.IP.To4())
                        if _, err := w.Write(ip[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        var descriptor [1]byte
                        descriptor[0] = uint8(tcp6Addr)
                        if _, err := w.Write(descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">var ip [16]byte
                        copy(ip[:], e.IP.To16())
                        if _, err := w.Write(ip[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">var port [2]byte
                binary.BigEndian.PutUint16(port[:], uint16(e.Port))
                if _, err := w.Write(port[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *tor.OnionAddr:<span class="cov0" title="0">
                if e == nil </span><span class="cov0" title="0">{
                        return errors.New("cannot write nil onion address")
                }</span>

                <span class="cov0" title="0">var suffixIndex int
                switch len(e.OnionService) </span>{
                case tor.V2Len:<span class="cov0" title="0">
                        descriptor := []byte{byte(v2OnionAddr)}
                        if _, err := w.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">suffixIndex = tor.V2Len - tor.OnionSuffixLen</span>
                case tor.V3Len:<span class="cov0" title="0">
                        descriptor := []byte{byte(v3OnionAddr)}
                        if _, err := w.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">suffixIndex = tor.V3Len - tor.OnionSuffixLen</span>
                default:<span class="cov0" title="0">
                        return errors.New("unknown onion service length")</span>
                }

                <span class="cov0" title="0">host, err := tor.Base32Encoding.DecodeString(
                        e.OnionService[:suffixIndex],
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(host); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var port [2]byte
                binary.BigEndian.PutUint16(port[:], uint16(e.Port))
                if _, err := w.Write(port[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case []net.Addr:<span class="cov1" title="3">
                // First, we'll encode all the addresses into an intermediate
                // buffer. We need to do this in order to compute the total
                // length of the addresses.
                var addrBuf bytes.Buffer
                for _, address := range e </span><span class="cov0" title="0">{
                        if err := WriteElement(&amp;addrBuf, address); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // With the addresses fully encoded, we can now write out the
                // number of bytes needed to encode them.
                <span class="cov1" title="3">addrLen := addrBuf.Len()
                if err := WriteElement(w, uint16(addrLen)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Finally, we'll write out the raw addresses themselves, but
                // only if we have any bytes to write.
                <span class="cov1" title="3">if addrLen &gt; 0 </span><span class="cov0" title="0">{
                        if _, err := w.Write(addrBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case color.RGBA:<span class="cov1" title="3">
                if err := WriteElements(w, e.R, e.G, e.B); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case DeliveryAddress:<span class="cov1" title="1">
                var length [2]byte
                binary.BigEndian.PutUint16(length[:], uint16(len(e)))
                if _, err := w.Write(length[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("Unknown type in WriteElement: %T", e)</span>
        }

        <span class="cov9" title="21895">return nil</span>
}

// WriteElements is writes each element in the elements slice to the passed
// io.Writer using WriteElement.
func WriteElements(w io.Writer, elements ...interface{}) error <span class="cov9" title="20944">{
        for _, element := range elements </span><span class="cov9" title="21336">{
                err := WriteElement(w, element)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov9" title="20944">return nil</span>
}

// ReadElement is a one-stop utility function to deserialize any datastructure
// encoded using the serialization format of lnwire.
func ReadElement(r io.Reader, element interface{}) error <span class="cov10" title="43892">{
        var err error
        switch e := element.(type) </span>{
        case *NodeAlias:<span class="cov3" title="19">
                var a [32]byte
                if _, err := io.ReadFull(r, a[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="19">alias, err := NewNodeAlias(string(a[:]))
                if err != nil </span><span class="cov3" title="11">{
                        return err
                }</span>

                <span class="cov2" title="8">*e = alias</span>
        case *ShortChanIDEncoding:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = ShortChanIDEncoding(b[0])</span>
        case *uint8:<span class="cov4" title="90">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="90">*e = b[0]</span>
        case *FundingFlag:<span class="cov3" title="20">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="20">*e = FundingFlag(b[0])</span>
        case *uint16:<span class="cov5" title="132">
                var b [2]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="132">*e = binary.BigEndian.Uint16(b[:])</span>
        case *ChanUpdateFlag:<span class="cov2" title="4">
                var b [2]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="4">*e = ChanUpdateFlag(binary.BigEndian.Uint16(b[:]))</span>
        case *ErrorCode:<span class="cov0" title="0">
                var b [2]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = ErrorCode(binary.BigEndian.Uint16(b[:]))</span>
        case *uint32:<span class="cov5" title="139">
                var b [4]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="139">*e = binary.BigEndian.Uint32(b[:])</span>
        case *uint64:<span class="cov3" title="16">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="16">*e = binary.BigEndian.Uint64(b[:])</span>
        case *MilliSatoshi:<span class="cov4" title="96">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="96">*e = MilliSatoshi(int64(binary.BigEndian.Uint64(b[:])))</span>
        case *btcutil.Amount:<span class="cov4" title="92">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="92">*e = btcutil.Amount(int64(binary.BigEndian.Uint64(b[:])))</span>
        case **btcec.PublicKey:<span class="cov5" title="192">
                var b [btcec.PubKeyBytesLenCompressed]byte
                if _, err = io.ReadFull(r, b[:]); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov5" title="191">pubKey, err := btcec.ParsePubKey(b[:], btcec.S256())
                if err != nil </span><span class="cov1" title="3">{
                        return err
                }</span>
                <span class="cov5" title="188">*e = pubKey</span>
        case **RawFeatureVector:<span class="cov4" title="37">
                f := NewRawFeatureVector()
                err = f.Decode(r)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov4" title="37">*e = f</span>

        case *[]Sig:<span class="cov2" title="4">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="4">numSigs := binary.BigEndian.Uint16(l[:])

                var sigs []Sig
                if numSigs &gt; 0 </span><span class="cov2" title="4">{
                        sigs = make([]Sig, numSigs)
                        for i := 0; i &lt; int(numSigs); i++ </span><span class="cov6" title="1110">{
                                if err := ReadElement(r, &amp;sigs[i]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov2" title="4">*e = sigs</span>

        case *Sig:<span class="cov6" title="1175">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *OpaqueReason:<span class="cov1" title="2">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">reasonLen := binary.BigEndian.Uint16(l[:])

                *e = OpaqueReason(make([]byte, reasonLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *ErrorData:<span class="cov1" title="2">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">errorLen := binary.BigEndian.Uint16(l[:])

                *e = ErrorData(make([]byte, errorLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *PingPayload:<span class="cov1" title="2">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">pingLen := binary.BigEndian.Uint16(l[:])

                *e = PingPayload(make([]byte, pingLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *PongPayload:<span class="cov2" title="4">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="4">pongLen := binary.BigEndian.Uint16(l[:])

                *e = PongPayload(make([]byte, pongLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *[33]byte:<span class="cov4" title="43">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case []byte:<span class="cov5" title="140">
                if _, err := io.ReadFull(r, e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *PkScript:<span class="cov0" title="0">
                pkScript, err := wire.ReadVarBytes(r, 0, 34, "pkscript")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = pkScript</span>
        case *wire.OutPoint:<span class="cov1" title="2">
                var h [32]byte
                if _, err = io.ReadFull(r, h[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">hash, err := chainhash.NewHash(h[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="2">var idxBytes [2]byte
                _, err = io.ReadFull(r, idxBytes[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">index := binary.BigEndian.Uint16(idxBytes[:])

                *e = wire.OutPoint{
                        Hash:  *hash,
                        Index: uint32(index),
                }</span>
        case *FailCode:<span class="cov1" title="2">
                if err := ReadElement(r, (*uint16)(e)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *ChannelID:<span class="cov3" title="35">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *ShortChannelID:<span class="cov9" title="41614">
                var blockHeight [4]byte
                if _, err = io.ReadFull(r, blockHeight[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="41614">var txIndex [4]byte
                if _, err = io.ReadFull(r, txIndex[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="41614">var txPosition [2]byte
                if _, err = io.ReadFull(r, txPosition[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="41614">*e = ShortChannelID{
                        BlockHeight: binary.BigEndian.Uint32(blockHeight[:]),
                        TxIndex:     binary.BigEndian.Uint32(txIndex[:]),
                        TxPosition:  binary.BigEndian.Uint16(txPosition[:]),
                }</span>

        case *[]net.Addr:<span class="cov2" title="8">
                // First, we'll read the number of total bytes that have been
                // used to encode the set of addresses.
                var numAddrsBytes [2]byte
                if _, err = io.ReadFull(r, numAddrsBytes[:]); err != nil </span><span class="cov1" title="2">{
                        return err
                }</span>
                <span class="cov2" title="6">addrsLen := binary.BigEndian.Uint16(numAddrsBytes[:])

                // With the number of addresses, read, we'll now pull in the
                // buffer of the encoded addresses into memory.
                addrs := make([]byte, addrsLen)
                if _, err := io.ReadFull(r, addrs[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="6">addrBuf := bytes.NewReader(addrs)

                // Finally, we'll parse the remaining address payload in
                // series, using the first byte to denote how to decode the
                // address itself.
                var (
                        addresses     []net.Addr
                        addrBytesRead uint16
                )

                for addrBytesRead &lt; addrsLen </span><span class="cov0" title="0">{
                        var descriptor [1]byte
                        if _, err = io.ReadFull(addrBuf, descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">addrBytesRead++

                        var address net.Addr
                        switch aType := addressType(descriptor[0]); aType </span>{
                        case noAddr:<span class="cov0" title="0">
                                addrBytesRead += aType.AddrLen()
                                continue</span>

                        case tcp4Addr:<span class="cov0" title="0">
                                var ip [4]byte
                                if _, err := io.ReadFull(addrBuf, ip[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var port [2]byte
                                if _, err := io.ReadFull(addrBuf, port[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">address = &amp;net.TCPAddr{
                                        IP:   net.IP(ip[:]),
                                        Port: int(binary.BigEndian.Uint16(port[:])),
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case tcp6Addr:<span class="cov0" title="0">
                                var ip [16]byte
                                if _, err := io.ReadFull(addrBuf, ip[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var port [2]byte
                                if _, err := io.ReadFull(addrBuf, port[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">address = &amp;net.TCPAddr{
                                        IP:   net.IP(ip[:]),
                                        Port: int(binary.BigEndian.Uint16(port[:])),
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case v2OnionAddr:<span class="cov0" title="0">
                                var h [tor.V2DecodedLen]byte
                                if _, err := io.ReadFull(addrBuf, h[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var p [2]byte
                                if _, err := io.ReadFull(addrBuf, p[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">onionService := tor.Base32Encoding.EncodeToString(h[:])
                                onionService += tor.OnionSuffix
                                port := int(binary.BigEndian.Uint16(p[:]))

                                address = &amp;tor.OnionAddr{
                                        OnionService: onionService,
                                        Port:         port,
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case v3OnionAddr:<span class="cov0" title="0">
                                var h [tor.V3DecodedLen]byte
                                if _, err := io.ReadFull(addrBuf, h[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var p [2]byte
                                if _, err := io.ReadFull(addrBuf, p[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">onionService := tor.Base32Encoding.EncodeToString(h[:])
                                onionService += tor.OnionSuffix
                                port := int(binary.BigEndian.Uint16(p[:]))

                                address = &amp;tor.OnionAddr{
                                        OnionService: onionService,
                                        Port:         port,
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        default:<span class="cov0" title="0">
                                return &amp;ErrUnknownAddrType{aType}</span>
                        }

                        <span class="cov0" title="0">addresses = append(addresses, address)</span>
                }

                <span class="cov2" title="6">*e = addresses</span>
        case *color.RGBA:<span class="cov3" title="19">
                err := ReadElements(r,
                        &amp;e.R,
                        &amp;e.G,
                        &amp;e.B,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case *DeliveryAddress:<span class="cov1" title="3">
                var addrLen [2]byte
                if _, err = io.ReadFull(r, addrLen[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="3">length := binary.BigEndian.Uint16(addrLen[:])

                var addrBytes [34]byte
                if length &gt; 34 </span><span class="cov1" title="1">{
                        return fmt.Errorf("Cannot read %d bytes into addrBytes", length)
                }</span>
                <span class="cov1" title="2">if _, err = io.ReadFull(r, addrBytes[:length]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">*e = addrBytes[:length]</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("Unknown type in ReadElement: %T", e)</span>
        }

        <span class="cov9" title="43874">return nil</span>
}

// ReadElements deserializes a variable number of elements into the passed
// io.Reader, with each element being deserialized according to the ReadElement
// function.
func ReadElements(r io.Reader, elements ...interface{}) error <span class="cov9" title="41880">{
        for _, element := range elements </span><span class="cov9" title="42778">{
                err := ReadElement(r, element)
                if err != nil </span><span class="cov3" title="18">{
                        return err
                }</span>
        }
        <span class="cov9" title="41862">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package lnwire

import (
        "bytes"
        "encoding/binary"
        "encoding/hex"
        "image/color"
        "math"
        "math/big"
        "math/rand"
        "net"
        "reflect"
        "testing"
        "testing/quick"
        "time"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
        "github.com/btcsuite/btcutil"
        "github.com/davecgh/go-spew/spew"
        "github.com/lightningnetwork/lnd/tor"
)

var (
        revHash = [32]byte{
                0xb7, 0x94, 0x38, 0x5f, 0x2d, 0x1e, 0xf7, 0xab,
                0x4d, 0x92, 0x73, 0xd1, 0x90, 0x63, 0x81, 0xb4,
                0x4f, 0x2f, 0x6f, 0x25, 0x88, 0xa3, 0xef, 0xb9,
                0x6a, 0x49, 0x18, 0x83, 0x31, 0x98, 0x47, 0x53,
        }

        shaHash1Bytes, _ = hex.DecodeString("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
        shaHash1, _      = chainhash.NewHash(shaHash1Bytes)
        outpoint1        = wire.NewOutPoint(shaHash1, 0)
        testSig          = &amp;btcec.Signature{
                R: new(big.Int),
                S: new(big.Int),
        }
        _, _ = testSig.R.SetString("63724406601629180062774974542967536251589935445068131219452686511677818569431", 10)
        _, _ = testSig.S.SetString("18801056069249825825291287104931333862866033135609736119018462340006816851118", 10)
)

const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

func randAlias(r *rand.Rand) NodeAlias <span class="cov0" title="0">{
        var a NodeAlias
        for i := range a </span><span class="cov0" title="0">{
                a[i] = letterBytes[r.Intn(len(letterBytes))]
        }</span>

        <span class="cov0" title="0">return a</span>
}

func randPubKey() (*btcec.PublicKey, error) <span class="cov0" title="0">{
        priv, err := btcec.NewPrivateKey(btcec.S256())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return priv.PubKey(), nil</span>
}

func randRawKey() ([33]byte, error) <span class="cov0" title="0">{
        var n [33]byte

        priv, err := btcec.NewPrivateKey(btcec.S256())
        if err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>

        <span class="cov0" title="0">copy(n[:], priv.PubKey().SerializeCompressed())

        return n, nil</span>
}

func randRawFeatureVector(r *rand.Rand) *RawFeatureVector <span class="cov0" title="0">{
        featureVec := NewRawFeatureVector()
        for i := 0; i &lt; 10000; i++ </span><span class="cov0" title="0">{
                if r.Int31n(2) == 0 </span><span class="cov0" title="0">{
                        featureVec.Set(FeatureBit(i))
                }</span>
        }
        <span class="cov0" title="0">return featureVec</span>
}

func randTCP4Addr(r *rand.Rand) (*net.TCPAddr, error) <span class="cov0" title="0">{
        var ip [4]byte
        if _, err := r.Read(ip[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var port [2]byte
        if _, err := r.Read(port[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">addrIP := net.IP(ip[:])
        addrPort := int(binary.BigEndian.Uint16(port[:]))

        return &amp;net.TCPAddr{IP: addrIP, Port: addrPort}, nil</span>
}

func randTCP6Addr(r *rand.Rand) (*net.TCPAddr, error) <span class="cov0" title="0">{
        var ip [16]byte
        if _, err := r.Read(ip[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var port [2]byte
        if _, err := r.Read(port[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">addrIP := net.IP(ip[:])
        addrPort := int(binary.BigEndian.Uint16(port[:]))

        return &amp;net.TCPAddr{IP: addrIP, Port: addrPort}, nil</span>
}

func randV2OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) <span class="cov0" title="0">{
        var serviceID [tor.V2DecodedLen]byte
        if _, err := r.Read(serviceID[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var port [2]byte
        if _, err := r.Read(port[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">onionService := tor.Base32Encoding.EncodeToString(serviceID[:])
        onionService += tor.OnionSuffix
        addrPort := int(binary.BigEndian.Uint16(port[:]))

        return &amp;tor.OnionAddr{OnionService: onionService, Port: addrPort}, nil</span>
}

func randV3OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) <span class="cov0" title="0">{
        var serviceID [tor.V3DecodedLen]byte
        if _, err := r.Read(serviceID[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var port [2]byte
        if _, err := r.Read(port[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">onionService := tor.Base32Encoding.EncodeToString(serviceID[:])
        onionService += tor.OnionSuffix
        addrPort := int(binary.BigEndian.Uint16(port[:]))

        return &amp;tor.OnionAddr{OnionService: onionService, Port: addrPort}, nil</span>
}

func randAddrs(r *rand.Rand) ([]net.Addr, error) <span class="cov0" title="0">{
        tcp4Addr, err := randTCP4Addr(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tcp6Addr, err := randTCP6Addr(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">v2OnionAddr, err := randV2OnionAddr(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">v3OnionAddr, err := randV3OnionAddr(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []net.Addr{tcp4Addr, tcp6Addr, v2OnionAddr, v3OnionAddr}, nil</span>
}

func TestMaxOutPointIndex(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        op := wire.OutPoint{
                Index: math.MaxUint32,
        }

        var b bytes.Buffer
        if err := WriteElement(&amp;b, op); err == nil </span><span class="cov0" title="0">{
                t.Fatalf("write of outPoint should fail, index exceeds 16-bits")
        }</span>
}

func TestEmptyMessageUnknownType(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        fakeType := MessageType(math.MaxUint16)
        if _, err := MakeEmptyMessage(fakeType); err == nil </span><span class="cov0" title="0">{
                t.Fatalf("should not be able to make an empty message of an " +
                        "unknown type")
        }</span>
}

// TestLightningWireProtocol uses the testing/quick package to create a series
// of fuzz tests to attempt to break a primary scenario which is implemented as
// property based testing scenario.
func TestLightningWireProtocol(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        // mainScenario is the primary test that will programmatically be
        // executed for all registered wire messages. The quick-checker within
        // testing/quick will attempt to find an input to this function, s.t
        // the function returns false, if so then we've found an input that
        // violates our model of the system.
        mainScenario := func(msg Message) bool </span><span class="cov0" title="0">{
                // Give a new message, we'll serialize the message into a new
                // bytes buffer.
                var b bytes.Buffer
                if _, err := WriteMessage(&amp;b, msg, 0); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("unable to write msg: %v", err)
                        return false
                }</span>

                // Next, we'll ensure that the serialized payload (subtracting
                // the 2 bytes for the message type) is _below_ the specified
                // max payload size for this message.
                <span class="cov0" title="0">payloadLen := uint32(b.Len()) - 2
                if payloadLen &gt; msg.MaxPayloadLength(0) </span><span class="cov0" title="0">{
                        t.Fatalf("msg payload constraint violated: %v &gt; %v",
                                payloadLen, msg.MaxPayloadLength(0))
                        return false
                }</span>

                // Finally, we'll deserialize the message from the written
                // buffer, and finally assert that the messages are equal.
                <span class="cov0" title="0">newMsg, err := ReadMessage(&amp;b, 0)
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("unable to read msg: %v", err)
                        return false
                }</span>
                <span class="cov0" title="0">if !reflect.DeepEqual(msg, newMsg) </span><span class="cov0" title="0">{
                        t.Fatalf("messages don't match after re-encoding: %v "+
                                "vs %v", spew.Sdump(msg), spew.Sdump(newMsg))
                        return false
                }</span>

                <span class="cov0" title="0">return true</span>
        }

        // customTypeGen is a map of functions that are able to randomly
        // generate a given type. These functions are needed for types which
        // are too complex for the testing/quick package to automatically
        // generate.
        <span class="cov0" title="0">customTypeGen := map[MessageType]func([]reflect.Value, *rand.Rand){
                MsgInit: func(v []reflect.Value, r *rand.Rand) </span><span class="cov0" title="0">{
                        req := NewInitMessage(
                                randRawFeatureVector(r),
                                randRawFeatureVector(r),
                        )

                        v[0] = reflect.ValueOf(*req)
                }</span>,
                MsgOpenChannel: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := OpenChannel{
                                FundingAmount:    btcutil.Amount(r.Int63()),
                                PushAmount:       MilliSatoshi(r.Int63()),
                                DustLimit:        btcutil.Amount(r.Int63()),
                                MaxValueInFlight: MilliSatoshi(r.Int63()),
                                ChannelReserve:   btcutil.Amount(r.Int63()),
                                HtlcMinimum:      MilliSatoshi(r.Int31()),
                                FeePerKiloWeight: uint32(r.Int63()),
                                CsvDelay:         uint16(r.Int31()),
                                MaxAcceptedHTLCs: uint16(r.Int31()),
                                ChannelFlags:     FundingFlag(uint8(r.Int31())),
                        }

                        if _, err := r.Read(req.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chain hash: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if _, err := r.Read(req.PendingChannelID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate pending chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">var err error
                        req.FundingKey, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.RevocationPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.PaymentPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.DelayedPaymentPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.HtlcPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.FirstCommitmentPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgAcceptChannel: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := AcceptChannel{
                                DustLimit:        btcutil.Amount(r.Int63()),
                                MaxValueInFlight: MilliSatoshi(r.Int63()),
                                ChannelReserve:   btcutil.Amount(r.Int63()),
                                MinAcceptDepth:   uint32(r.Int31()),
                                HtlcMinimum:      MilliSatoshi(r.Int31()),
                                CsvDelay:         uint16(r.Int31()),
                                MaxAcceptedHTLCs: uint16(r.Int31()),
                        }

                        if _, err := r.Read(req.PendingChannelID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate pending chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">var err error
                        req.FundingKey, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.RevocationPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.PaymentPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.DelayedPaymentPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.HtlcPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.FirstCommitmentPoint, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgFundingCreated: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := FundingCreated{}

                        if _, err := r.Read(req.PendingChannelID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate pending chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if _, err := r.Read(req.FundingPoint.Hash[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate hash: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.FundingPoint.Index = uint32(r.Int31()) % math.MaxUint16

                        var err error
                        req.CommitSig, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgFundingSigned: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        var c [32]byte
                        _, err := r.Read(c[:])
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req := FundingSigned{
                                ChanID: ChannelID(c),
                        }
                        req.CommitSig, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgFundingLocked: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{

                        var c [32]byte
                        if _, err := r.Read(c[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">pubKey, err := randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req := NewFundingLocked(ChannelID(c), pubKey)

                        v[0] = reflect.ValueOf(*req)</span>
                },
                MsgClosingSigned: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := ClosingSigned{
                                FeeSatoshis: btcutil.Amount(r.Int63()),
                        }
                        var err error
                        req.Signature, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if _, err := r.Read(req.ChannelID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgCommitSig: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := NewCommitSig()
                        if _, err := r.Read(req.ChanID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">var err error
                        req.CommitSig, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        // Only create the slice if there will be any signatures
                        // in it to prevent false positive test failures due to
                        // an empty slice versus a nil slice.
                        <span class="cov0" title="0">numSigs := uint16(r.Int31n(1020))
                        if numSigs &gt; 0 </span><span class="cov0" title="0">{
                                req.HtlcSigs = make([]Sig, numSigs)
                        }</span>
                        <span class="cov0" title="0">for i := 0; i &lt; int(numSigs); i++ </span><span class="cov0" title="0">{
                                req.HtlcSigs[i], err = NewSigFromSignature(testSig)
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to parse sig: %v", err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(*req)</span>
                },
                MsgRevokeAndAck: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := NewRevokeAndAck()
                        if _, err := r.Read(req.ChanID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chan id: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := r.Read(req.Revocation[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate bytes: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">var err error
                        req.NextRevocationKey, err = randPubKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(*req)</span>
                },
                MsgChannelAnnouncement: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        var err error
                        req := ChannelAnnouncement{
                                ShortChannelID: NewShortChanIDFromInt(uint64(r.Int63())),
                                Features:       randRawFeatureVector(r),
                        }
                        req.NodeSig1, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.NodeSig2, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.BitcoinSig1, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.BitcoinSig2, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req.NodeID1, err = randRawKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.NodeID2, err = randRawKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.BitcoinKey1, err = randRawKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">req.BitcoinKey2, err = randRawKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := r.Read(req.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chain hash: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">numExtraBytes := r.Int31n(1000)
                        if numExtraBytes &gt; 0 </span><span class="cov0" title="0">{
                                req.ExtraOpaqueData = make([]byte, numExtraBytes)
                                _, err := r.Read(req.ExtraOpaqueData[:])
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to generate opaque "+
                                                "bytes: %v", err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgNodeAnnouncement: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        var err error
                        req := NodeAnnouncement{
                                Features:  randRawFeatureVector(r),
                                Timestamp: uint32(r.Int31()),
                                Alias:     randAlias(r),
                                RGBColor: color.RGBA{
                                        R: uint8(r.Int31()),
                                        G: uint8(r.Int31()),
                                        B: uint8(r.Int31()),
                                },
                        }
                        req.Signature, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req.NodeID, err = randRawKey()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate key: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req.Addresses, err = randAddrs(r)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate addresses: %v", err)
                        }</span>

                        <span class="cov0" title="0">numExtraBytes := r.Int31n(1000)
                        if numExtraBytes &gt; 0 </span><span class="cov0" title="0">{
                                req.ExtraOpaqueData = make([]byte, numExtraBytes)
                                _, err := r.Read(req.ExtraOpaqueData[:])
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to generate opaque "+
                                                "bytes: %v", err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgChannelUpdate: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        var err error
                        req := ChannelUpdate{
                                ShortChannelID:  NewShortChanIDFromInt(uint64(r.Int63())),
                                Timestamp:       uint32(r.Int31()),
                                Flags:           ChanUpdateFlag(r.Int31()),
                                TimeLockDelta:   uint16(r.Int31()),
                                HtlcMinimumMsat: MilliSatoshi(r.Int63()),
                                BaseFee:         uint32(r.Int31()),
                                FeeRate:         uint32(r.Int31()),
                        }
                        req.Signature, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if _, err := r.Read(req.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chain hash: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">numExtraBytes := r.Int31n(1000)
                        if numExtraBytes &gt; 0 </span><span class="cov0" title="0">{
                                req.ExtraOpaqueData = make([]byte, numExtraBytes)
                                _, err := r.Read(req.ExtraOpaqueData[:])
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to generate opaque "+
                                                "bytes: %v", err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgAnnounceSignatures: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        var err error
                        req := AnnounceSignatures{
                                ShortChannelID: NewShortChanIDFromInt(uint64(r.Int63())),
                        }

                        req.NodeSignature, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req.BitcoinSignature, err = NewSigFromSignature(testSig)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to parse sig: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if _, err := r.Read(req.ChannelID[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to generate chan id: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">numExtraBytes := r.Int31n(1000)
                        if numExtraBytes &gt; 0 </span><span class="cov0" title="0">{
                                req.ExtraOpaqueData = make([]byte, numExtraBytes)
                                _, err := r.Read(req.ExtraOpaqueData[:])
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to generate opaque "+
                                                "bytes: %v", err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgChannelReestablish: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := ChannelReestablish{
                                NextLocalCommitHeight:  uint64(r.Int63()),
                                RemoteCommitTailHeight: uint64(r.Int63()),
                        }

                        // With a 50/50 probability, we'll include the
                        // additional fields so we can test our ability to
                        // properly parse, and write out the optional fields.
                        if r.Int()%2 == 0 </span><span class="cov0" title="0">{
                                _, err := r.Read(req.LastRemoteCommitSecret[:])
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to read commit secret: %v", err)
                                        return
                                }</span>

                                <span class="cov0" title="0">req.LocalUnrevokedCommitPoint, err = randPubKey()
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("unable to generate key: %v", err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgQueryShortChanIDs: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := QueryShortChanIDs{}

                        // With a 50/50 change, we'll either use zlib encoding,
                        // or regular encoding.
                        if r.Int31()%2 == 0 </span><span class="cov0" title="0">{
                                req.EncodingType = EncodingSortedZlib
                        }</span> else<span class="cov0" title="0"> {
                                req.EncodingType = EncodingSortedPlain
                        }</span>

                        <span class="cov0" title="0">if _, err := rand.Read(req.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to read chain hash: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">numChanIDs := rand.Int31n(5000)
                        for i := int32(0); i &lt; numChanIDs; i++ </span><span class="cov0" title="0">{
                                req.ShortChanIDs = append(req.ShortChanIDs,
                                        NewShortChanIDFromInt(uint64(r.Int63())))
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
                MsgReplyChannelRange: func(v []reflect.Value, r *rand.Rand) <span class="cov0" title="0">{
                        req := ReplyChannelRange{
                                QueryChannelRange: QueryChannelRange{
                                        FirstBlockHeight: uint32(r.Int31()),
                                        NumBlocks:        uint32(r.Int31()),
                                },
                        }

                        if _, err := rand.Read(req.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("unable to read chain hash: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">req.Complete = uint8(r.Int31n(2))

                        // With a 50/50 change, we'll either use zlib encoding,
                        // or regular encoding.
                        if r.Int31()%2 == 0 </span><span class="cov0" title="0">{
                                req.EncodingType = EncodingSortedZlib
                        }</span> else<span class="cov0" title="0"> {
                                req.EncodingType = EncodingSortedPlain
                        }</span>

                        <span class="cov0" title="0">numChanIDs := rand.Int31n(5000)
                        for i := int32(0); i &lt; numChanIDs; i++ </span><span class="cov0" title="0">{
                                req.ShortChanIDs = append(req.ShortChanIDs,
                                        NewShortChanIDFromInt(uint64(r.Int63())))
                        }</span>

                        <span class="cov0" title="0">v[0] = reflect.ValueOf(req)</span>
                },
        }

        // With the above types defined, we'll now generate a slice of
        // scenarios to feed into quick.Check. The function scans in input
        // space of the target function under test, so we'll need to create a
        // series of wrapper functions to force it to iterate over the target
        // types, but re-use the mainScenario defined above.
        <span class="cov0" title="0">tests := []struct {
                msgType  MessageType
                scenario interface{}
        }{
                {
                        msgType: MsgInit,
                        scenario: func(m Init) bool </span><span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgError,
                        scenario: func(m Error) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgPing,
                        scenario: func(m Ping) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgPong,
                        scenario: func(m Pong) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgOpenChannel,
                        scenario: func(m OpenChannel) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgAcceptChannel,
                        scenario: func(m AcceptChannel) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgFundingCreated,
                        scenario: func(m FundingCreated) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgFundingSigned,
                        scenario: func(m FundingSigned) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgFundingLocked,
                        scenario: func(m FundingLocked) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgShutdown,
                        scenario: func(m Shutdown) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgClosingSigned,
                        scenario: func(m ClosingSigned) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgUpdateAddHTLC,
                        scenario: func(m UpdateAddHTLC) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgUpdateFulfillHTLC,
                        scenario: func(m UpdateFulfillHTLC) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgUpdateFailHTLC,
                        scenario: func(m UpdateFailHTLC) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgCommitSig,
                        scenario: func(m CommitSig) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgRevokeAndAck,
                        scenario: func(m RevokeAndAck) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgUpdateFee,
                        scenario: func(m UpdateFee) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {

                        msgType: MsgUpdateFailMalformedHTLC,
                        scenario: func(m UpdateFailMalformedHTLC) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgChannelReestablish,
                        scenario: func(m ChannelReestablish) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgChannelAnnouncement,
                        scenario: func(m ChannelAnnouncement) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgNodeAnnouncement,
                        scenario: func(m NodeAnnouncement) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgChannelUpdate,
                        scenario: func(m ChannelUpdate) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgAnnounceSignatures,
                        scenario: func(m AnnounceSignatures) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgGossipTimestampRange,
                        scenario: func(m GossipTimestampRange) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgQueryShortChanIDs,
                        scenario: func(m QueryShortChanIDs) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgReplyShortChanIDsEnd,
                        scenario: func(m ReplyShortChanIDsEnd) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgQueryChannelRange,
                        scenario: func(m QueryChannelRange) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
                {
                        msgType: MsgReplyChannelRange,
                        scenario: func(m ReplyChannelRange) bool <span class="cov0" title="0">{
                                return mainScenario(&amp;m)
                        }</span>,
                },
        }
        <span class="cov0" title="0">for _, test := range tests </span><span class="cov0" title="0">{
                var config *quick.Config

                // If the type defined is within the custom type gen map above,
                // then we'll modify the default config to use this Value
                // function that knows how to generate the proper types.
                if valueGen, ok := customTypeGen[test.msgType]; ok </span><span class="cov0" title="0">{
                        config = &amp;quick.Config{
                                Values: valueGen,
                        }
                }</span>

                <span class="cov0" title="0">t.Logf("Running fuzz tests for msgType=%v", test.msgType)
                if err := quick.Check(test.scenario, config); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("fuzz checks for msg=%v failed: %v",
                                test.msgType, err)
                }</span>
        }

}

func init() <span class="cov8" title="1">{
        rand.Seed(time.Now().Unix())
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) 2013-2017 The btcsuite developers
// Copyright (c) 2015-2016 The Decred developers
// code derived from https://github .com/btcsuite/btcd/blob/master/wire/message.go
// Copyright (C) 2015-2017 The Lightning Network Developers

package lnwire

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// MaxMessagePayload is the maximum bytes a message can be regardless of other
// individual limits imposed by messages themselves.
const MaxMessagePayload = 65535 // 65KB

// MessageType is the unique 2 byte big-endian integer that indicates the type
// of message on the wire. All messages have a very simple header which
// consists simply of 2-byte message type. We omit a length field, and checksum
// as the Lightning Protocol is intended to be encapsulated within a
// confidential+authenticated cryptographic messaging protocol.
type MessageType uint16

// The currently defined message types within this current version of the
// Lightning protocol.
const (
        MsgInit                    MessageType = 16
        MsgError                               = 17
        MsgPing                                = 18
        MsgPong                                = 19
        MsgOpenChannel                         = 32
        MsgAcceptChannel                       = 33
        MsgFundingCreated                      = 34
        MsgFundingSigned                       = 35
        MsgFundingLocked                       = 36
        MsgShutdown                            = 38
        MsgClosingSigned                       = 39
        MsgUpdateAddHTLC                       = 128
        MsgUpdateFulfillHTLC                   = 130
        MsgUpdateFailHTLC                      = 131
        MsgCommitSig                           = 132
        MsgRevokeAndAck                        = 133
        MsgUpdateFee                           = 134
        MsgUpdateFailMalformedHTLC             = 135
        MsgChannelReestablish                  = 136
        MsgChannelAnnouncement                 = 256
        MsgNodeAnnouncement                    = 257
        MsgChannelUpdate                       = 258
        MsgAnnounceSignatures                  = 259
        MsgQueryShortChanIDs                   = 261
        MsgReplyShortChanIDsEnd                = 262
        MsgQueryChannelRange                   = 263
        MsgReplyChannelRange                   = 264
        MsgGossipTimestampRange                = 265
)

// String return the string representation of message type.
func (t MessageType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case MsgInit:<span class="cov0" title="0">
                return "Init"</span>
        case MsgOpenChannel:<span class="cov0" title="0">
                return "MsgOpenChannel"</span>
        case MsgAcceptChannel:<span class="cov0" title="0">
                return "MsgAcceptChannel"</span>
        case MsgFundingCreated:<span class="cov0" title="0">
                return "MsgFundingCreated"</span>
        case MsgFundingSigned:<span class="cov0" title="0">
                return "MsgFundingSigned"</span>
        case MsgFundingLocked:<span class="cov0" title="0">
                return "FundingLocked"</span>
        case MsgShutdown:<span class="cov0" title="0">
                return "Shutdown"</span>
        case MsgClosingSigned:<span class="cov0" title="0">
                return "ClosingSigned"</span>
        case MsgUpdateAddHTLC:<span class="cov0" title="0">
                return "UpdateAddHTLC"</span>
        case MsgUpdateFailHTLC:<span class="cov0" title="0">
                return "UpdateFailHTLC"</span>
        case MsgUpdateFulfillHTLC:<span class="cov0" title="0">
                return "UpdateFulfillHTLC"</span>
        case MsgCommitSig:<span class="cov0" title="0">
                return "CommitSig"</span>
        case MsgRevokeAndAck:<span class="cov0" title="0">
                return "RevokeAndAck"</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov0" title="0">
                return "UpdateFailMalformedHTLC"</span>
        case MsgChannelReestablish:<span class="cov0" title="0">
                return "ChannelReestablish"</span>
        case MsgError:<span class="cov0" title="0">
                return "Error"</span>
        case MsgChannelAnnouncement:<span class="cov0" title="0">
                return "ChannelAnnouncement"</span>
        case MsgChannelUpdate:<span class="cov0" title="0">
                return "ChannelUpdate"</span>
        case MsgNodeAnnouncement:<span class="cov0" title="0">
                return "NodeAnnouncement"</span>
        case MsgPing:<span class="cov0" title="0">
                return "Ping"</span>
        case MsgAnnounceSignatures:<span class="cov0" title="0">
                return "AnnounceSignatures"</span>
        case MsgPong:<span class="cov0" title="0">
                return "Pong"</span>
        case MsgUpdateFee:<span class="cov0" title="0">
                return "UpdateFee"</span>
        case MsgQueryShortChanIDs:<span class="cov0" title="0">
                return "QueryShortChanIDs"</span>
        case MsgReplyShortChanIDsEnd:<span class="cov0" title="0">
                return "ReplyShortChanIDsEnd"</span>
        case MsgQueryChannelRange:<span class="cov0" title="0">
                return "QueryChannelRange"</span>
        case MsgReplyChannelRange:<span class="cov0" title="0">
                return "ReplyChannelRange"</span>
        case MsgGossipTimestampRange:<span class="cov0" title="0">
                return "GossipTimestampRange"</span>
        default:<span class="cov0" title="0">
                return "&lt;unknown&gt;"</span>
        }
}

// UnknownMessage is an implementation of the error interface that allows the
// creation of an error in response to an unknown message.
type UnknownMessage struct {
        messageType MessageType
}

// Error returns a human readable string describing the error.
//
// This is part of the error interface.
func (u *UnknownMessage) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unable to parse message of unknown type: %v",
                u.messageType)
}</span>

// Serializable is an interface which defines a lightning wire serializable
// object.
type Serializable interface {
        // Decode reads the bytes stream and converts it to the object.
        Decode(io.Reader, uint32) error

        // Encode converts object to the bytes stream and write it into the
        // writer.
        Encode(io.Writer, uint32) error
}

// Message is an interface that defines a lightning wire protocol message. The
// interface is general in order to allow implementing types full control over
// the representation of its data.
type Message interface {
        Serializable
        MsgType() MessageType
        MaxPayloadLength(uint32) uint32
}

// MakeEmptyMessage creates a new empty message of the proper concrete type
// based on the passed message type.
func MakeEmptyMessage(msgType MessageType) (Message, error) <span class="cov10" title="273">{
        var msg Message

        switch msgType </span>{
        case MsgInit:<span class="cov4" title="9">
                msg = &amp;Init{}</span>
        case MsgOpenChannel:<span class="cov6" title="34">
                msg = &amp;OpenChannel{}</span>
        case MsgAcceptChannel:<span class="cov5" title="19">
                msg = &amp;AcceptChannel{}</span>
        case MsgFundingCreated:<span class="cov2" title="3">
                msg = &amp;FundingCreated{}</span>
        case MsgFundingSigned:<span class="cov2" title="3">
                msg = &amp;FundingSigned{}</span>
        case MsgFundingLocked:<span class="cov2" title="3">
                msg = &amp;FundingLocked{}</span>
        case MsgShutdown:<span class="cov3" title="5">
                msg = &amp;Shutdown{}</span>
        case MsgClosingSigned:<span class="cov2" title="3">
                msg = &amp;ClosingSigned{}</span>
        case MsgUpdateAddHTLC:<span class="cov2" title="3">
                msg = &amp;UpdateAddHTLC{}</span>
        case MsgUpdateFailHTLC:<span class="cov2" title="3">
                msg = &amp;UpdateFailHTLC{}</span>
        case MsgUpdateFulfillHTLC:<span class="cov2" title="3">
                msg = &amp;UpdateFulfillHTLC{}</span>
        case MsgCommitSig:<span class="cov3" title="6">
                msg = &amp;CommitSig{}</span>
        case MsgRevokeAndAck:<span class="cov2" title="3">
                msg = &amp;RevokeAndAck{}</span>
        case MsgUpdateFee:<span class="cov2" title="3">
                msg = &amp;UpdateFee{}</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov2" title="3">
                msg = &amp;UpdateFailMalformedHTLC{}</span>
        case MsgChannelReestablish:<span class="cov3" title="6">
                msg = &amp;ChannelReestablish{}</span>
        case MsgError:<span class="cov2" title="3">
                msg = &amp;Error{}</span>
        case MsgChannelAnnouncement:<span class="cov4" title="9">
                msg = &amp;ChannelAnnouncement{}</span>
        case MsgChannelUpdate:<span class="cov3" title="6">
                msg = &amp;ChannelUpdate{}</span>
        case MsgNodeAnnouncement:<span class="cov6" title="35">
                msg = &amp;NodeAnnouncement{}</span>
        case MsgPing:<span class="cov2" title="3">
                msg = &amp;Ping{}</span>
        case MsgAnnounceSignatures:<span class="cov3" title="6">
                msg = &amp;AnnounceSignatures{}</span>
        case MsgPong:<span class="cov3" title="6">
                msg = &amp;Pong{}</span>
        case MsgQueryShortChanIDs:<span class="cov6" title="40">
                msg = &amp;QueryShortChanIDs{}</span>
        case MsgReplyShortChanIDsEnd:<span class="cov2" title="3">
                msg = &amp;ReplyShortChanIDsEnd{}</span>
        case MsgQueryChannelRange:<span class="cov2" title="3">
                msg = &amp;QueryChannelRange{}</span>
        case MsgReplyChannelRange:<span class="cov7" title="47">
                msg = &amp;ReplyChannelRange{}</span>
        case MsgGossipTimestampRange:<span class="cov2" title="3">
                msg = &amp;GossipTimestampRange{}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;UnknownMessage{msgType}</span>
        }

        <span class="cov10" title="273">return msg, nil</span>
}

// WriteMessage writes a lightning Message to w including the necessary header
// information and returns the number of bytes written.
func WriteMessage(w io.Writer, msg Message, pver uint32) (int, error) <span class="cov7" title="75">{
        totalBytes := 0

        // Encode the message payload itself into a temporary buffer.
        // TODO(roasbeef): create buffer pool
        var bw bytes.Buffer
        if err := msg.Encode(&amp;bw, pver); err != nil </span><span class="cov0" title="0">{
                return totalBytes, err
        }</span>
        <span class="cov7" title="75">payload := bw.Bytes()
        lenp := len(payload)

        // Enforce maximum overall message payload.
        if lenp &gt; MaxMessagePayload </span><span class="cov0" title="0">{
                return totalBytes, fmt.Errorf("message payload is too large - "+
                        "encoded %d bytes, but maximum message payload is %d bytes",
                        lenp, MaxMessagePayload)
        }</span>

        // Enforce maximum message payload on the message type.
        <span class="cov7" title="75">mpl := msg.MaxPayloadLength(pver)
        if uint32(lenp) &gt; mpl </span><span class="cov0" title="0">{
                return totalBytes, fmt.Errorf("message payload is too large - "+
                        "encoded %d bytes, but maximum message payload of "+
                        "type %v is %d bytes", lenp, msg.MsgType(), mpl)
        }</span>

        // With the initial sanity checks complete, we'll now write out the
        // message type itself.
        <span class="cov7" title="75">var mType [2]byte
        binary.BigEndian.PutUint16(mType[:], uint16(msg.MsgType()))
        n, err := w.Write(mType[:])
        totalBytes += n
        if err != nil </span><span class="cov0" title="0">{
                return totalBytes, err
        }</span>

        // With the message type written, we'll now write out the raw payload
        // itself.
        <span class="cov7" title="75">n, err = w.Write(payload)
        totalBytes += n

        return totalBytes, err</span>
}

// ReadMessage reads, validates, and parses the next Lightning message from r
// for the provided protocol version.
func ReadMessage(r io.Reader, pver uint32) (Message, error) <span class="cov9" title="174">{
        // First, we'll read out the first two bytes of the message so we can
        // create the proper empty message.
        var mType [2]byte
        if _, err := io.ReadFull(r, mType[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="174">msgType := MessageType(binary.BigEndian.Uint16(mType[:]))

        // Now that we know the target message type, we can create the proper
        // empty message type and decode the message into it.
        msg, err := MakeEmptyMessage(msgType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="174">if err := msg.Decode(r, pver); err != nil </span><span class="cov6" title="24">{
                return nil, err
        }</span>

        <span class="cov9" title="150">return msg, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package lnwire

import (
        "fmt"

        "github.com/btcsuite/btcutil"
)

// mSatScale is a value that's used to scale satoshis to milli-satoshis, and
// the other way around.
const mSatScale uint64 = 1000

// MilliSatoshi are the native unit of the Lightning Network. A milli-satoshi
// is simply 1/1000th of a satoshi. There are 1000 milli-satoshis in a single
// satoshi. Within the network, all HTLC payments are denominated in
// milli-satoshis. As milli-satoshis aren't deliverable on the native
// blockchain, before settling to broadcasting, the values are rounded down to
// the nearest satoshi.
type MilliSatoshi uint64

// NewMSatFromSatoshis creates a new MilliSatoshi instance from a target amount
// of satoshis.
func NewMSatFromSatoshis(sat btcutil.Amount) MilliSatoshi <span class="cov0" title="0">{
        return MilliSatoshi(uint64(sat) * mSatScale)
}</span>

// ToBTC converts the target MilliSatoshi amount to its corresponding value
// when expressed in BTC.
func (m MilliSatoshi) ToBTC() float64 <span class="cov0" title="0">{
        sat := m.ToSatoshis()
        return sat.ToBTC()
}</span>

// ToSatoshis converts the target MilliSatoshi amount to satoshis. Simply, this
// sheds a factor of 1000 from the mSAT amount in order to convert it to SAT.
func (m MilliSatoshi) ToSatoshis() btcutil.Amount <span class="cov0" title="0">{
        return btcutil.Amount(uint64(m) / mSatScale)
}</span>

// String returns the string representation of the mSAT amount.
func (m MilliSatoshi) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v mSAT", uint64(m))
}</span>

// TODO(roasbeef): extend with arithmetic operations?
</pre>
		
		<pre class="file" id="file21" style="display: none">package lnwire

import (
        "testing"

        "github.com/btcsuite/btcutil"
)

func TestMilliSatoshiConversion(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        testCases := []struct {
                mSatAmount MilliSatoshi

                satAmount btcutil.Amount
                btcAmount float64
        }{
                {
                        mSatAmount: 0,
                        satAmount:  0,
                        btcAmount:  0,
                },
                {
                        mSatAmount: 10,
                        satAmount:  0,
                        btcAmount:  0,
                },
                {
                        mSatAmount: 999,
                        satAmount:  0,
                        btcAmount:  0,
                },
                {
                        mSatAmount: 1000,
                        satAmount:  1,
                        btcAmount:  1e-8,
                },
                {
                        mSatAmount: 10000,
                        satAmount:  10,
                        btcAmount:  0.00000010,
                },
                {
                        mSatAmount: 100000000000,
                        satAmount:  100000000,
                        btcAmount:  1,
                },
                {
                        mSatAmount: 2500000000000,
                        satAmount:  2500000000,
                        btcAmount:  25,
                },
                {
                        mSatAmount: 5000000000000,
                        satAmount:  5000000000,
                        btcAmount:  50,
                },
                {
                        mSatAmount: 21 * 1e6 * 1e8 * 1e3,
                        satAmount:  21 * 1e6 * 1e8,
                        btcAmount:  21 * 1e6,
                },
        }

        for i, test := range testCases </span><span class="cov0" title="0">{
                if test.mSatAmount.ToSatoshis() != test.satAmount </span><span class="cov0" title="0">{
                        t.Fatalf("test #%v: wrong sat amount, expected %v "+
                                "got %v", i, int64(test.satAmount),
                                int64(test.mSatAmount.ToSatoshis()))
                }</span>
                <span class="cov0" title="0">if test.mSatAmount.ToBTC() != test.btcAmount </span><span class="cov0" title="0">{
                        t.Fatalf("test #%v: wrong btc amount, expected %v "+
                                "got %v", i, test.btcAmount,
                                test.mSatAmount.ToBTC())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package lnwire

import (
        "fmt"
        "net"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/wire"
)

// NetAddress represents information pertaining to the identity and network
// reachability of a peer. Information stored includes the node's identity
// public key for establishing a confidential+authenticated connection, the
// service bits it supports, and a TCP address the node is reachable at.
//
// TODO(roasbeef): merge with LinkNode in some fashion
type NetAddress struct {
        // IdentityKey is the long-term static public key for a node. This node is
        // used throughout the network as a node's identity key. It is used to
        // authenticate any data sent to the network on behalf of the node, and
        // additionally to establish a confidential+authenticated connection with
        // the node.
        IdentityKey *btcec.PublicKey

        // Address is the IP address and port of the node. This is left
        // general so that multiple implementations can be used.
        Address net.Addr

        // ChainNet is the Bitcoin network this node is associated with.
        // TODO(roasbeef): make a slice in the future for multi-chain
        ChainNet wire.BitcoinNet
}

// A compile time assertion to ensure that NetAddress meets the net.Addr
// interface.
var _ net.Addr = (*NetAddress)(nil)

// String returns a human readable string describing the target NetAddress. The
// current string format is: &lt;pubkey&gt;@host.
//
// This part of the net.Addr interface.
func (n *NetAddress) String() string <span class="cov0" title="0">{
        // TODO(roasbeef): use base58?
        pubkey := n.IdentityKey.SerializeCompressed()

        return fmt.Sprintf("%x@%v", pubkey, n.Address)
}</span>

// Network returns the name of the network this address is bound to.
//
// This part of the net.Addr interface.
func (n *NetAddress) Network() string <span class="cov0" title="0">{
        return n.Address.Network()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package lnwire

import (
        "encoding/hex"
        "net"
        "testing"

        "github.com/btcsuite/btcd/btcec"
)

func TestNetAddressDisplay(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        pubKeyStr := "036a0c5ea35df8a528b98edf6f290b28676d51d0fe202b073fe677612a39c0aa09"
        pubHex, err := hex.DecodeString(pubKeyStr)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to decode str: %v", err)
        }</span>

        <span class="cov0" title="0">pubKey, err := btcec.ParsePubKey(pubHex, btcec.S256())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to parse pubkey: %v", err)
        }</span>
        <span class="cov0" title="0">addr, _ := net.ResolveTCPAddr("tcp", "10.0.0.2:9000")

        netAddr := NetAddress{
                IdentityKey: pubKey,
                Address:     addr,
        }

        if addr.Network() != netAddr.Network() </span><span class="cov0" title="0">{
                t.Fatalf("network addr mismatch: %v", err)
        }</span>

        <span class="cov0" title="0">expectedAddr := pubKeyStr + "@" + addr.String()
        addrString := netAddr.String()
        if expectedAddr != addrString </span><span class="cov0" title="0">{
                t.Fatalf("expected %v, got %v", expectedAddr, addrString)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "image/color"
        "io"
        "io/ioutil"
        "net"
        "unicode/utf8"
)

var (
        startPort uint16 = 1024
        endPort   uint16 = 49151
)

// ErrUnknownAddrType is an error returned if we encounter an unknown address type
// when parsing addresses.
type ErrUnknownAddrType struct {
        addrType addressType
}

// Error returns a human readable string describing the error.
//
// NOTE: implements the error interface.
func (e ErrUnknownAddrType) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unknown address type: %v", e.addrType)
}</span>

// ErrInvalidNodeAlias is an error returned if a node alias we parse on the
// wire is invalid, as in it has non UTF-8 characters.
type ErrInvalidNodeAlias struct{}

// Error returns a human readable string describing the error.
//
// NOTE: implements the error interface.
func (e ErrInvalidNodeAlias) Error() string <span class="cov0" title="0">{
        return "node alias has non-utf8 characters"
}</span>

// NodeAlias a hex encoded UTF-8 string that may be displayed as an alternative
// to the node's ID. Notice that aliases are not unique and may be freely
// chosen by the node operators.
type NodeAlias [32]byte

// NewNodeAlias creates a new instance of a NodeAlias. Verification is
// performed on the passed string to ensure it meets the alias requirements.
func NewNodeAlias(s string) (NodeAlias, error) <span class="cov10" title="19">{
        var n NodeAlias

        if len(s) &gt; 32 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("alias too large: max is %v, got %v", 32,
                        len(s))
        }</span>

        <span class="cov10" title="19">if !utf8.ValidString(s) </span><span class="cov8" title="11">{
                return n, &amp;ErrInvalidNodeAlias{}
        }</span>

        <span class="cov7" title="8">copy(n[:], []byte(s))
        return n, nil</span>
}

// String returns a utf8 string representation of the alias bytes.
func (n NodeAlias) String() string <span class="cov0" title="0">{
        // Trim trailing zero-bytes for presentation
        return string(bytes.Trim(n[:], "\x00"))
}</span>

// NodeAnnouncement message is used to announce the presence of a Lightning
// node and also to signal that the node is accepting incoming connections.
// Each NodeAnnouncement authenticating the advertised information within the
// announcement via a signature using the advertised node pubkey.
type NodeAnnouncement struct {
        // Signature is used to prove the ownership of node id.
        Signature Sig

        // Features is the list of protocol features this node supports.
        Features *RawFeatureVector

        // Timestamp allows ordering in the case of multiple announcements.
        Timestamp uint32

        // NodeID is a public key which is used as node identification.
        NodeID [33]byte

        // RGBColor is used to customize their node's appearance in maps and
        // graphs
        RGBColor color.RGBA

        // Alias is used to customize their node's appearance in maps and
        // graphs
        Alias NodeAlias

        // Address includes two specification fields: 'ipv6' and 'port' on
        // which the node is accepting incoming connections.
        Addresses []net.Addr

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData []byte
}

// UpdateNodeAnnAddrs is a functional option that allows updating the addresses
// of the given node announcement.
func UpdateNodeAnnAddrs(addrs []net.Addr) func(*NodeAnnouncement) <span class="cov0" title="0">{
        return func(nodeAnn *NodeAnnouncement) </span><span class="cov0" title="0">{
                nodeAnn.Addresses = addrs
        }</span>
}

// A compile time check to ensure NodeAnnouncement implements the
// lnwire.Message interface.
var _ Message = (*NodeAnnouncement)(nil)

// Decode deserializes a serialized NodeAnnouncement stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) Decode(r io.Reader, pver uint32) error <span class="cov10" title="19">{
        err := ReadElements(r,
                &amp;a.Signature,
                &amp;a.Features,
                &amp;a.Timestamp,
                &amp;a.NodeID,
                &amp;a.RGBColor,
                &amp;a.Alias,
                &amp;a.Addresses,
        )
        if err != nil </span><span class="cov8" title="13">{
                return err
        }</span>

        // Now that we've read out all the fields that we explicitly know of,
        // we'll collect the remainder into the ExtraOpaqueData field. If there
        // aren't any bytes, then we'll snip off the slice to avoid carrying
        // around excess capacity.
        <span class="cov6" title="6">a.ExtraOpaqueData, err = ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="6">if len(a.ExtraOpaqueData) == 0 </span><span class="cov6" title="6">{
                a.ExtraOpaqueData = nil
        }</span>

        <span class="cov6" title="6">return nil</span>
}

// Encode serializes the target NodeAnnouncement into the passed io.Writer
// observing the protocol version specified.
//
func (a *NodeAnnouncement) Encode(w io.Writer, pver uint32) error <span class="cov4" title="3">{
        return WriteElements(w,
                a.Signature,
                a.Features,
                a.Timestamp,
                a.NodeID,
                a.RGBColor,
                a.Alias,
                a.Addresses,
                a.ExtraOpaqueData,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) MsgType() MessageType <span class="cov4" title="3">{
        return MsgNodeAnnouncement
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="19">{
        return 65533
}</span>

// DataToSign returns the part of the message that should be signed.
func (a *NodeAnnouncement) DataToSign() ([]byte, error) <span class="cov0" title="0">{

        // We should not include the signatures itself.
        var w bytes.Buffer
        err := WriteElements(&amp;w,
                a.Features,
                a.Timestamp,
                a.NodeID,
                a.RGBColor,
                a.Alias[:],
                a.Addresses,
                a.ExtraOpaqueData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return w.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package lnwire

import "testing"

// TestNodeAliasValidation tests that the NewNodeAlias method will only accept
// valid node announcements.
func TestNodeAliasValidation(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        var testCases = []struct {
                alias string
                valid bool
        }{
                // UTF-8 alias with valid length.
                {
                        alias: "meruem",
                        valid: true,
                },

                // UTF-8 alias with invalid length.
                {
                        alias: "p3kysxqr23swl33m6h5grmzddgw5nsgkky3g52zc6frpwz",
                        valid: false,
                },

                // String with non UTF-8 characters.
                {
                        alias: "\xE0\x80\x80",
                        valid: false,
                },
        }
        for i, testCase := range testCases </span><span class="cov0" title="0">{
                _, err := NewNodeAlias(testCase.alias)
                switch </span>{
                case err != nil &amp;&amp; testCase.valid:<span class="cov0" title="0">
                        t.Fatalf("#%v: alias should have been invalid", i)</span>

                case err == nil &amp;&amp; !testCase.valid:<span class="cov0" title="0">
                        t.Fatalf("#%v: invalid alias was missed", i)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package lnwire

import (
        "bufio"
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "io"

        "bytes"

        "github.com/davecgh/go-spew/spew"
        "github.com/go-errors/errors"
)

// FailureMessage represents the onion failure object identified by its unique
// failure code.
type FailureMessage interface {
        // Code returns a failure code describing the exact nature of the
        // error.
        Code() FailCode

        // Error returns a human readable string describing the error. With
        // this method, the FailureMessage interface meets the built-in error
        // interface.
        Error() string
}

// failureMessageLength is the size of the failure message plus the size of
// padding. The FailureMessage message should always be EXACTLY this size.
const failureMessageLength = 256

const (
        // FlagBadOnion error flag describes an unparsable, encrypted by
        // previous node.
        FlagBadOnion FailCode = 0x8000

        // FlagPerm error flag indicates a permanent failure.
        FlagPerm FailCode = 0x4000

        // FlagNode error flag indicates anode failure.
        FlagNode FailCode = 0x2000

        // FlagUpdate error flag indicates a new channel update is enclosed
        // within the error.
        FlagUpdate FailCode = 0x1000
)

// FailCode specifies the precise reason that an upstream HTLC was cancelled.
// Each UpdateFailHTLC message carries a FailCode which is to be passed
// backwards, encrypted at each step back to the source of the HTLC within the
// route.
type FailCode uint16

// The currently defined onion failure types within this current version of the
// Lightning protocol.
const (
        CodeNone                          FailCode = 0
        CodeInvalidRealm                           = FlagBadOnion | 1
        CodeTemporaryNodeFailure                   = FlagNode | 2
        CodePermanentNodeFailure                   = FlagPerm | FlagNode | 2
        CodeRequiredNodeFeatureMissing             = FlagPerm | FlagNode | 3
        CodeInvalidOnionVersion                    = FlagBadOnion | FlagPerm | 4
        CodeInvalidOnionHmac                       = FlagBadOnion | FlagPerm | 5
        CodeInvalidOnionKey                        = FlagBadOnion | FlagPerm | 6
        CodeTemporaryChannelFailure                = FlagUpdate | 7
        CodePermanentChannelFailure                = FlagPerm | 8
        CodeRequiredChannelFeatureMissing          = FlagPerm | 9
        CodeUnknownNextPeer                        = FlagPerm | 10
        CodeAmountBelowMinimum                     = FlagUpdate | 11
        CodeFeeInsufficient                        = FlagUpdate | 12
        CodeIncorrectCltvExpiry                    = FlagUpdate | 13
        CodeExpiryTooSoon                          = FlagUpdate | 14
        CodeChannelDisabled                        = FlagUpdate | 20
        CodeUnknownPaymentHash                     = FlagPerm | 15
        CodeIncorrectPaymentAmount                 = FlagPerm | 16
        CodeFinalExpiryTooSoon            FailCode = 17
        CodeFinalIncorrectCltvExpiry      FailCode = 18
        CodeFinalIncorrectHtlcAmount      FailCode = 19
        CodeExpiryTooFar                  FailCode = 21
)

// String returns the string representation of the failure code.
func (c FailCode) String() string <span class="cov0" title="0">{
        switch c </span>{
        case CodeInvalidRealm:<span class="cov0" title="0">
                return "InvalidRealm"</span>

        case CodeTemporaryNodeFailure:<span class="cov0" title="0">
                return "TemporaryNodeFailure"</span>

        case CodePermanentNodeFailure:<span class="cov0" title="0">
                return "PermanentNodeFailure"</span>

        case CodeRequiredNodeFeatureMissing:<span class="cov0" title="0">
                return "RequiredNodeFeatureMissing"</span>

        case CodeInvalidOnionVersion:<span class="cov0" title="0">
                return "InvalidOnionVersion"</span>

        case CodeInvalidOnionHmac:<span class="cov0" title="0">
                return "InvalidOnionHmac"</span>

        case CodeInvalidOnionKey:<span class="cov0" title="0">
                return "InvalidOnionKey"</span>

        case CodeTemporaryChannelFailure:<span class="cov0" title="0">
                return "TemporaryChannelFailure"</span>

        case CodePermanentChannelFailure:<span class="cov0" title="0">
                return "PermanentChannelFailure"</span>

        case CodeRequiredChannelFeatureMissing:<span class="cov0" title="0">
                return "RequiredChannelFeatureMissing"</span>

        case CodeUnknownNextPeer:<span class="cov0" title="0">
                return "UnknownNextPeer"</span>

        case CodeAmountBelowMinimum:<span class="cov0" title="0">
                return "AmountBelowMinimum"</span>

        case CodeFeeInsufficient:<span class="cov0" title="0">
                return "FeeInsufficient"</span>

        case CodeIncorrectCltvExpiry:<span class="cov0" title="0">
                return "IncorrectCltvExpiry"</span>

        case CodeExpiryTooSoon:<span class="cov0" title="0">
                return "ExpiryTooSoon"</span>

        case CodeChannelDisabled:<span class="cov0" title="0">
                return "ChannelDisabled"</span>

        case CodeUnknownPaymentHash:<span class="cov0" title="0">
                return "UnknownPaymentHash"</span>

        case CodeIncorrectPaymentAmount:<span class="cov0" title="0">
                return "IncorrectPaymentAmount"</span>

        case CodeFinalExpiryTooSoon:<span class="cov0" title="0">
                return "FinalExpiryTooSoon"</span>

        case CodeFinalIncorrectCltvExpiry:<span class="cov0" title="0">
                return "FinalIncorrectCltvExpiry"</span>

        case CodeFinalIncorrectHtlcAmount:<span class="cov0" title="0">
                return "FinalIncorrectHtlcAmount"</span>

        case CodeExpiryTooFar:<span class="cov0" title="0">
                return "ExpiryTooFar"</span>

        default:<span class="cov0" title="0">
                return "&lt;unknown&gt;"</span>
        }
}

// FailInvalidRealm is returned if the realm byte is unknown.
//
// NOTE: May be returned by any node in the payment route.
type FailInvalidRealm struct{}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailInvalidRealm) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailInvalidRealm) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidRealm
}</span>

// FailTemporaryNodeFailure is returned if an otherwise unspecified transient
// error occurs for the entire node.
//
// NOTE: May be returned by any node in the payment route.
type FailTemporaryNodeFailure struct{}

// Code returns the failure unique code.
// NOTE: Part of the FailureMessage interface.
func (f FailTemporaryNodeFailure) Code() FailCode <span class="cov0" title="0">{
        return CodeTemporaryNodeFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailTemporaryNodeFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailPermanentNodeFailure is returned if an otherwise unspecified permanent
// error occurs for the entire node.
//
// NOTE: May be returned by any node in the payment route.
type FailPermanentNodeFailure struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailPermanentNodeFailure) Code() FailCode <span class="cov0" title="0">{
        return CodePermanentNodeFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailPermanentNodeFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailRequiredNodeFeatureMissing is returned if a node has requirement
// advertised in its node_announcement features which were not present in the
// onion.
//
// NOTE: May be returned by any node in the payment route.
type FailRequiredNodeFeatureMissing struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailRequiredNodeFeatureMissing) Code() FailCode <span class="cov0" title="0">{
        return CodeRequiredNodeFeatureMissing
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailRequiredNodeFeatureMissing) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailPermanentChannelFailure is return if an otherwise unspecified permanent
// error occurs for the outgoing channel (eg. channel (recently).
//
// NOTE: May be returned by any node in the payment route.
type FailPermanentChannelFailure struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailPermanentChannelFailure) Code() FailCode <span class="cov0" title="0">{
        return CodePermanentChannelFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailPermanentChannelFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailRequiredChannelFeatureMissing is returned if the outgoing channel has a
// requirement advertised in its channel announcement features which were not
// present in the onion.
//
// NOTE: May only be returned by intermediate nodes.
type FailRequiredChannelFeatureMissing struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailRequiredChannelFeatureMissing) Code() FailCode <span class="cov0" title="0">{
        return CodeRequiredChannelFeatureMissing
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailRequiredChannelFeatureMissing) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailUnknownNextPeer is returned if the next peer specified by the onion is
// not known.
//
// NOTE: May only be returned by intermediate nodes.
type FailUnknownNextPeer struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailUnknownNextPeer) Code() FailCode <span class="cov0" title="0">{
        return CodeUnknownNextPeer
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailUnknownNextPeer) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailUnknownPaymentHash is returned If the payment hash has already been
// paid, the final node MAY treat the payment hash as unknown, or may succeed
// in accepting the HTLC. If the payment hash is unknown, the final node MUST
// fail the HTLC.
//
// NOTE: May only be returned by the final node in the path.
type FailUnknownPaymentHash struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailUnknownPaymentHash) Code() FailCode <span class="cov0" title="0">{
        return CodeUnknownPaymentHash
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailUnknownPaymentHash) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailIncorrectPaymentAmount is returned if the amount paid is less than the
// amount expected, the final node MUST fail the HTLC. If the amount paid is
// more than twice the amount expected, the final node SHOULD fail the HTLC.
// This allows the sender to reduce information leakage by altering the amount,
// without allowing accidental gross overpayment.
//
// NOTE: May only be returned by the final node in the path.
type FailIncorrectPaymentAmount struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailIncorrectPaymentAmount) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectPaymentAmount
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailIncorrectPaymentAmount) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailFinalExpiryTooSoon is returned if the cltv_expiry is too low, the final
// node MUST fail the HTLC.
//
// NOTE: May only be returned by the final node in the path.
type FailFinalExpiryTooSoon struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailFinalExpiryTooSoon) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalExpiryTooSoon
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailFinalExpiryTooSoon) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailInvalidOnionVersion is returned if the onion version byte is unknown.
//
// NOTE: May be returned only by intermediate nodes.
type FailInvalidOnionVersion struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailInvalidOnionVersion) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionVersion(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// NewInvalidOnionVersion creates new instance of the FailInvalidOnionVersion.
func NewInvalidOnionVersion(onion []byte) *FailInvalidOnionVersion <span class="cov1" title="1">{
        return &amp;FailInvalidOnionVersion{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionVersion) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionVersion
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionVersion) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionVersion) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.OnionSHA256[:])
}</span>

// FailInvalidOnionHmac is return if the onion HMAC is incorrect.
//
// NOTE: May only be returned by intermediate nodes.
type FailInvalidOnionHmac struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// NewInvalidOnionHmac creates new instance of the FailInvalidOnionHmac.
func NewInvalidOnionHmac(onion []byte) *FailInvalidOnionHmac <span class="cov1" title="1">{
        return &amp;FailInvalidOnionHmac{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionHmac) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionHmac
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionHmac) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionHmac) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.OnionSHA256[:])
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailInvalidOnionHmac) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionHMAC(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// FailInvalidOnionKey is return if the ephemeral key in the onion is
// unparsable.
//
// NOTE: May only be returned by intermediate nodes.
type FailInvalidOnionKey struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// NewInvalidOnionKey creates new instance of the FailInvalidOnionKey.
func NewInvalidOnionKey(onion []byte) *FailInvalidOnionKey <span class="cov1" title="1">{
        return &amp;FailInvalidOnionKey{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionKey) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionKey
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionKey) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionKey) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.OnionSHA256[:])
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailInvalidOnionKey) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionKey(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// parseChannelUpdateCompatabilityMode will attempt to parse a channel updated
// encoded into an onion error payload in two ways. First, we'll try the
// compatibility oriented version wherein we'll _skip_ the length prefixing on
// the channel update message. Older versions of c-lighting do this so we'll
// attempt to parse these messages in order to retain compatibility. If we're
// unable to pull out a fully valid version, then we'll fall back to the
// regular parsing mechanism which includes the length prefix an NO type byte.
func parseChannelUpdateCompatabilityMode(r *bufio.Reader,
        chanUpdate *ChannelUpdate, pver uint32) error <span class="cov0" title="0">{

        // We'll peek out two bytes from the buffer without advancing the
        // buffer so we can decide how to parse the remainder of it.
        maybeTypeBytes, err := r.Peek(2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Some nodes well prefix an additional set of bytes in front of their
        // channel updates. These bytes will _almost_ always be 258 or the type
        // of the ChannelUpdate message.
        <span class="cov0" title="0">typeInt := binary.BigEndian.Uint16(maybeTypeBytes)
        if typeInt == MsgChannelUpdate </span><span class="cov0" title="0">{
                // At this point it's likely the case that this is a channel
                // update message with its type prefixed, so we'll snip off the
                // first two bytes and parse it as normal.
                var throwAwayTypeBytes [2]byte
                _, err := r.Read(throwAwayTypeBytes[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // At this pint, we've either decided to keep the entire thing, or snip
        // off the first two bytes. In either case, we can just read it as
        // normal.
        <span class="cov0" title="0">return chanUpdate.Decode(r, pver)</span>
}

// FailTemporaryChannelFailure is if an otherwise unspecified transient error
// occurs for the outgoing channel (eg. channel capacity reached, too many
// in-flight htlcs)
//
// NOTE: May only be returned by intermediate nodes.
type FailTemporaryChannelFailure struct {
        // Update is used to update information about state of the channel
        // which caused the failure.
        //
        // NOTE: This field is optional.
        Update *ChannelUpdate
}

// NewTemporaryChannelFailure creates new instance of the FailTemporaryChannelFailure.
func NewTemporaryChannelFailure(update *ChannelUpdate) *FailTemporaryChannelFailure <span class="cov10" title="2">{
        return &amp;FailTemporaryChannelFailure{Update: update}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailTemporaryChannelFailure) Code() FailCode <span class="cov0" title="0">{
        return CodeTemporaryChannelFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailTemporaryChannelFailure) Error() string <span class="cov0" title="0">{
        if f.Update == nil </span><span class="cov0" title="0">{
                return f.Code().String()
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("TemporaryChannelFailure(update=%v)",
                spew.Sdump(f.Update))</span>
}

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailTemporaryChannelFailure) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var length uint16
        err := ReadElement(r, &amp;length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if length != 0 </span><span class="cov0" title="0">{
                f.Update = &amp;ChannelUpdate{}
                return parseChannelUpdateCompatabilityMode(
                        bufio.NewReader(r), f.Update, pver,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailTemporaryChannelFailure) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        var payload []byte
        if f.Update != nil </span><span class="cov0" title="0">{
                var bw bytes.Buffer
                if err := f.Update.Encode(&amp;bw, pver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">payload = bw.Bytes()</span>
        }

        <span class="cov0" title="0">if err := WriteElement(w, uint16(len(payload))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err := w.Write(payload)
        return err</span>
}

// FailAmountBelowMinimum is returned if the HTLC does not reach the current
// minimum amount, we tell them the amount of the incoming HTLC and the current
// channel setting for the outgoing channel.
//
// NOTE: May only be returned by the intermediate nodes in the path.
type FailAmountBelowMinimum struct {
        // HtlcMsat is the wrong amount of the incoming HTLC.
        HtlcMsat MilliSatoshi

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewAmountBelowMinimum creates new instance of the FailAmountBelowMinimum.
func NewAmountBelowMinimum(htlcMsat MilliSatoshi,
        update ChannelUpdate) *FailAmountBelowMinimum <span class="cov1" title="1">{

        return &amp;FailAmountBelowMinimum{
                HtlcMsat: htlcMsat,
                Update:   update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailAmountBelowMinimum) Code() FailCode <span class="cov0" title="0">{
        return CodeAmountBelowMinimum
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailAmountBelowMinimum) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("AmountBelowMinimum(amt=%v, update=%v", f.HtlcMsat,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailAmountBelowMinimum) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailAmountBelowMinimum) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailFeeInsufficient is returned if the HTLC does not pay sufficient fee, we
// tell them the amount of the incoming HTLC and the current channel setting
// for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailFeeInsufficient struct {
        // HtlcMsat is the wrong amount of the incoming HTLC.
        HtlcMsat MilliSatoshi

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewFeeInsufficient creates new instance of the FailFeeInsufficient.
func NewFeeInsufficient(htlcMsat MilliSatoshi,
        update ChannelUpdate) *FailFeeInsufficient <span class="cov1" title="1">{
        return &amp;FailFeeInsufficient{
                HtlcMsat: htlcMsat,
                Update:   update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFeeInsufficient) Code() FailCode <span class="cov0" title="0">{
        return CodeFeeInsufficient
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailFeeInsufficient) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FeeInsufficient(htlc_amt==%v, update=%v", f.HtlcMsat,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFeeInsufficient) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFeeInsufficient) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailIncorrectCltvExpiry is returned if outgoing cltv value does not match
// the update add htlc's cltv expiry minus cltv expiry delta for the outgoing
// channel, we tell them the cltv expiry and the current channel setting for
// the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailIncorrectCltvExpiry struct {
        // CltvExpiry is the wrong absolute timeout in blocks, after which
        // outgoing HTLC expires.
        CltvExpiry uint32

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewIncorrectCltvExpiry creates new instance of the FailIncorrectCltvExpiry.
func NewIncorrectCltvExpiry(cltvExpiry uint32,
        update ChannelUpdate) *FailIncorrectCltvExpiry <span class="cov1" title="1">{

        return &amp;FailIncorrectCltvExpiry{
                CltvExpiry: cltvExpiry,
                Update:     update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectCltvExpiry) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectCltvExpiry
}</span>

func (f *FailIncorrectCltvExpiry) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("IncorrectCltvExpiry(expiry=%v, update=%v",
                f.CltvExpiry, spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectCltvExpiry) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.CltvExpiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectCltvExpiry) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.CltvExpiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailExpiryTooSoon is returned if the ctlv-expiry is too near, we tell them
// the current channel setting for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailExpiryTooSoon struct {
        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewExpiryTooSoon creates new instance of the FailExpiryTooSoon.
func NewExpiryTooSoon(update ChannelUpdate) *FailExpiryTooSoon <span class="cov1" title="1">{
        return &amp;FailExpiryTooSoon{
                Update: update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailExpiryTooSoon) Code() FailCode <span class="cov0" title="0">{
        return CodeExpiryTooSoon
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailExpiryTooSoon) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ExpiryTooSoon(update=%v", spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from l stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailExpiryTooSoon) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailExpiryTooSoon) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)
}</span>

// FailChannelDisabled is returned if the channel is disabled, we tell them the
// current channel setting for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailChannelDisabled struct {
        // Flags least-significant bit must be set to 0 if the creating node
        // corresponds to the first node in the previously sent channel
        // announcement and 1 otherwise.
        Flags uint16

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate
}

// NewChannelDisabled creates new instance of the FailChannelDisabled.
func NewChannelDisabled(flags uint16, update ChannelUpdate) *FailChannelDisabled <span class="cov1" title="1">{
        return &amp;FailChannelDisabled{
                Flags:  flags,
                Update: update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailChannelDisabled) Code() FailCode <span class="cov0" title="0">{
        return CodeChannelDisabled
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailChannelDisabled) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ChannelDisabled(flags=%v, update=%v", f.Flags,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailChannelDisabled) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate{}
        return parseChannelUpdateCompatabilityMode(
                bufio.NewReader(r), &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailChannelDisabled) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteElement(w, f.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailFinalIncorrectCltvExpiry is returned if the outgoing_cltv_value does not
// match the ctlv_expiry of the HTLC at the final hop.
//
// NOTE: might be returned by final node only.
type FailFinalIncorrectCltvExpiry struct {
        // CltvExpiry is the wrong absolute timeout in blocks, after which
        // outgoing HTLC expires.
        CltvExpiry uint32
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailFinalIncorrectCltvExpiry) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FinalIncorrectCltvExpiry(expiry=%v)", f.CltvExpiry)
}</span>

// NewFinalIncorrectCltvExpiry creates new instance of the
// FailFinalIncorrectCltvExpiry.
func NewFinalIncorrectCltvExpiry(cltvExpiry uint32) *FailFinalIncorrectCltvExpiry <span class="cov1" title="1">{
        return &amp;FailFinalIncorrectCltvExpiry{
                CltvExpiry: cltvExpiry,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalIncorrectCltvExpiry) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalIncorrectCltvExpiry
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectCltvExpiry) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, &amp;f.CltvExpiry)
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectCltvExpiry) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.CltvExpiry)
}</span>

// FailFinalIncorrectHtlcAmount is returned if the amt_to_forward is higher
// than incoming_htlc_amt of the HTLC at the final hop.
//
// NOTE: May only be returned by the final node.
type FailFinalIncorrectHtlcAmount struct {
        // IncomingHTLCAmount is the wrong forwarded htlc amount.
        IncomingHTLCAmount MilliSatoshi
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailFinalIncorrectHtlcAmount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FinalIncorrectHtlcAmount(amt=%v)",
                f.IncomingHTLCAmount)
}</span>

// NewFinalIncorrectHtlcAmount creates new instance of the
// FailFinalIncorrectHtlcAmount.
func NewFinalIncorrectHtlcAmount(amount MilliSatoshi) *FailFinalIncorrectHtlcAmount <span class="cov1" title="1">{
        return &amp;FailFinalIncorrectHtlcAmount{
                IncomingHTLCAmount: amount,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalIncorrectHtlcAmount) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalIncorrectHtlcAmount
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectHtlcAmount) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, &amp;f.IncomingHTLCAmount)
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectHtlcAmount) Encode(w io.Writer, pver uint32) error <span class="cov0" title="0">{
        return WriteElement(w, f.IncomingHTLCAmount)
}</span>

// FailExpiryTooFar is returned if the CLTV expiry in the HTLC is too far in the
// future.
//
// NOTE: May be returned by any node in the payment route.
type FailExpiryTooFar struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f FailExpiryTooFar) Code() FailCode <span class="cov0" title="0">{
        return CodeExpiryTooFar
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f FailExpiryTooFar) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// DecodeFailure decodes, validates, and parses the lnwire onion failure, for
// the provided protocol version.
func DecodeFailure(r io.Reader, pver uint32) (FailureMessage, error) <span class="cov0" title="0">{
        // First, we'll parse out the encapsulated failure message itself. This
        // is a 2 byte length followed by the payload itself.
        var failureLength uint16
        if err := ReadElement(r, &amp;failureLength); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read error len: %v", err)
        }</span>
        <span class="cov0" title="0">if failureLength &gt; failureMessageLength </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure message is too "+
                        "long: %v", failureLength)
        }</span>
        <span class="cov0" title="0">failureData := make([]byte, failureLength)
        if _, err := io.ReadFull(r, failureData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to full read payload of "+
                        "%v: %v", failureLength, err)
        }</span>

        <span class="cov0" title="0">dataReader := bytes.NewReader(failureData)

        // Once we have the failure data, we can obtain the failure code from
        // the first two bytes of the buffer.
        var codeBytes [2]byte
        if _, err := io.ReadFull(dataReader, codeBytes[:]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read failure code: %v", err)
        }</span>
        <span class="cov0" title="0">failCode := FailCode(binary.BigEndian.Uint16(codeBytes[:]))

        // Create the empty failure by given code and populate the failure with
        // additional data if needed.
        failure, err := makeEmptyOnionError(failCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to make empty error: %v", err)
        }</span>

        // Finally, if this failure has a payload, then we'll read that now as
        // well.
        <span class="cov0" title="0">switch f := failure.(type) </span>{
        case Serializable:<span class="cov0" title="0">
                if err := f.Decode(dataReader, pver); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to decode error "+
                                "update (type=%T, len_bytes=%v, bytes=%x): %v",
                                failure, failureLength, failureData[:], err)
                }</span>
        }

        <span class="cov0" title="0">return failure, nil</span>
}

// EncodeFailure encodes, including the necessary onion failure header
// information.
func EncodeFailure(w io.Writer, failure FailureMessage, pver uint32) error <span class="cov0" title="0">{
        var failureMessageBuffer bytes.Buffer

        // First, we'll write out the error code itself into the failure
        // buffer.
        var codeBytes [2]byte
        code := uint16(failure.Code())
        binary.BigEndian.PutUint16(codeBytes[:], code)
        _, err := failureMessageBuffer.Write(codeBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next, some message have an additional message payload, if this is
        // one of those types, then we'll also encode the error payload as
        // well.
        <span class="cov0" title="0">switch failure := failure.(type) </span>{
        case Serializable:<span class="cov0" title="0">
                if err := failure.Encode(&amp;failureMessageBuffer, pver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // The combined size of this message must be below the max allowed
        // failure message length.
        <span class="cov0" title="0">failureMessage := failureMessageBuffer.Bytes()
        if len(failureMessage) &gt; failureMessageLength </span><span class="cov0" title="0">{
                return fmt.Errorf("failure message exceed max "+
                        "available size: %v", len(failureMessage))
        }</span>

        // Finally, we'll add some padding in order to ensure that all failure
        // messages are fixed size.
        <span class="cov0" title="0">pad := make([]byte, failureMessageLength-len(failureMessage))

        return WriteElements(w,
                uint16(len(failureMessage)),
                failureMessage,
                uint16(len(pad)),
                pad,
        )</span>
}

// makeEmptyOnionError creates a new empty onion error  of the proper concrete
// type based on the passed failure code.
func makeEmptyOnionError(code FailCode) (FailureMessage, error) <span class="cov0" title="0">{
        switch code </span>{
        case CodeInvalidRealm:<span class="cov0" title="0">
                return &amp;FailInvalidRealm{}, nil</span>

        case CodeTemporaryNodeFailure:<span class="cov0" title="0">
                return &amp;FailTemporaryNodeFailure{}, nil</span>

        case CodePermanentNodeFailure:<span class="cov0" title="0">
                return &amp;FailPermanentNodeFailure{}, nil</span>

        case CodeRequiredNodeFeatureMissing:<span class="cov0" title="0">
                return &amp;FailRequiredNodeFeatureMissing{}, nil</span>

        case CodePermanentChannelFailure:<span class="cov0" title="0">
                return &amp;FailPermanentChannelFailure{}, nil</span>

        case CodeRequiredChannelFeatureMissing:<span class="cov0" title="0">
                return &amp;FailRequiredChannelFeatureMissing{}, nil</span>

        case CodeUnknownNextPeer:<span class="cov0" title="0">
                return &amp;FailUnknownNextPeer{}, nil</span>

        case CodeUnknownPaymentHash:<span class="cov0" title="0">
                return &amp;FailUnknownPaymentHash{}, nil</span>

        case CodeIncorrectPaymentAmount:<span class="cov0" title="0">
                return &amp;FailIncorrectPaymentAmount{}, nil</span>

        case CodeFinalExpiryTooSoon:<span class="cov0" title="0">
                return &amp;FailFinalExpiryTooSoon{}, nil</span>

        case CodeInvalidOnionVersion:<span class="cov0" title="0">
                return &amp;FailInvalidOnionVersion{}, nil</span>

        case CodeInvalidOnionHmac:<span class="cov0" title="0">
                return &amp;FailInvalidOnionHmac{}, nil</span>

        case CodeInvalidOnionKey:<span class="cov0" title="0">
                return &amp;FailInvalidOnionKey{}, nil</span>

        case CodeTemporaryChannelFailure:<span class="cov0" title="0">
                return &amp;FailTemporaryChannelFailure{}, nil</span>

        case CodeAmountBelowMinimum:<span class="cov0" title="0">
                return &amp;FailAmountBelowMinimum{}, nil</span>

        case CodeFeeInsufficient:<span class="cov0" title="0">
                return &amp;FailFeeInsufficient{}, nil</span>

        case CodeIncorrectCltvExpiry:<span class="cov0" title="0">
                return &amp;FailIncorrectCltvExpiry{}, nil</span>

        case CodeExpiryTooSoon:<span class="cov0" title="0">
                return &amp;FailExpiryTooSoon{}, nil</span>

        case CodeChannelDisabled:<span class="cov0" title="0">
                return &amp;FailChannelDisabled{}, nil</span>

        case CodeFinalIncorrectCltvExpiry:<span class="cov0" title="0">
                return &amp;FailFinalIncorrectCltvExpiry{}, nil</span>

        case CodeFinalIncorrectHtlcAmount:<span class="cov0" title="0">
                return &amp;FailFinalIncorrectHtlcAmount{}, nil</span>

        case CodeExpiryTooFar:<span class="cov0" title="0">
                return &amp;FailExpiryTooFar{}, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown error code: %v", code)</span>
        }
}

// writeOnionErrorChanUpdate writes out a ChannelUpdate using the onion error
// format. The format is that we first write out the true serialized length of
// the channel update, followed by the serialized channel update itself.
func writeOnionErrorChanUpdate(w io.Writer, chanUpdate *ChannelUpdate,
        pver uint32) error <span class="cov0" title="0">{

        // First, we encode the channel update in a temporary buffer in order
        // to get the exact serialized size.
        var b bytes.Buffer
        if err := chanUpdate.Encode(&amp;b, pver); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now that we know the size, we can write the length out in the main
        // writer.
        <span class="cov0" title="0">updateLen := b.Len()
        if err := WriteElement(w, uint16(updateLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the length written, we'll then write out the serialized channel
        // update.
        <span class="cov0" title="0">if _, err := w.Write(b.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package lnwire

import (
        "bufio"
        "bytes"
        "encoding/binary"
        "reflect"
        "testing"

        "github.com/davecgh/go-spew/spew"
)

var (
        testOnionHash     = []byte{}
        testAmount        = MilliSatoshi(1)
        testCtlvExpiry    = uint32(2)
        testFlags         = uint16(2)
        sig, _            = NewSigFromSignature(testSig)
        testChannelUpdate = ChannelUpdate{
                Signature:      sig,
                ShortChannelID: NewShortChanIDFromInt(1),
                Timestamp:      1,
                Flags:          1,
        }
)

var onionFailures = []FailureMessage{
        &amp;FailInvalidRealm{},
        &amp;FailTemporaryNodeFailure{},
        &amp;FailPermanentNodeFailure{},
        &amp;FailRequiredNodeFeatureMissing{},
        &amp;FailPermanentChannelFailure{},
        &amp;FailRequiredChannelFeatureMissing{},
        &amp;FailUnknownNextPeer{},
        &amp;FailUnknownPaymentHash{},
        &amp;FailIncorrectPaymentAmount{},
        &amp;FailFinalExpiryTooSoon{},

        NewInvalidOnionVersion(testOnionHash),
        NewInvalidOnionHmac(testOnionHash),
        NewInvalidOnionKey(testOnionHash),
        NewTemporaryChannelFailure(&amp;testChannelUpdate),
        NewTemporaryChannelFailure(nil),
        NewAmountBelowMinimum(testAmount, testChannelUpdate),
        NewFeeInsufficient(testAmount, testChannelUpdate),
        NewIncorrectCltvExpiry(testCtlvExpiry, testChannelUpdate),
        NewExpiryTooSoon(testChannelUpdate),
        NewChannelDisabled(testFlags, testChannelUpdate),
        NewFinalIncorrectCltvExpiry(testCtlvExpiry),
        NewFinalIncorrectHtlcAmount(testAmount),
}

// TestEncodeDecodeCode tests the ability of onion errors to be properly encoded
// and decoded.
func TestEncodeDecodeCode(t *testing.T) <span class="cov0" title="0">{
        for _, failure1 := range onionFailures </span><span class="cov0" title="0">{
                var b bytes.Buffer

                if err := EncodeFailure(&amp;b, failure1, 0); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("unable to encode failure code(%v): %v",
                                failure1.Code(), err)
                }</span>

                <span class="cov0" title="0">failure2, err := DecodeFailure(&amp;b, 0)
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("unable to decode failure code(%v): %v",
                                failure1.Code(), err)
                }</span>

                <span class="cov0" title="0">if !reflect.DeepEqual(failure1, failure2) </span><span class="cov0" title="0">{
                        t.Fatalf("expected %v, got %v", spew.Sdump(failure1),
                                spew.Sdump(failure2))
                }</span>
        }
}

// TestChannelUpdateCompatabilityParsing tests that we're able to properly read
// out channel update messages encoded in an onion error payload that was
// written in the legacy (type prefixed) format.
func TestChannelUpdateCompatabilityParsing(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        // We'll start by taking out test channel update, and encoding it into
        // a set of raw bytes.
        var b bytes.Buffer
        if err := testChannelUpdate.Encode(&amp;b, 0); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to encode chan update: %v", err)
        }</span>

        // Now that we have the set of bytes encoded, we'll ensure that we're
        // able to decode it using our compatibility method, as it's a regular
        // encoded channel update message.
        <span class="cov0" title="0">var newChanUpdate ChannelUpdate
        err := parseChannelUpdateCompatabilityMode(
                bufio.NewReader(&amp;b), &amp;newChanUpdate, 0,
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to parse channel update: %v", err)
        }</span>

        // At this point, we'll ensure that we get the exact same failure out
        // on the other side.
        <span class="cov0" title="0">if !reflect.DeepEqual(testChannelUpdate, newChanUpdate) </span><span class="cov0" title="0">{
                t.Fatalf("mismatched channel updates: %v", err)
        }</span>

        // We'll now reset then re-encoded the same channel update to try it in
        // the proper compatible mode.
        <span class="cov0" title="0">b.Reset()

        // Before we encode the update itself, we'll also write out the 2-byte
        // type in order to simulate the compat mode.
        var tByte [2]byte
        binary.BigEndian.PutUint16(tByte[:], MsgChannelUpdate)
        b.Write(tByte[:])
        if err := testChannelUpdate.Encode(&amp;b, 0); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to encode chan update: %v", err)
        }</span>

        // We should be able to properly parse the encoded channel update
        // message even with the extra two bytes.
        <span class="cov0" title="0">var newChanUpdate2 ChannelUpdate
        err = parseChannelUpdateCompatabilityMode(
                bufio.NewReader(&amp;b), &amp;newChanUpdate2, 0,
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to parse channel update: %v", err)
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(newChanUpdate2, newChanUpdate) </span><span class="cov0" title="0">{
                t.Fatalf("mismatched channel updates: %v", err)
        }</span>
}

// TestWriteOnionErrorChanUpdate tests that we write an exact size for the
// channel update in order to be more compliant with the parsers of other
// implementations.
func TestWriteOnionErrorChanUpdate(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        // First, we'll write out the raw channel update so we can obtain the
        // raw serialized length.
        var b bytes.Buffer
        update := testChannelUpdate
        if err := update.Encode(&amp;b, 0); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to write update: %v", err)
        }</span>
        <span class="cov0" title="0">trueUpdateLength := b.Len()

        // Next, we'll use the function to encode the update as we would in a
        // onion error message.
        var errorBuf bytes.Buffer
        err := writeOnionErrorChanUpdate(&amp;errorBuf, &amp;update, 0)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to encode onion error: %v", err)
        }</span>

        // Finally, read the length encoded and ensure that it matches the raw
        // length.
        <span class="cov0" title="0">var encodedLen uint16
        if err := ReadElement(&amp;errorBuf, &amp;encodedLen); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unable to read len: %v", err)
        }</span>
        <span class="cov0" title="0">if uint16(trueUpdateLength) != encodedLen </span><span class="cov0" title="0">{
                t.Fatalf("wrong length written: expected %v, got %v",
                        trueUpdateLength, encodedLen)
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcutil"
)

// FundingFlag represents the possible bit mask values for the ChannelFlags
// field within the OpenChannel struct.
type FundingFlag uint8

const (
        // FFAnnounceChannel is a FundingFlag that when set, indicates the
        // initiator of a funding flow wishes to announce the channel to the
        // greater network.
        FFAnnounceChannel FundingFlag = 1 &lt;&lt; iota
)

// OpenChannel is the message Alice sends to Bob if we should like to create a
// channel with Bob where she's the sole provider of funds to the channel.
// Single funder channels simplify the initial funding workflow, are supported
// by nodes backed by SPV Bitcoin clients, and have a simpler security models
// than dual funded channels.
type OpenChannel struct {
        // ChainHash is the target chain that the initiator wishes to open a
        // channel within.
        ChainHash chainhash.Hash

        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // FundingAmount is the amount of satoshis that the initiator of the
        // channel wishes to use as the total capacity of the channel. The
        // initial balance of the funding will be this value minus the push
        // amount (if set).
        FundingAmount btcutil.Amount

        // PushAmount is the value that the initiating party wishes to "push"
        // to the responding as part of the first commitment state. If the
        // responder accepts, then this will be their initial balance.
        PushAmount MilliSatoshi

        // DustLimit is the specific dust limit the sender of this message
        // would like enforced on their version of the commitment transaction.
        // Any output below this value will be "trimmed" from the commitment
        // transaction, with the amount of the HTLC going to dust.
        DustLimit btcutil.Amount

        // MaxValueInFlight represents the maximum amount of coins that can be
        // pending within the channel at any given time. If the amount of funds
        // in limbo exceeds this amount, then the channel will be failed.
        MaxValueInFlight MilliSatoshi

        // ChannelReserve is the amount of BTC that the receiving party MUST
        // maintain a balance above at all times. This is a safety mechanism to
        // ensure that both sides always have skin in the game during the
        // channel's lifetime.
        ChannelReserve btcutil.Amount

        // HtlcMinimum is the smallest HTLC that the sender of this message
        // will accept.
        HtlcMinimum MilliSatoshi

        // FeePerKiloWeight is the initial fee rate that the initiator suggests
        // for both commitment transaction. This value is expressed in sat per
        // kilo-weight.
        //
        // TODO(halseth): make SatPerKWeight when fee estimation is in own
        // package. Currently this will cause an import cycle.
        FeePerKiloWeight uint32

        // CsvDelay is the number of blocks to use for the relative time lock
        // in the pay-to-self output of both commitment transactions.
        CsvDelay uint16

        // MaxAcceptedHTLCs is the total number of incoming HTLC's that the
        // sender of this channel will accept.
        MaxAcceptedHTLCs uint16

        // FundingKey is the key that should be used on behalf of the sender
        // within the 2-of-2 multi-sig output that it contained within the
        // funding transaction.
        FundingKey *btcec.PublicKey

        // RevocationPoint is the base revocation point for the sending party.
        // Any commitment transaction belonging to the receiver of this message
        // should use this key and their per-commitment point to derive the
        // revocation key for the commitment transaction.
        RevocationPoint *btcec.PublicKey

        // PaymentPoint is the base payment point for the sending party. This
        // key should be combined with the per commitment point for a
        // particular commitment state in order to create the key that should
        // be used in any output that pays directly to the sending party, and
        // also within the HTLC covenant transactions.
        PaymentPoint *btcec.PublicKey

        // DelayedPaymentPoint is the delay point for the sending party. This
        // key should be combined with the per commitment point to derive the
        // keys that are used in outputs of the sender's commitment transaction
        // where they claim funds.
        DelayedPaymentPoint *btcec.PublicKey

        // HtlcPoint is the base point used to derive the set of keys for this
        // party that will be used within the HTLC public key scripts.  This
        // value is combined with the receiver's revocation base point in order
        // to derive the keys that are used within HTLC scripts.
        HtlcPoint *btcec.PublicKey

        // FirstCommitmentPoint is the first commitment point for the sending
        // party. This value should be combined with the receiver's revocation
        // base point in order to derive the revocation keys that are placed
        // within the commitment transaction of the sender.
        FirstCommitmentPoint *btcec.PublicKey

        // ChannelFlags is a bit-field which allows the initiator of the
        // channel to specify further behavior surrounding the channel.
        // Currently, the least significant bit of this bit field indicates the
        // initiator of the channel wishes to advertise this channel publicly.
        ChannelFlags FundingFlag
}

// A compile time check to ensure OpenChannel implements the lnwire.Message
// interface.
var _ Message = (*OpenChannel)(nil)

// Encode serializes the target OpenChannel into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) Encode(w io.Writer, pver uint32) error <span class="cov7" title="10">{
        return WriteElements(w,
                o.ChainHash[:],
                o.PendingChannelID[:],
                o.FundingAmount,
                o.PushAmount,
                o.DustLimit,
                o.MaxValueInFlight,
                o.ChannelReserve,
                o.HtlcMinimum,
                o.FeePerKiloWeight,
                o.CsvDelay,
                o.MaxAcceptedHTLCs,
                o.FundingKey,
                o.RevocationPoint,
                o.PaymentPoint,
                o.DelayedPaymentPoint,
                o.HtlcPoint,
                o.FirstCommitmentPoint,
                o.ChannelFlags,
        )
}</span>

// Decode deserializes the serialized OpenChannel stored in the passed
// io.Reader into the target OpenChannel using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) Decode(r io.Reader, pver uint32) error <span class="cov10" title="22">{
        return ReadElements(r,
                o.ChainHash[:],
                o.PendingChannelID[:],
                &amp;o.FundingAmount,
                &amp;o.PushAmount,
                &amp;o.DustLimit,
                &amp;o.MaxValueInFlight,
                &amp;o.ChannelReserve,
                &amp;o.HtlcMinimum,
                &amp;o.FeePerKiloWeight,
                &amp;o.CsvDelay,
                &amp;o.MaxAcceptedHTLCs,
                &amp;o.FundingKey,
                &amp;o.RevocationPoint,
                &amp;o.PaymentPoint,
                &amp;o.DelayedPaymentPoint,
                &amp;o.HtlcPoint,
                &amp;o.FirstCommitmentPoint,
                &amp;o.ChannelFlags,
        )
}</span>

// MsgType returns the MessageType code which uniquely identifies this message
// as an OpenChannel on the wire.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) MsgType() MessageType <span class="cov7" title="10">{
        return MsgOpenChannel
}</span>

// MaxPayloadLength returns the maximum allowed payload length for a
// OpenChannel message.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) MaxPayloadLength(uint32) uint32 <span class="cov10" title="22">{
        // (32 * 2) + (8 * 6) + (4 * 1) + (2 * 2) + (33 * 6) + 1
        return 319
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package lnwire

import "io"

// PingPayload is a set of opaque bytes used to pad out a ping message.
type PingPayload []byte

// Ping defines a message which is sent by peers periodically to determine if
// the connection is still valid. Each ping message carries the number of bytes
// to pad the pong response with, and also a number of bytes to be ignored at
// the end of the ping message (which is padding).
type Ping struct {
        // NumPongBytes is the number of bytes the pong response to this
        // message should carry.
        NumPongBytes uint16

        // PaddingBytes is a set of opaque bytes used to pad out this ping
        // message. Using this field in conjunction to the one above, it's
        // possible for node to generate fake cover traffic.
        PaddingBytes PingPayload
}

// NewPing returns a new Ping message.
func NewPing(numBytes uint16) *Ping <span class="cov0" title="0">{
        return &amp;Ping{
                NumPongBytes: numBytes,
        }
}</span>

// A compile time check to ensure Ping implements the lnwire.Message interface.
var _ Message = (*Ping)(nil)

// Decode deserializes a serialized Ping message stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Ping) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;p.NumPongBytes,
                &amp;p.PaddingBytes)
}</span>

// Encode serializes the target Ping into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (p *Ping) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                p.NumPongBytes,
                p.PaddingBytes)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (p *Ping) MsgType() MessageType <span class="cov1" title="1">{
        return MsgPing
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a Ping
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p Ping) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        return 65532
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package lnwire

import "io"

// PongPayload is a set of opaque bytes sent in response to a ping message.
type PongPayload []byte

// Pong defines a message which is the direct response to a received Ping
// message. A Pong reply indicates that a connection is still active. The Pong
// reply to a Ping message should contain the nonce carried in the original
// Pong message.
type Pong struct {
        // PongBytes is a set of opaque bytes that corresponds to the
        // NumPongBytes defined in the ping message that this pong is
        // replying to.
        PongBytes PongPayload
}

// NewPong returns a new Pong message.
func NewPong(pongBytes []byte) *Pong <span class="cov0" title="0">{
        return &amp;Pong{
                PongBytes: pongBytes,
        }
}</span>

// A compile time check to ensure Pong implements the lnwire.Message interface.
var _ Message = (*Pong)(nil)

// Decode deserializes a serialized Pong message stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Pong) Decode(r io.Reader, pver uint32) error <span class="cov10" title="4">{
        return ReadElements(r,
                &amp;p.PongBytes,
        )
}</span>

// Encode serializes the target Pong into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (p *Pong) Encode(w io.Writer, pver uint32) error <span class="cov5" title="2">{
        return WriteElements(w,
                p.PongBytes,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (p *Pong) MsgType() MessageType <span class="cov5" title="2">{
        return MsgPong
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a Pong
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Pong) MaxPayloadLength(uint32) uint32 <span class="cov10" title="4">{
        return 65532
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// QueryChannelRange is a message sent by a node in order to query the
// receiving node of the set of open channel they know of with short channel
// ID's after the specified block height, capped at the number of blocks beyond
// that block height. This will be used by nodes upon initial connect to
// synchronize their views of the network.
type QueryChannelRange struct {
        // ChainHash denotes the target chain that we're trying to synchronize
        // channel graph state for.
        ChainHash chainhash.Hash

        // FirstBlockHeight is the first block in the query range. The
        // responder should send all new short channel IDs from this block
        // until this block plus the specified number of blocks.
        FirstBlockHeight uint32

        // NumBlocks is the number of blocks beyond the first block that short
        // channel ID's should be sent for.
        NumBlocks uint32
}

// NewQueryChannelRange creates a new empty QueryChannelRange message.
func NewQueryChannelRange() *QueryChannelRange <span class="cov0" title="0">{
        return &amp;QueryChannelRange{}
}</span>

// A compile time check to ensure QueryChannelRange implements the
// lnwire.Message interface.
var _ Message = (*QueryChannelRange)(nil)

// Decode deserializes a serialized QueryChannelRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) Decode(r io.Reader, pver uint32) error <span class="cov10" title="33">{
        return ReadElements(r,
                q.ChainHash[:],
                &amp;q.FirstBlockHeight,
                &amp;q.NumBlocks,
        )
}</span>

// Encode serializes the target QueryChannelRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) Encode(w io.Writer, pver uint32) error <span class="cov8" title="16">{
        return WriteElements(w,
                q.ChainHash[:],
                q.FirstBlockHeight,
                q.NumBlocks,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) MsgType() MessageType <span class="cov1" title="1">{
        return MsgQueryChannelRange
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// QueryChannelRange complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) MaxPayloadLength(uint32) uint32 <span class="cov2" title="2">{
        // 32 + 4 + 4
        return 40
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package lnwire

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "io"
        "sort"
        "sync"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ShortChanIDEncoding is an enum-like type that represents exactly how a set
// of short channel ID's is encoded on the wire. The set of encodings allows us
// to take advantage of the structure of a list of short channel ID's to
// achieving a high degree of compression.
type ShortChanIDEncoding uint8

const (
        // EncodingSortedPlain signals that the set of short channel ID's is
        // encoded using the regular encoding, in a sorted order.
        EncodingSortedPlain ShortChanIDEncoding = 0

        // EncodingSortedZlib signals that the set of short channel ID's is
        // encoded by first sorting the set of channel ID's, as then
        // compressing them using zlib.
        EncodingSortedZlib ShortChanIDEncoding = 1
)

const (
        // maxZlibBufSize is the max number of bytes that we'll accept from a
        // zlib decoding instance. We do this in order to limit the total
        // amount of memory allocated during a decoding instance.
        maxZlibBufSize = 67413630
)

// zlibDecodeMtx is a package level mutex that we'll use in order to ensure
// that we'll only attempt a single zlib decoding instance at a time. This
// allows us to also further bound our memory usage.
var zlibDecodeMtx sync.Mutex

// ErrUnknownShortChanIDEncoding is a parametrized error that indicates that we
// came across an unknown short channel ID encoding, and therefore were unable
// to continue parsing.
func ErrUnknownShortChanIDEncoding(encoding ShortChanIDEncoding) error <span class="cov1" title="1">{
        return fmt.Errorf("unknown short chan id encoding: %v", encoding)
}</span>

// QueryShortChanIDs is a message that allows the sender to query a set of
// channel announcement and channel update messages that correspond to the set
// of encoded short channel ID's. The encoding of the short channel ID's is
// detailed in the query message ensuring that the receiver knows how to
// properly decode each encode short channel ID which may be encoded using a
// compression format. The receiver should respond with a series of channel
// announcement and channel updates, finally sending a ReplyShortChanIDsEnd
// message.
type QueryShortChanIDs struct {
        // ChainHash denotes the target chain that we're querying for the
        // channel channel ID's of.
        ChainHash chainhash.Hash

        // EncodingType is a signal to the receiver of the message that
        // indicates exactly how the set of short channel ID's that follow have
        // been encoded.
        EncodingType ShortChanIDEncoding

        // ShortChanIDs is a slice of decoded short channel ID's.
        ShortChanIDs []ShortChannelID
}

// NewQueryShortChanIDs creates a new QueryShortChanIDs message.
func NewQueryShortChanIDs(h chainhash.Hash, e ShortChanIDEncoding,
        s []ShortChannelID) *QueryShortChanIDs <span class="cov0" title="0">{

        return &amp;QueryShortChanIDs{
                ChainHash:    h,
                EncodingType: e,
                ShortChanIDs: s,
        }
}</span>

// A compile time check to ensure QueryShortChanIDs implements the
// lnwire.Message interface.
var _ Message = (*QueryShortChanIDs)(nil)

// Decode deserializes a serialized QueryShortChanIDs message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) Decode(r io.Reader, pver uint32) error <span class="cov3" title="25">{
        err := ReadElements(r, q.ChainHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="25">q.EncodingType, q.ShortChanIDs, err = decodeShortChanIDs(r)

        return err</span>
}

// decodeShortChanIDs decodes a set of short channel ID's that have been
// encoded. The first byte of the body details how the short chan ID's were
// encoded. We'll use this type to govern exactly how we go about encoding the
// set of short channel ID's.
func decodeShortChanIDs(r io.Reader) (ShortChanIDEncoding, []ShortChannelID, error) <span class="cov3" title="56">{
        // First, we'll attempt to read the number of bytes in the body of the
        // set of encoded short channel ID's.
        var numBytesResp uint16
        err := ReadElements(r, &amp;numBytesResp)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov3" title="56">if numBytesResp == 0 </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("No encoding type specified")
        }</span>

        <span class="cov3" title="56">queryBody := make([]byte, numBytesResp)
        if _, err := io.ReadFull(r, queryBody); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        // The first byte is the encoding type, so we'll extract that so we can
        // continue our parsing.
        <span class="cov3" title="56">encodingType := ShortChanIDEncoding(queryBody[0])

        // Before continuing, we'll snip off the first byte of the query body
        // as that was just the encoding type.
        queryBody = queryBody[1:]

        // Otherwise, depending on the encoding type, we'll decode the encode
        // short channel ID's in a different manner.
        switch encodingType </span>{

        // In this encoding, we'll simply read a sort array of encoded short
        // channel ID's from the buffer.
        case EncodingSortedPlain:<span class="cov3" title="52">
                // If after extracting the encoding type, then number of
                // remaining bytes instead a whole multiple of the size of an
                // encoded short channel ID (8 bytes), then we'll return a
                // parsing error.
                if len(queryBody)%8 != 0 </span><span class="cov1" title="2">{
                        return 0, nil, fmt.Errorf("whole number of short "+
                                "chan ID's cannot be encoded in len=%v",
                                len(queryBody))
                }</span>

                // As each short channel ID is encoded as 8 bytes, we can
                // compute the number of bytes encoded based on the size of the
                // query body.
                <span class="cov3" title="50">numShortChanIDs := len(queryBody) / 8
                if numShortChanIDs == 0 </span><span class="cov1" title="2">{
                        return encodingType, nil, nil
                }</span>

                // Finally, we'll read out the exact number of short channel
                // ID's to conclude our parsing.
                <span class="cov3" title="48">shortChanIDs := make([]ShortChannelID, numShortChanIDs)
                bodyReader := bytes.NewReader(queryBody)
                for i := 0; i &lt; numShortChanIDs; i++ </span><span class="cov8" title="41600">{
                        if err := ReadElements(bodyReader, &amp;shortChanIDs[i]); err != nil </span><span class="cov0" title="0">{
                                return 0, nil, fmt.Errorf("unable to parse "+
                                        "short chan ID: %v", err)
                        }</span>
                }

                <span class="cov3" title="48">return encodingType, shortChanIDs, nil</span>

        // In this encoding, we'll use zlib to decode the compressed payload.
        // However, we'll pay attention to ensure that we don't open our selves
        // up to a memory exhaustion attack.
        case EncodingSortedZlib:<span class="cov1" title="3">
                // We'll obtain an ultimately release the zlib decode mutex.
                // This guards us against allocating too much memory to decode
                // each instance from concurrent peers.
                zlibDecodeMtx.Lock()
                defer zlibDecodeMtx.Unlock()

                // Before we start to decode, we'll create a limit reader over
                // the current reader. This will ensure that we can control how
                // much memory we're allocating during the decoding process.
                limitedDecompressor, err := zlib.NewReader(&amp;io.LimitedReader{
                        R: bytes.NewReader(queryBody),
                        N: maxZlibBufSize,
                })
                if err != nil </span><span class="cov1" title="3">{
                        return 0, nil, fmt.Errorf("unable to create zlib reader: %v", err)
                }</span>

                <span class="cov0" title="0">var (
                        shortChanIDs []ShortChannelID
                        lastChanID   ShortChannelID
                )
                for </span><span class="cov0" title="0">{
                        // We'll now attempt to read the next short channel ID
                        // encoded in the payload.
                        var cid ShortChannelID
                        err := ReadElements(limitedDecompressor, &amp;cid)

                        switch </span>{
                        // If we get an EOF error, then that either means we've
                        // read all that's contained in the buffer, or have hit
                        // our limit on the number of bytes we'll read. In
                        // either case, we'll return what we have so far.
                        case err == io.ErrUnexpectedEOF || err == io.EOF:<span class="cov0" title="0">
                                return encodingType, shortChanIDs, nil</span>

                        // Otherwise, we hit some other sort of error, possibly
                        // an invalid payload, so we'll exit early with the
                        // error.
                        case err != nil:<span class="cov0" title="0">
                                return 0, nil, fmt.Errorf("unable to "+
                                        "deflate next short chan "+
                                        "ID: %v", err)</span>
                        }

                        // We successfully read the next ID, so well collect
                        // that in the set of final ID's to return.
                        <span class="cov0" title="0">shortChanIDs = append(shortChanIDs, cid)

                        // Finally, we'll ensure that this short chan ID is
                        // greater than the last one. This is a requirement
                        // within the encoding, and if violated can aide us in
                        // detecting malicious payloads.
                        if cid.ToUint64() &lt;= lastChanID.ToUint64() </span><span class="cov0" title="0">{
                                return 0, nil, fmt.Errorf("current sid of %v "+
                                        "isn't greater than last sid of %v", cid,
                                        lastChanID)
                        }</span>

                        <span class="cov0" title="0">lastChanID = cid</span>
                }

        default:<span class="cov1" title="1">
                // If we've been sent an encoding type that we don't know of,
                // then we'll return a parsing error as we can't continue if
                // we're unable to encode them.
                return 0, nil, ErrUnknownShortChanIDEncoding(encodingType)</span>
        }
}

// Encode serializes the target QueryShortChanIDs into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) Encode(w io.Writer, pver uint32) error <span class="cov2" title="10">{
        // First, we'll write out the chain hash.
        err := WriteElements(w, q.ChainHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Base on our encoding type, we'll write out the set of short channel
        // ID's.
        <span class="cov2" title="10">return encodeShortChanIDs(w, q.EncodingType, q.ShortChanIDs)</span>
}

// encodeShortChanIDs encodes the passed short channel ID's into the passed
// io.Writer, respecting the specified encoding type.
func encodeShortChanIDs(w io.Writer, encodingType ShortChanIDEncoding,
        shortChanIDs []ShortChannelID) error <span class="cov3" title="25">{

        // For both of the current encoding types, the channel ID's are to be
        // sorted in place, so we'll do that now.
        sort.Slice(shortChanIDs, func(i, j int) bool </span><span class="cov10" title="212654">{
                return shortChanIDs[i].ToUint64() &lt;
                        shortChanIDs[j].ToUint64()
        }</span>)

        <span class="cov3" title="25">switch encodingType </span>{

        // In this encoding, we'll simply write a sorted array of encoded short
        // channel ID's from the buffer.
        case EncodingSortedPlain:<span class="cov3" title="25">
                // First, we'll write out the number of bytes of the query
                // body. We add 1 as the response will have the encoding type
                // prepended to it.
                numBytesBody := uint16(len(shortChanIDs)*8) + 1
                if err := WriteElements(w, numBytesBody); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // We'll then write out the encoding that that follows the
                // actual encoded short channel ID's.
                <span class="cov3" title="25">if err := WriteElements(w, encodingType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Now that we know they're sorted, we can write out each short
                // channel ID to the buffer.
                <span class="cov3" title="25">for _, chanID := range shortChanIDs </span><span class="cov8" title="20800">{
                        if err := WriteElements(w, chanID); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to write short chan "+
                                        "ID: %v", err)
                        }</span>
                }

                <span class="cov3" title="25">return nil</span>

        // For this encoding we'll first write out a serialized version of all
        // the channel ID's into a buffer, then zlib encode that. The final
        // payload is what we'll write out to the passed io.Writer.
        //
        // TODO(roasbeef): assumes the caller knows the proper chunk size to
        // pass to avoid bin-packing here
        case EncodingSortedZlib:<span class="cov0" title="0">
                // We'll make a new buffer, then wrap that with a zlib writer
                // so we can write directly to the buffer and encode in a
                // streaming manner.
                var buf bytes.Buffer
                zlibWriter := zlib.NewWriter(&amp;buf)

                // Next, we'll write out all the channel ID's directly into the
                // zlib writer, which will do compressing on the fly.
                for _, chanID := range shortChanIDs </span><span class="cov0" title="0">{
                        err := WriteElements(zlibWriter, chanID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to write short chan "+
                                        "ID: %v", err)
                        }</span>
                }

                // Now that we've written all the elements, we'll ensure the
                // compressed stream is written to the underlying buffer.
                <span class="cov0" title="0">if err := zlibWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to finalize "+
                                "compression: %v", err)
                }</span>

                // Now that we have all the items compressed, we can compute
                // what the total payload size will be. We add one to account
                // for the byte to encode the type.
                <span class="cov0" title="0">compressedPayload := buf.Bytes()
                numBytesBody := len(compressedPayload) + 1

                // Finally, we can write out the number of bytes, the
                // compression type, and finally the buffer itself.
                if err := WriteElements(w, uint16(numBytesBody)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := WriteElements(w, encodingType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err := w.Write(compressedPayload)
                return err</span>

        default:<span class="cov0" title="0">
                // If we're trying to encode with an encoding type that we
                // don't know of, then we'll return a parsing error as we can't
                // continue if we're unable to encode them.
                return ErrUnknownShortChanIDEncoding(encodingType)</span>
        }
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) MsgType() MessageType <span class="cov2" title="10">{
        return MsgQueryShortChanIDs
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// QueryShortChanIDs complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) MaxPayloadLength(uint32) uint32 <span class="cov3" title="25">{
        return MaxMessagePayload
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package lnwire

import "io"

// ReplyChannelRange is the response to the QueryChannelRange message. It
// includes the original query, and the next streaming chunk of encoded short
// channel ID's as the response. We'll also include a byte that indicates if
// this is the last query in the message.
type ReplyChannelRange struct {
        // QueryChannelRange is the corresponding query to this response.
        QueryChannelRange

        // Complete denotes if this is the conclusion of the set of streaming
        // responses to the original query.
        Complete uint8

        // EncodingType is a signal to the receiver of the message that
        // indicates exactly how the set of short channel ID's that follow have
        // been encoded.
        EncodingType ShortChanIDEncoding

        // ShortChanIDs is a slice of decoded short channel ID's.
        ShortChanIDs []ShortChannelID
}

// NewReplyChannelRange creates a new empty ReplyChannelRange message.
func NewReplyChannelRange() *ReplyChannelRange <span class="cov0" title="0">{
        return &amp;ReplyChannelRange{}
}</span>

// A compile time check to ensure ReplyChannelRange implements the
// lnwire.Message interface.
var _ Message = (*ReplyChannelRange)(nil)

// Decode deserializes a serialized ReplyChannelRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) Decode(r io.Reader, pver uint32) error <span class="cov10" title="31">{
        err := c.QueryChannelRange.Decode(r, pver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="31">if err := ReadElements(r, &amp;c.Complete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="31">c.EncodingType, c.ShortChanIDs, err = decodeShortChanIDs(r)

        return err</span>
}

// Encode serializes the target ReplyChannelRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) Encode(w io.Writer, pver uint32) error <span class="cov8" title="15">{
        if err := c.QueryChannelRange.Encode(w, pver); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="15">if err := WriteElements(w, c.Complete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="15">return encodeShortChanIDs(w, c.EncodingType, c.ShortChanIDs)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) MsgType() MessageType <span class="cov8" title="15">{
        return MsgReplyChannelRange
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// ReplyChannelRange complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) MaxPayloadLength(uint32) uint32 <span class="cov10" title="31">{
        return MaxMessagePayload
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ReplyShortChanIDsEnd is a message that marks the end of a streaming message
// response to an initial QueryShortChanIDs message. This marks that the
// receiver of the original QueryShortChanIDs for the target chain has either
// sent all adequate responses it knows of, or doesn't now of any short chan
// ID's for the target chain.
type ReplyShortChanIDsEnd struct {
        // ChainHash denotes the target chain that we're respond to a short
        // chan ID query for.
        ChainHash chainhash.Hash

        // Complete will be set to 0 if we don't know of the chain that the
        // remote peer sent their query for. Otherwise, we'll set this to 1 in
        // order to indicate that we've sent all known responses for the prior
        // set of short chan ID's in the corresponding QueryShortChanIDs
        // message.
        Complete uint8
}

// NewReplyShortChanIDsEnd creates a new empty ReplyShortChanIDsEnd message.
func NewReplyShortChanIDsEnd() *ReplyShortChanIDsEnd <span class="cov0" title="0">{
        return &amp;ReplyShortChanIDsEnd{}
}</span>

// A compile time check to ensure ReplyShortChanIDsEnd implements the
// lnwire.Message interface.
var _ Message = (*ReplyShortChanIDsEnd)(nil)

// Decode deserializes a serialized ReplyShortChanIDsEnd message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                c.ChainHash[:],
                &amp;c.Complete,
        )
}</span>

// Encode serializes the target ReplyShortChanIDsEnd into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChainHash[:],
                c.Complete,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) MsgType() MessageType <span class="cov1" title="1">{
        return MsgReplyShortChanIDsEnd
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// ReplyShortChanIDsEnd complete message observing the specified protocol
// version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 (chain hash) + 1 (complete)
        return 33
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec"
)

// RevokeAndAck is sent by either side once a CommitSig message has been
// received, and validated. This message serves to revoke the prior commitment
// transaction, which was the most up to date version until a CommitSig message
// referencing the specified ChannelPoint was received.  Additionally, this
// message also piggyback's the next revocation hash that Alice should use when
// constructing the Bob's version of the next commitment transaction (which
// would be done before sending a CommitSig message).  This piggybacking allows
// Alice to send the next CommitSig message modifying Bob's commitment
// transaction without first asking for a revocation hash initially.
type RevokeAndAck struct {
        // ChanID uniquely identifies to which currently active channel this
        // RevokeAndAck applies to.
        ChanID ChannelID

        // Revocation is the preimage to the revocation hash of the now prior
        // commitment transaction.
        Revocation [32]byte

        // NextRevocationKey is the next commitment point which should be used
        // for the next commitment transaction the remote peer creates for us.
        // This, in conjunction without revocation base point will be used to
        // create the proper revocation key used within the commitment
        // transaction.
        NextRevocationKey *btcec.PublicKey
}

// NewRevokeAndAck creates a new RevokeAndAck message.
func NewRevokeAndAck() *RevokeAndAck <span class="cov0" title="0">{
        return &amp;RevokeAndAck{}
}</span>

// A compile time check to ensure RevokeAndAck implements the lnwire.Message
// interface.
var _ Message = (*RevokeAndAck)(nil)

// Decode deserializes a serialized RevokeAndAck message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                c.Revocation[:],
                &amp;c.NextRevocationKey,
        )
}</span>

// Encode serializes the target RevokeAndAck into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.Revocation[:],
                c.NextRevocationKey,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) MsgType() MessageType <span class="cov1" title="1">{
        return MsgRevokeAndAck
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a RevokeAndAck
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 32 + 33
        return 97
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package lnwire

import (
        "fmt"
)

// ShortChannelID represents the set of data which is needed to retrieve all
// necessary data to validate the channel existence.
type ShortChannelID struct {
        // BlockHeight is the height of the block where funding transaction
        // located.
        //
        // NOTE: This field is limited to 3 bytes.
        BlockHeight uint32

        // TxIndex is a position of funding transaction within a block.
        //
        // NOTE: This field is limited to 3 bytes.
        TxIndex uint32

        // TxPosition indicating transaction output which pays to the channel.
        TxPosition uint16
}

// NewShortChanIDFromInt returns a new ShortChannelID which is the decoded
// version of the compact channel ID encoded within the uint64. The format of
// the compact channel ID is as follows: 3 bytes for the block height, 3 bytes
// for the transaction index, and 2 bytes for the output index.
func NewShortChanIDFromInt(chanID uint64) ShortChannelID <span class="cov1" title="1">{
        return ShortChannelID{
                BlockHeight: uint32(chanID &gt;&gt; 40),
                TxIndex:     uint32(chanID&gt;&gt;16) &amp; 0xFFFFFF,
                TxPosition:  uint16(chanID),
        }
}</span>

// ToUint64 converts the ShortChannelID into a compact format encoded within a
// uint64 (8 bytes).
func (c ShortChannelID) ToUint64() uint64 <span class="cov10" title="425308">{
        // TODO(roasbeef): explicit error on overflow?
        return ((uint64(c.BlockHeight) &lt;&lt; 40) | (uint64(c.TxIndex) &lt;&lt; 16) |
                (uint64(c.TxPosition)))
}</span>

// String generates a human-readable representation of the channel ID.
func (c ShortChannelID) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d:%d:%d", c.BlockHeight, c.TxIndex, c.TxPosition)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package lnwire

import (
        "reflect"
        "testing"

        "github.com/davecgh/go-spew/spew"
)

func TestShortChannelIDEncoding(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        var testCases = []ShortChannelID{
                {
                        BlockHeight: (1 &lt;&lt; 24) - 1,
                        TxIndex:     (1 &lt;&lt; 24) - 1,
                        TxPosition:  (1 &lt;&lt; 16) - 1,
                },
                {
                        BlockHeight: 2304934,
                        TxIndex:     2345,
                        TxPosition:  5,
                },
                {
                        BlockHeight: 9304934,
                        TxIndex:     2345,
                        TxPosition:  5233,
                },
        }

        for _, testCase := range testCases </span><span class="cov0" title="0">{
                chanInt := testCase.ToUint64()

                newChanID := NewShortChanIDFromInt(chanInt)

                if !reflect.DeepEqual(testCase, newChanID) </span><span class="cov0" title="0">{
                        t.Fatalf("chan ID's don't match: expected %v got %v",
                                spew.Sdump(testCase), spew.Sdump(newChanID))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package lnwire

import (
        "io"
)

// Shutdown is sent by either side in order to initiate the cooperative closure
// of a channel. This message is sparse as both sides implicitly have the
// information necessary to construct a transaction that will send the settled
// funds of both parties to the final delivery addresses negotiated during the
// funding workflow.
type Shutdown struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // Address is the script to which the channel funds will be paid.
        Address DeliveryAddress
}

// DeliveryAddress is used to communicate the address to which funds from a
// closed channel should be sent. The address can be a p2wsh, p2pkh, p2sh or
// p2wpkh.
type DeliveryAddress []byte

// NewShutdown creates a new Shutdown message.
func NewShutdown(cid ChannelID, addr DeliveryAddress) *Shutdown <span class="cov0" title="0">{
        return &amp;Shutdown{
                ChannelID: cid,
                Address:   addr,
        }
}</span>

// A compile-time check to ensure Shutdown implements the lnwire.Message
// interface.
var _ Message = (*Shutdown)(nil)

// Decode deserializes a serialized Shutdown stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) Decode(r io.Reader, pver uint32) error <span class="cov10" title="3">{
        return ReadElements(r, &amp;s.ChannelID, &amp;s.Address)
}</span>

// Encode serializes the target Shutdown into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w, s.ChannelID, s.Address)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) MsgType() MessageType <span class="cov1" title="1">{
        return MsgShutdown
}</span>

// MaxPayloadLength returns the maximum allowed payload size for this message
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) MaxPayloadLength(pver uint32) uint32 <span class="cov10" title="3">{
        var length uint32

        // ChannelID - 32bytes
        length += 32

        // Len - 2 bytes
        length += 2

        // ScriptPubKey - 34 bytes for pay to witness script hash
        length += 34

        // NOTE: pay to pubkey hash is 25 bytes, pay to script hash is 22
        // bytes, and pay to witness pubkey hash is 22 bytes in length.

        return length
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package lnwire

import (
        "fmt"

        "github.com/btcsuite/btcd/btcec"
)

// Sig is a fixed-sized ECDSA signature. Unlike Bitcoin, we use fixed sized
// signatures on the wire, instead of DER encoded signatures. This type
// provides several methods to convert to/from a regular Bitcoin DER encoded
// signature (raw bytes and *btcec.Signature).
type Sig [64]byte

// NewSigFromRawSignature returns a Sig from a Bitcoin raw signature encoded in
// the canonical DER encoding.
func NewSigFromRawSignature(sig []byte) (Sig, error) <span class="cov8" title="1">{
        var b Sig

        if len(sig) == 0 </span><span class="cov0" title="0">{
                return b, fmt.Errorf("cannot decode empty signature")
        }</span>

        // Extract lengths of R and S. The DER representation is laid out as
        // 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s
        // which means the length of R is the 4th byte and the length of S
        // is the second byte after R ends. 0x02 signifies a length-prefixed,
        // zero-padded, big-endian bigint. 0x30 signifies a DER signature.
        // See the Serialize() method for btcec.Signature for details.
        <span class="cov8" title="1">rLen := sig[3]
        sLen := sig[5+rLen]

        // Check to make sure R and S can both fit into their intended buffers.
        // We check S first because these code blocks decrement sLen and rLen
        // in the case of a 33-byte 0-padded integer returned from Serialize()
        // and rLen is used in calculating array indices for S. We can track
        // this with additional variables, but it's more efficient to just
        // check S first.
        if sLen &gt; 32 </span><span class="cov0" title="0">{
                if (sLen &gt; 33) || (sig[6+rLen] != 0x00) </span><span class="cov0" title="0">{
                        return b, fmt.Errorf("S is over 32 bytes long " +
                                "without padding")
                }</span>
                <span class="cov0" title="0">sLen--
                copy(b[64-sLen:], sig[7+rLen:])</span>
        } else<span class="cov8" title="1"> {
                copy(b[64-sLen:], sig[6+rLen:])
        }</span>

        // Do the same for R as we did for S
        <span class="cov8" title="1">if rLen &gt; 32 </span><span class="cov8" title="1">{
                if (rLen &gt; 33) || (sig[4] != 0x00) </span><span class="cov0" title="0">{
                        return b, fmt.Errorf("R is over 32 bytes long " +
                                "without padding")
                }</span>
                <span class="cov8" title="1">rLen--
                copy(b[32-rLen:], sig[5:5+rLen])</span>
        } else<span class="cov0" title="0"> {
                copy(b[32-rLen:], sig[4:4+rLen])
        }</span>

        <span class="cov8" title="1">return b, nil</span>
}

// NewSigFromSignature creates a new signature as used on the wire, from an
// existing btcec.Signature.
func NewSigFromSignature(e *btcec.Signature) (Sig, error) <span class="cov8" title="1">{
        if e == nil </span><span class="cov0" title="0">{
                return Sig{}, fmt.Errorf("cannot decode empty signature")
        }</span>

        // Serialize the signature with all the checks that entails.
        <span class="cov8" title="1">return NewSigFromRawSignature(e.Serialize())</span>
}

// ToSignature converts the fixed-sized signature to a btcec.Signature objects
// which can be used for signature validation checks.
func (b *Sig) ToSignature() (*btcec.Signature, error) <span class="cov0" title="0">{
        // Parse the signature with strict checks.
        sigBytes := b.ToSignatureBytes()
        sig, err := btcec.ParseDERSignature(sigBytes, btcec.S256())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}

// ToSignatureBytes serializes the target fixed-sized signature into the raw
// bytes of a DER encoding.
func (b *Sig) ToSignatureBytes() []byte <span class="cov0" title="0">{
        // Extract canonically-padded bigint representations from buffer
        r := extractCanonicalPadding(b[0:32])
        s := extractCanonicalPadding(b[32:64])
        rLen := uint8(len(r))
        sLen := uint8(len(s))

        // Create a canonical serialized signature. DER format is:
        // 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s
        sigBytes := make([]byte, 6+rLen+sLen)
        sigBytes[0] = 0x30            // DER signature magic value
        sigBytes[1] = 4 + rLen + sLen // Length of rest of signature
        sigBytes[2] = 0x02            // Big integer magic value
        sigBytes[3] = rLen            // Length of R
        sigBytes[rLen+4] = 0x02       // Big integer magic value
        sigBytes[rLen+5] = sLen       // Length of S
        copy(sigBytes[4:], r)         // Copy R
        copy(sigBytes[rLen+6:], s)    // Copy S

        return sigBytes
}</span>

// extractCanonicalPadding is a utility function to extract the canonical
// padding of a big-endian integer from the wire encoding (a 0-padded
// big-endian integer) such that it passes btcec.canonicalPadding test.
func extractCanonicalPadding(b []byte) []byte <span class="cov0" title="0">{
        for i := 0; i &lt; len(b); i++ </span><span class="cov0" title="0">{
                // Found first non-zero byte.
                if b[i] &gt; 0 </span><span class="cov0" title="0">{
                        // If the MSB is set, we need zero padding.
                        if b[i]&amp;0x80 == 0x80 </span><span class="cov0" title="0">{
                                return append([]byte{0x00}, b[i:]...)
                        }</span>
                        <span class="cov0" title="0">return b[i:]</span>
                }
        }
        <span class="cov0" title="0">return []byte{0x00}</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package lnwire

import (
        "fmt"
        "math/big"
        "testing"

        "github.com/btcsuite/btcd/btcec"
)

func TestSignatureSerializeDeserialize(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()

        // Local-scoped closure to serialize and deserialize a Signature and
        // check for errors as well as check if the results are correct.
        signatureSerializeDeserialize := func(e btcec.Signature) error </span><span class="cov0" title="0">{
                sig, err := NewSigFromSignature(&amp;e)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">e2, err := sig.ToSignature()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if e.R.Cmp(e2.R) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Pre/post-serialize Rs don't match"+
                                ": %s, %s", e.R, e2.R)
                }</span>
                <span class="cov0" title="0">if e.S.Cmp(e2.S) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Pre/post-serialize Ss don't match"+
                                ": %s, %s", e.S, e2.S)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">sig := btcec.Signature{}

        // Check R = N-1, S = 128.
        sig.R = big.NewInt(1) // Allocate a big.Int before we call .Sub.
        sig.R.Sub(btcec.S256().N, sig.R)
        sig.S = big.NewInt(128)
        err := signatureSerializeDeserialize(sig)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("R = N-1, S = 128: %s", err.Error())
        }</span>

        // Check R = N-1, S = 127.
        <span class="cov0" title="0">sig.S = big.NewInt(127)
        err = signatureSerializeDeserialize(sig)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("R = N-1, S = 127: %s", err.Error())
        }</span>

        // Check R = N-1, S = N&gt;&gt;1.
        <span class="cov0" title="0">sig.S.Set(btcec.S256().N)
        sig.S.Rsh(sig.S, 1)
        err = signatureSerializeDeserialize(sig)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("R = N-1, S = N&gt;&gt;1: %s", err.Error())
        }</span>

        // Check R = N-1, S = N.
        <span class="cov0" title="0">sig.S.Set(btcec.S256().N)
        err = signatureSerializeDeserialize(sig)
        if err.Error() != "signature S isn't 1 or more" </span><span class="cov0" title="0">{
                t.Fatalf("R = N-1, S = N should become R = N-1, S = 0: %s",
                        err.Error())
        }</span>

        // Check R = N-1, S = N-1.
        <span class="cov0" title="0">sig.S.Sub(sig.S, big.NewInt(1))
        err = signatureSerializeDeserialize(sig)
        if err.Error() != "Pre/post-serialize Ss don't match: 115792089237316"+
                "195423570985008687907852837564279074904382605163141518161494"+
                "336, 1" </span><span class="cov0" title="0">{
                t.Fatalf("R = N-1, S = N-1 should become R = N-1, S = 1: %s",
                        err.Error())
        }</span>

        // Check R = 2N, S = 128
        <span class="cov0" title="0">sig.R.Mul(btcec.S256().N, big.NewInt(2))
        sig.S.Set(big.NewInt(127))
        err = signatureSerializeDeserialize(sig)
        if err.Error() != "R is over 32 bytes long without padding" </span><span class="cov0" title="0">{
                t.Fatalf("R = 2N, S = 128, R should be over 32 bytes: %s",
                        err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package lnwire

import "io"

// OnionPacketSize is the size of the serialized Sphinx onion packet included
// in each UpdateAddHTLC message. The breakdown of the onion packet is as
// follows: 1-byte version, 33-byte ephemeral public key (for ECDH), 1300-bytes
// of per-hop data, and a 32-byte HMAC over the entire packet.
const OnionPacketSize = 1366

// UpdateAddHTLC is the message sent by Alice to Bob when she wishes to add an
// HTLC to his remote commitment transaction. In addition to information
// detailing the value, the ID, expiry, and the onion blob is also included
// which allows Bob to derive the next hop in the route. The HTLC added by this
// message is to be added to the remote node's "pending" HTLC's.  A subsequent
// CommitSig message will move the pending HTLC to the newly created commitment
// transaction, marking them as "staged".
type UpdateAddHTLC struct {
        // ChanID is the particular active channel that this UpdateAddHTLC is
        // bound to.
        ChanID ChannelID

        // ID is the identification server for this HTLC. This value is
        // explicitly included as it allows nodes to survive single-sided
        // restarts. The ID value for this sides starts at zero, and increases
        // with each offered HTLC.
        ID uint64

        // Amount is the amount of millisatoshis this HTLC is worth.
        Amount MilliSatoshi

        // PaymentHash is the payment hash to be included in the HTLC this
        // request creates. The pre-image to this HTLC must be revealed by the
        // upstream peer in order to fully settle the HTLC.
        PaymentHash [32]byte

        // Expiry is the number of blocks after which this HTLC should expire.
        // It is the receiver's duty to ensure that the outgoing HTLC has a
        // sufficient expiry value to allow her to redeem the incoming HTLC.
        Expiry uint32

        // OnionBlob is the raw serialized mix header used to route an HTLC in
        // a privacy-preserving manner. The mix header is defined currently to
        // be parsed as a 4-tuple: (groupElement, routingInfo, headerMAC,
        // body).  First the receiving node should use the groupElement, and
        // its current onion key to derive a shared secret with the source.
        // Once the shared secret has been derived, the headerMAC should be
        // checked FIRST. Note that the MAC only covers the routingInfo field.
        // If the MAC matches, and the shared secret is fresh, then the node
        // should strip off a layer of encryption, exposing the next hop to be
        // used in the subsequent UpdateAddHTLC message.
        OnionBlob [OnionPacketSize]byte
}

// NewUpdateAddHTLC returns a new empty UpdateAddHTLC message.
func NewUpdateAddHTLC() *UpdateAddHTLC <span class="cov0" title="0">{
        return &amp;UpdateAddHTLC{}
}</span>

// A compile time check to ensure UpdateAddHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateAddHTLC)(nil)

// Decode deserializes a serialized UpdateAddHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                &amp;c.Amount,
                c.PaymentHash[:],
                &amp;c.Expiry,
                c.OnionBlob[:],
        )
}</span>

// Encode serializes the target UpdateAddHTLC into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.Amount,
                c.PaymentHash[:],
                c.Expiry,
                c.OnionBlob[:],
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateAddHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateAddHTLC
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 1450
        return 32 + 8 + 4 + 8 + 32 + 1366
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package lnwire

import "io"

// OpaqueReason is an opaque encrypted byte slice that encodes the exact
// failure reason and additional some supplemental data. The contents of this
// slice can only be decrypted by the sender of the original HTLC.
type OpaqueReason []byte

// UpdateFailHTLC is sent by Alice to Bob in order to remove a previously added
// HTLC. Upon receipt of an UpdateFailHTLC the HTLC should be removed from the
// next commitment transaction, with the UpdateFailHTLC propagated backwards in
// the route to fully undo the HTLC.
type UpdateFailHTLC struct {
        // ChanIDPoint is the particular active channel that this
        // UpdateFailHTLC is bound to.
        ChanID ChannelID

        // ID references which HTLC on the remote node's commitment transaction
        // has timed out.
        ID uint64

        // Reason is an onion-encrypted blob that details why the HTLC was
        // failed. This blob is only fully decryptable by the initiator of the
        // HTLC message.
        Reason OpaqueReason
}

// A compile time check to ensure UpdateFailHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateFailHTLC)(nil)

// Decode deserializes a serialized UpdateFailHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                &amp;c.Reason,
        )
}</span>

// Encode serializes the target UpdateFailHTLC into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.Reason,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFailHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateFailHTLC
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        var length uint32

        // Length of the ChanID
        length += 32

        // Length of the ID
        length += 8

        // Length of the length opaque reason
        length += 2

        // Length of the Reason
        length += 292

        return length
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package lnwire

import (
        "crypto/sha256"
        "io"
)

// UpdateFailMalformedHTLC is sent by either the payment forwarder or by
// payment receiver to the payment sender in order to notify it that the onion
// blob can't be parsed. For that reason we send this message instead of
// obfuscate the onion failure.
type UpdateFailMalformedHTLC struct {
        // ChanID is the particular active channel that this
        // UpdateFailMalformedHTLC is bound to.
        ChanID ChannelID

        // ID references which HTLC on the remote node's commitment transaction
        // has timed out.
        ID uint64

        // ShaOnionBlob hash of the onion blob on which can't be parsed by the
        // node in the payment path.
        ShaOnionBlob [sha256.Size]byte

        // FailureCode the exact reason why onion blob haven't been parsed.
        FailureCode FailCode
}

// A compile time check to ensure UpdateFailMalformedHTLC implements the
// lnwire.Message interface.
var _ Message = (*UpdateFailMalformedHTLC)(nil)

// Decode deserializes a serialized UpdateFailMalformedHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                c.ShaOnionBlob[:],
                &amp;c.FailureCode,
        )
}</span>

// Encode serializes the target UpdateFailMalformedHTLC into the passed
// io.Writer observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.ShaOnionBlob[:],
                c.FailureCode,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFailMalformedHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for a
// UpdateFailMalformedHTLC complete message observing the specified protocol
// version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 +  8 + 32 + 2
        return 74
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package lnwire

import (
        "io"
)

// UpdateFee is the message the channel initiator sends to the other peer if
// the channel commitment fee needs to be updated.
type UpdateFee struct {
        // ChanID is the channel that this UpdateFee is meant for.
        ChanID ChannelID

        // FeePerKw is the fee-per-kw on commit transactions that the sender of
        // this message wants to use for this channel.
        //
        // TODO(halseth): make SatPerKWeight when fee estimation is moved to
        // own package. Currently this will cause an import cycle.
        FeePerKw uint32
}

// NewUpdateFee creates a new UpdateFee message.
func NewUpdateFee(chanID ChannelID, feePerKw uint32) *UpdateFee <span class="cov0" title="0">{
        return &amp;UpdateFee{
                ChanID:   chanID,
                FeePerKw: feePerKw,
        }
}</span>

// A compile time check to ensure UpdateFee implements the lnwire.Message
// interface.
var _ Message = (*UpdateFee)(nil)

// Decode deserializes a serialized UpdateFee message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.FeePerKw,
        )
}</span>

// Encode serializes the target UpdateFee into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.FeePerKw,
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFee
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateFee
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 4
        return 36
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package lnwire

import "io"

// UpdateFulfillHTLC is sent by Alice to Bob when she wishes to settle a
// particular HTLC referenced by its HTLCKey within a specific active channel
// referenced by ChannelPoint.  A subsequent CommitSig message will be sent by
// Alice to "lock-in" the removal of the specified HTLC, possible containing a
// batch signature covering several settled HTLC's.
type UpdateFulfillHTLC struct {
        // ChanID references an active channel which holds the HTLC to be
        // settled.
        ChanID ChannelID

        // ID denotes the exact HTLC stage within the receiving node's
        // commitment transaction to be removed.
        ID uint64

        // PaymentPreimage is the R-value preimage required to fully settle an
        // HTLC.
        PaymentPreimage [32]byte
}

// NewUpdateFulfillHTLC returns a new empty UpdateFulfillHTLC.
func NewUpdateFulfillHTLC(chanID ChannelID, id uint64,
        preimage [32]byte) *UpdateFulfillHTLC <span class="cov0" title="0">{

        return &amp;UpdateFulfillHTLC{
                ChanID:          chanID,
                ID:              id,
                PaymentPreimage: preimage,
        }
}</span>

// A compile time check to ensure UpdateFulfillHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateFulfillHTLC)(nil)

// Decode deserializes a serialized UpdateFulfillHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) Decode(r io.Reader, pver uint32) error <span class="cov10" title="2">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                c.PaymentPreimage[:],
        )
}</span>

// Encode serializes the target UpdateFulfillHTLC into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) Encode(w io.Writer, pver uint32) error <span class="cov1" title="1">{
        return WriteElements(w,
                c.ChanID,
                c.ID,
                c.PaymentPreimage[:],
        )
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) MsgType() MessageType <span class="cov1" title="1">{
        return MsgUpdateFulfillHTLC
}</span>

// MaxPayloadLength returns the maximum allowed payload size for an UpdateFulfillHTLC
// complete message observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) MaxPayloadLength(uint32) uint32 <span class="cov10" title="2">{
        // 32 + 8 + 32
        return 72
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
