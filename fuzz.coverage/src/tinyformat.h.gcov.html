<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - fuzz_coverage.info - src/tinyformat.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - tinyformat.h<span style="font-size: 80%;"> (source / <a href="tinyformat.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">fuzz_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">248</td>
            <td class="headerCovTableEntry">257</td>
            <td class="headerCovTableEntryHi">96.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-08-10 06:23:20</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">436</td>
            <td class="headerCovTableEntry">1444</td>
            <td class="headerCovTableEntryLo">30.2 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // tinyformat.h</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
<span class="lineNum">       3 </span>            : //
<span class="lineNum">       4 </span>            : // Boost Software License - Version 1.0
<span class="lineNum">       5 </span>            : //
<span class="lineNum">       6 </span>            : // Permission is hereby granted, free of charge, to any person or organization
<span class="lineNum">       7 </span>            : // obtaining a copy of the software and accompanying documentation covered by
<span class="lineNum">       8 </span>            : // this license (the &quot;Software&quot;) to use, reproduce, display, distribute,
<span class="lineNum">       9 </span>            : // execute, and transmit the Software, and to prepare derivative works of the
<span class="lineNum">      10 </span>            : // Software, and to permit third-parties to whom the Software is furnished to
<span class="lineNum">      11 </span>            : // do so, all subject to the following:
<span class="lineNum">      12 </span>            : //
<span class="lineNum">      13 </span>            : // The copyright notices in the Software and this entire statement, including
<span class="lineNum">      14 </span>            : // the above license grant, this restriction and the following disclaimer,
<span class="lineNum">      15 </span>            : // must be included in all copies of the Software, in whole or in part, and
<span class="lineNum">      16 </span>            : // all derivative works of the Software, unless such copies or derivative
<span class="lineNum">      17 </span>            : // works are solely in the form of machine-executable object code generated by
<span class="lineNum">      18 </span>            : // a source language processor.
<span class="lineNum">      19 </span>            : //
<span class="lineNum">      20 </span>            : // THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      21 </span>            : // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      22 </span>            : // FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
<span class="lineNum">      23 </span>            : // SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
<span class="lineNum">      24 </span>            : // FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
<span class="lineNum">      25 </span>            : // ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
<span class="lineNum">      26 </span>            : // DEALINGS IN THE SOFTWARE.
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">      29 </span>            : // Tinyformat: A minimal type safe printf replacement
<span class="lineNum">      30 </span>            : //
<span class="lineNum">      31 </span>            : // tinyformat.h is a type safe printf replacement library in a single C++
<span class="lineNum">      32 </span>            : // header file.  Design goals include:
<span class="lineNum">      33 </span>            : //
<span class="lineNum">      34 </span>            : // * Type safety and extensibility for user defined types.
<span class="lineNum">      35 </span>            : // * C99 printf() compatibility, to the extent possible using std::ostream
<span class="lineNum">      36 </span>            : // * POSIX extension for positional arguments
<span class="lineNum">      37 </span>            : // * Simplicity and minimalism.  A single header file to include and distribute
<span class="lineNum">      38 </span>            : //   with your projects.
<span class="lineNum">      39 </span>            : // * Augment rather than replace the standard stream formatting mechanism
<span class="lineNum">      40 </span>            : // * C++98 support, with optional C++11 niceties
<span class="lineNum">      41 </span>            : //
<span class="lineNum">      42 </span>            : //
<span class="lineNum">      43 </span>            : // Main interface example usage
<span class="lineNum">      44 </span>            : // ----------------------------
<span class="lineNum">      45 </span>            : //
<span class="lineNum">      46 </span>            : // To print a date to std::cout for American usage:
<span class="lineNum">      47 </span>            : //
<span class="lineNum">      48 </span>            : //   std::string weekday = &quot;Wednesday&quot;;
<span class="lineNum">      49 </span>            : //   const char* month = &quot;July&quot;;
<span class="lineNum">      50 </span>            : //   size_t day = 27;
<span class="lineNum">      51 </span>            : //   long hour = 14;
<span class="lineNum">      52 </span>            : //   int min = 44;
<span class="lineNum">      53 </span>            : //
<span class="lineNum">      54 </span>            : //   tfm::printf(&quot;%s, %s %d, %.2d:%.2d\n&quot;, weekday, month, day, hour, min);
<span class="lineNum">      55 </span>            : //
<span class="lineNum">      56 </span>            : // POSIX extension for positional arguments is available.
<span class="lineNum">      57 </span>            : // The ability to rearrange formatting arguments is an important feature
<span class="lineNum">      58 </span>            : // for localization because the word order may vary in different languages.
<span class="lineNum">      59 </span>            : //
<span class="lineNum">      60 </span>            : // Previous example for German usage. Arguments are reordered:
<span class="lineNum">      61 </span>            : //
<span class="lineNum">      62 </span>            : //   tfm::printf(&quot;%1$s, %3$d. %2$s, %4$d:%5$.2d\n&quot;, weekday, month, day, hour, min);
<span class="lineNum">      63 </span>            : //
<span class="lineNum">      64 </span>            : // The strange types here emphasize the type safety of the interface; it is
<span class="lineNum">      65 </span>            : // possible to print a std::string using the &quot;%s&quot; conversion, and a
<span class="lineNum">      66 </span>            : // size_t using the &quot;%d&quot; conversion.  A similar result could be achieved
<span class="lineNum">      67 </span>            : // using either of the tfm::format() functions.  One prints on a user provided
<span class="lineNum">      68 </span>            : // stream:
<span class="lineNum">      69 </span>            : //
<span class="lineNum">      70 </span>            : //   tfm::format(std::cerr, &quot;%s, %s %d, %.2d:%.2d\n&quot;,
<span class="lineNum">      71 </span>            : //               weekday, month, day, hour, min);
<span class="lineNum">      72 </span>            : //
<span class="lineNum">      73 </span>            : // The other returns a std::string:
<span class="lineNum">      74 </span>            : //
<span class="lineNum">      75 </span>            : //   std::string date = tfm::format(&quot;%s, %s %d, %.2d:%.2d\n&quot;,
<span class="lineNum">      76 </span>            : //                                  weekday, month, day, hour, min);
<span class="lineNum">      77 </span>            : //   std::cout &lt;&lt; date;
<span class="lineNum">      78 </span>            : //
<span class="lineNum">      79 </span>            : // These are the three primary interface functions.  There is also a
<span class="lineNum">      80 </span>            : // convenience function printfln() which appends a newline to the usual result
<span class="lineNum">      81 </span>            : // of printf() for super simple logging.
<span class="lineNum">      82 </span>            : //
<span class="lineNum">      83 </span>            : //
<span class="lineNum">      84 </span>            : // User defined format functions
<span class="lineNum">      85 </span>            : // -----------------------------
<span class="lineNum">      86 </span>            : //
<span class="lineNum">      87 </span>            : // Simulating variadic templates in C++98 is pretty painful since it requires
<span class="lineNum">      88 </span>            : // writing out the same function for each desired number of arguments.  To make
<span class="lineNum">      89 </span>            : // this bearable tinyformat comes with a set of macros which are used
<span class="lineNum">      90 </span>            : // internally to generate the API, but which may also be used in user code.
<span class="lineNum">      91 </span>            : //
<span class="lineNum">      92 </span>            : // The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and
<span class="lineNum">      93 </span>            : // TINYFORMAT_PASSARGS(n) will generate a list of n argument types,
<span class="lineNum">      94 </span>            : // type/name pairs and argument names respectively when called with an integer
<span class="lineNum">      95 </span>            : // n between 1 and 16.  We can use these to define a macro which generates the
<span class="lineNum">      96 </span>            : // desired user defined function with n arguments.  To generate all 16 user
<span class="lineNum">      97 </span>            : // defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an
<span class="lineNum">      98 </span>            : // example, see the implementation of printf() at the end of the source file.
<span class="lineNum">      99 </span>            : //
<span class="lineNum">     100 </span>            : // Sometimes it's useful to be able to pass a list of format arguments through
<span class="lineNum">     101 </span>            : // to a non-template function.  The FormatList class is provided as a way to do
<span class="lineNum">     102 </span>            : // this by storing the argument list in a type-opaque way.  Continuing the
<span class="lineNum">     103 </span>            : // example from above, we construct a FormatList using makeFormatList():
<span class="lineNum">     104 </span>            : //
<span class="lineNum">     105 </span>            : //   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);
<span class="lineNum">     106 </span>            : //
<span class="lineNum">     107 </span>            : // The format list can now be passed into any non-template function and used
<span class="lineNum">     108 </span>            : // via a call to the vformat() function:
<span class="lineNum">     109 </span>            : //
<span class="lineNum">     110 </span>            : //   tfm::vformat(std::cout, &quot;%s, %s %d, %.2d:%.2d\n&quot;, formatList);
<span class="lineNum">     111 </span>            : //
<span class="lineNum">     112 </span>            : //
<span class="lineNum">     113 </span>            : // Additional API information
<span class="lineNum">     114 </span>            : // --------------------------
<span class="lineNum">     115 </span>            : //
<span class="lineNum">     116 </span>            : // Error handling: Define TINYFORMAT_ERROR to customize the error handling for
<span class="lineNum">     117 </span>            : // format strings which are unsupported or have the wrong number of format
<span class="lineNum">     118 </span>            : // specifiers (calls assert() by default).
<span class="lineNum">     119 </span>            : //
<span class="lineNum">     120 </span>            : // User defined types: Uses operator&lt;&lt; for user defined types by default.
<span class="lineNum">     121 </span>            : // Overload formatValue() for more control.
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : #ifndef TINYFORMAT_H_INCLUDED
<span class="lineNum">     125 </span>            : #define TINYFORMAT_H_INCLUDED
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : namespace tinyformat {}
<span class="lineNum">     128 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">     129 </span>            : // Config section.  Customize to your liking!
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : // Namespace alias to encourage brevity
<span class="lineNum">     132 </span>            : namespace tfm = tinyformat;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : // Error handling; calls assert() by default.
<span class="lineNum">     135 </span>            : #define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : // Define for C++11 variadic templates which make the code shorter &amp; more
<span class="lineNum">     138 </span>            : // general.  If you don't define this, C++11 support is autodetected below.
<span class="lineNum">     139 </span>            : #define TINYFORMAT_USE_VARIADIC_TEMPLATES
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">     143 </span>            : // Implementation details.
<span class="lineNum">     144 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">     145 </span>            : #include &lt;iostream&gt;
<span class="lineNum">     146 </span>            : #include &lt;sstream&gt;
<span class="lineNum">     147 </span>            : #include &lt;stdexcept&gt; // Added for Bitcoin Core
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : #ifndef TINYFORMAT_ASSERT
<span class="lineNum">     150 </span>            : #   include &lt;cassert&gt;
<span class="lineNum">     151 </span>            : #   define TINYFORMAT_ASSERT(cond) assert(cond)
<span class="lineNum">     152 </span>            : #endif
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : #ifndef TINYFORMAT_ERROR
<span class="lineNum">     155 </span>            : #   include &lt;cassert&gt;
<span class="lineNum">     156 </span>            : #   define TINYFORMAT_ERROR(reason) assert(0 &amp;&amp; reason)
<span class="lineNum">     157 </span>            : #endif
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : #if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) &amp;&amp; !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)
<span class="lineNum">     160 </span>            : #   ifdef __GXX_EXPERIMENTAL_CXX0X__
<span class="lineNum">     161 </span>            : #       define TINYFORMAT_USE_VARIADIC_TEMPLATES
<span class="lineNum">     162 </span>            : #   endif
<span class="lineNum">     163 </span>            : #endif
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : #if defined(__GLIBCXX__) &amp;&amp; __GLIBCXX__ &lt; 20080201
<span class="lineNum">     166 </span>            : //  std::showpos is broken on old libstdc++ as provided with macOS.  See
<span class="lineNum">     167 </span>            : //  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html
<span class="lineNum">     168 </span>            : #   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
<span class="lineNum">     169 </span>            : #endif
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : #ifdef __APPLE__
<span class="lineNum">     172 </span>            : // Workaround macOS linker warning: Xcode uses different default symbol
<span class="lineNum">     173 </span>            : // visibilities for static libs vs executables (see issue #25)
<span class="lineNum">     174 </span>            : #   define TINYFORMAT_HIDDEN __attribute__((visibility(&quot;hidden&quot;)))
<span class="lineNum">     175 </span>            : #else
<span class="lineNum">     176 </span>            : #   define TINYFORMAT_HIDDEN
<span class="lineNum">     177 </span>            : #endif
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : namespace tinyformat {
<a name="180"><span class="lineNum">     180 </span>            : </a>
<span class="lineNum">     181 </span>            : // Added for Bitcoin Core
<span class="lineNum">     182 </span><span class="lineNoCov">          0 : class format_error: public std::runtime_error</span>
<a name="183"><span class="lineNum">     183 </span>            : {</a>
<span class="lineNum">     184 </span>            : public:
<span class="lineNum">     185 </span><span class="lineCov">       5162 :     explicit format_error(const std::string &amp;what): std::runtime_error(what) {</span>
<span class="lineNum">     186 </span><span class="lineCov">       5162 :     }</span>
<span class="lineNum">     187 </span>            : };
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">     190 </span>            : namespace detail {
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : // Test whether type T1 is convertible to type T2
<span class="lineNum">     193 </span>            : template &lt;typename T1, typename T2&gt;
<span class="lineNum">     194 </span>            : struct is_convertible
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span>            :     private:
<span class="lineNum">     197 </span>            :         // two types of different size
<span class="lineNum">     198 </span>            :         struct fail { char dummy[2]; };
<span class="lineNum">     199 </span>            :         struct succeed { char dummy; };
<span class="lineNum">     200 </span>            :         // Try to convert a T1 to a T2 by plugging into tryConvert
<span class="lineNum">     201 </span>            :         static fail tryConvert(...);
<span class="lineNum">     202 </span>            :         static succeed tryConvert(const T2&amp;);
<span class="lineNum">     203 </span>            :         static const T1&amp; makeT1();
<span class="lineNum">     204 </span>            :     public:
<span class="lineNum">     205 </span>            : #       ifdef _MSC_VER
<span class="lineNum">     206 </span>            :         // Disable spurious loss of precision warnings in tryConvert(makeT1())
<span class="lineNum">     207 </span>            : #       pragma warning(push)
<span class="lineNum">     208 </span>            : #       pragma warning(disable:4244)
<span class="lineNum">     209 </span>            : #       pragma warning(disable:4267)
<span class="lineNum">     210 </span>            : #       endif
<span class="lineNum">     211 </span>            :         // Standard trick: the (...) version of tryConvert will be chosen from
<span class="lineNum">     212 </span>            :         // the overload set only if the version taking a T2 doesn't match.
<span class="lineNum">     213 </span>            :         // Then we compare the sizes of the return types to check which
<span class="lineNum">     214 </span>            :         // function matched.  Very neat, in a disgusting kind of way :)
<span class="lineNum">     215 </span>            :         static const bool value =
<span class="lineNum">     216 </span>            :             sizeof(tryConvert(makeT1())) == sizeof(succeed);
<span class="lineNum">     217 </span>            : #       ifdef _MSC_VER
<span class="lineNum">     218 </span>            : #       pragma warning(pop)
<span class="lineNum">     219 </span>            : #       endif
<span class="lineNum">     220 </span>            : };
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : // Detect when a type is not a wchar_t string
<span class="lineNum">     224 </span>            : template&lt;typename T&gt; struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };
<span class="lineNum">     225 </span>            : template&lt;&gt; struct is_wchar&lt;wchar_t*&gt; {};
<span class="lineNum">     226 </span>            : template&lt;&gt; struct is_wchar&lt;const wchar_t*&gt; {};
<span class="lineNum">     227 </span>            : template&lt;int n&gt; struct is_wchar&lt;const wchar_t[n]&gt; {};
<span class="lineNum">     228 </span>            : template&lt;int n&gt; struct is_wchar&lt;wchar_t[n]&gt; {};
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : // Format the value by casting to type fmtT.  This default implementation
<span class="lineNum">     232 </span>            : // should never be called.
<span class="lineNum">     233 </span>            : template&lt;typename T, typename fmtT, bool convertible = is_convertible&lt;T, fmtT&gt;::value&gt;
<span class="lineNum">     234 </span>            : struct formatValueAsType
<span class="lineNum">     235 </span>            : {
<span class="lineNum">     236 </span>            :     static void invoke(std::ostream&amp; /*out*/, const T&amp; /*value*/) { TINYFORMAT_ASSERT(0); }
<span class="lineNum">     237 </span>            : };
<span class="lineNum">     238 </span>            : // Specialized version for types that can actually be converted to fmtT, as
<span class="lineNum">     239 </span>            : // indicated by the &quot;convertible&quot; template parameter.
<span class="lineNum">     240 </span>            : template&lt;typename T, typename fmtT&gt;
<a name="241"><span class="lineNum">     241 </span>            : struct formatValueAsType&lt;T,fmtT,true&gt;</a>
<span class="lineNum">     242 </span>            : {
<span class="lineNum">     243 </span><span class="lineCov">       2976 :     static void invoke(std::ostream&amp; out, const T&amp; value)</span>
<span class="lineNum">     244 </span><span class="lineCov">       2976 :         { out &lt;&lt; static_cast&lt;fmtT&gt;(value); }</span>
<span class="lineNum">     245 </span>            : };
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
<span class="lineNum">     248 </span>            : template&lt;typename T, bool convertible = is_convertible&lt;T, int&gt;::value&gt;
<span class="lineNum">     249 </span>            : struct formatZeroIntegerWorkaround
<span class="lineNum">     250 </span>            : {
<span class="lineNum">     251 </span>            :     static bool invoke(std::ostream&amp; /**/, const T&amp; /**/) { return false; }
<span class="lineNum">     252 </span>            : };
<span class="lineNum">     253 </span>            : template&lt;typename T&gt;
<span class="lineNum">     254 </span>            : struct formatZeroIntegerWorkaround&lt;T,true&gt;
<span class="lineNum">     255 </span>            : {
<span class="lineNum">     256 </span>            :     static bool invoke(std::ostream&amp; out, const T&amp; value)
<span class="lineNum">     257 </span>            :     {
<span class="lineNum">     258 </span>            :         if (static_cast&lt;int&gt;(value) == 0 &amp;&amp; out.flags() &amp; std::ios::showpos) {
<span class="lineNum">     259 </span>            :             out &lt;&lt; &quot;+0&quot;;
<span class="lineNum">     260 </span>            :             return true;
<span class="lineNum">     261 </span>            :         }
<span class="lineNum">     262 </span>            :         return false;
<span class="lineNum">     263 </span>            :     }
<span class="lineNum">     264 </span>            : };
<span class="lineNum">     265 </span>            : #endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : // Convert an arbitrary type to integer.  The version with convertible=false
<span class="lineNum">     268 </span>            : // throws an error.
<span class="lineNum">     269 </span>            : template&lt;typename T, bool convertible = is_convertible&lt;T,int&gt;::value&gt;
<a name="270"><span class="lineNum">     270 </span>            : struct convertToInt</a>
<span class="lineNum">     271 </span>            : {
<span class="lineNum">     272 </span><span class="lineCov">        762 :     static int invoke(const T&amp; /*value*/)</span>
<span class="lineNum">     273 </span>            :     {
<span class="lineNum">     274 </span><span class="lineCov">        762 :         TINYFORMAT_ERROR(&quot;tinyformat: Cannot convert from argument type to &quot;</span>
<span class="lineNum">     275 </span>            :                          &quot;integer for use as variable width or precision&quot;);
<span class="lineNum">     276 </span>            :         return 0;
<span class="lineNum">     277 </span><span class="lineCov">        762 :     }</span>
<span class="lineNum">     278 </span>            : };
<span class="lineNum">     279 </span>            : // Specialization for convertToInt when conversion is possible
<span class="lineNum">     280 </span>            : template&lt;typename T&gt;
<a name="281"><span class="lineNum">     281 </span>            : struct convertToInt&lt;T,true&gt;</a>
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span><span class="lineCov">         57 :     static int invoke(const T&amp; value) { return static_cast&lt;int&gt;(value); }</span>
<span class="lineNum">     284 </span>            : };
<span class="lineNum">     285 </span>            : 
<a name="286"><span class="lineNum">     286 </span>            : // Format at most ntrunc characters to the given stream.</a>
<span class="lineNum">     287 </span>            : template&lt;typename T&gt;
<span class="lineNum">     288 </span><span class="lineCov">      13901 : inline void formatTruncated(std::ostream&amp; out, const T&amp; value, int ntrunc)</span>
<span class="lineNum">     289 </span>            : {
<span class="lineNum">     290 </span><span class="lineCov">      13901 :     std::ostringstream tmp;</span>
<span class="lineNum">     291 </span><span class="lineCov">      13901 :     tmp &lt;&lt; value;</span>
<span class="lineNum">     292 </span><span class="lineCov">      13901 :     std::string result = tmp.str();</span>
<span class="lineNum">     293 </span><span class="lineCov">      13901 :     out.write(result.c_str(), (std::min)(ntrunc, static_cast&lt;int&gt;(result.size())));</span>
<span class="lineNum">     294 </span><span class="lineCov">      13901 : }</span>
<span class="lineNum">     295 </span>            : #define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \
<span class="lineNum">     296 </span>            : inline void formatTruncated(std::ostream&amp; out, type* value, int ntrunc) \
<span class="lineNum">     297 </span>            : {                                                           \
<span class="lineNum">     298 </span>            :     std::streamsize len = 0;                                \
<span class="lineNum">     299 </span>            :     while (len &lt; ntrunc &amp;&amp; value[len] != 0)                 \
<span class="lineNum">     300 </span>            :         ++len;                                              \
<span class="lineNum">     301 </span>            :     out.write(value, len);                                  \
<span class="lineNum">     302 </span>            : }
<a name="303"><span class="lineNum">     303 </span>            : // Overload for const char* and char*.  Could overload for signed &amp; unsigned</a>
<a name="304"><span class="lineNum">     304 </span>            : // char too, but these are technically unneeded for printf compatibility.</a>
<span class="lineNum">     305 </span><span class="lineCov">        424 : TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 : TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)</span>
<span class="lineNum">     307 </span>            : #undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : } // namespace detail
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">     313 </span>            : // Variable formatting functions.  May be overridden for user-defined types if
<span class="lineNum">     314 </span>            : // desired.
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : /// Format a value into a stream, delegating to operator&lt;&lt; by default.
<span class="lineNum">     318 </span>            : ///
<span class="lineNum">     319 </span>            : /// Users may override this for their own types.  When this function is called,
<span class="lineNum">     320 </span>            : /// the stream flags will have been modified according to the format string.
<span class="lineNum">     321 </span>            : /// The format specification is provided in the range [fmtBegin, fmtEnd).  For
<span class="lineNum">     322 </span>            : /// truncating conversions, ntrunc is set to the desired maximum number of
<span class="lineNum">     323 </span>            : /// characters, for example &quot;%.7s&quot; calls formatValue with ntrunc = 7.
<span class="lineNum">     324 </span>            : ///
<span class="lineNum">     325 </span>            : /// By default, formatValue() uses the usual stream insertion operator
<span class="lineNum">     326 </span>            : /// operator&lt;&lt; to format the type T, with special cases for the %c and %p
<a name="327"><span class="lineNum">     327 </span>            : /// conversions.</a>
<span class="lineNum">     328 </span>            : template&lt;typename T&gt;
<span class="lineNum">     329 </span><span class="lineCov">    7383719 : inline void formatValue(std::ostream&amp; out, const char* /*fmtBegin*/,</span>
<span class="lineNum">     330 </span>            :                         const char* fmtEnd, int ntrunc, const T&amp; value)
<span class="lineNum">     331 </span>            : {
<span class="lineNum">     332 </span>            : #ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
<span class="lineNum">     333 </span>            :     // Since we don't support printing of wchar_t using &quot;%ls&quot;, make it fail at
<span class="lineNum">     334 </span>            :     // compile time in preference to printing as a void* at runtime.
<span class="lineNum">     335 </span>            :     typedef typename detail::is_wchar&lt;T&gt;::tinyformat_wchar_is_not_supported DummyType;
<span class="lineNum">     336 </span>            :     (void) DummyType(); // avoid unused type warning with gcc-4.8
<span class="lineNum">     337 </span>            : #endif
<span class="lineNum">     338 </span>            :     // The mess here is to support the %c and %p conversions: if these
<span class="lineNum">     339 </span>            :     // conversions are active we try to convert the type to a char or const
<span class="lineNum">     340 </span>            :     // void* respectively and format that instead of the value itself.  For the
<span class="lineNum">     341 </span>            :     // %p conversion it's important to avoid dereferencing the pointer, which
<span class="lineNum">     342 </span>            :     // could otherwise lead to a crash when printing a dangling (const char*).
<span class="lineNum">     343 </span>            :     const bool canConvertToChar = detail::is_convertible&lt;T,char&gt;::value;
<span class="lineNum">     344 </span>            :     const bool canConvertToVoidPtr = detail::is_convertible&lt;T, const void*&gt;::value;
<span class="lineNum">     345 </span><span class="lineCov">    5306851 :     if (canConvertToChar &amp;&amp; *(fmtEnd-1) == 'c')</span>
<span class="lineNum">     346 </span><span class="lineCov">         51 :         detail::formatValueAsType&lt;T, char&gt;::invoke(out, value);</span>
<span class="lineNum">     347 </span><span class="lineCov">     269607 :     else if (canConvertToVoidPtr &amp;&amp; *(fmtEnd-1) == 'p')</span>
<span class="lineNum">     348 </span><span class="lineCov">       2925 :         detail::formatValueAsType&lt;T, const void*&gt;::invoke(out, value);</span>
<span class="lineNum">     349 </span>            : #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
<span class="lineNum">     350 </span>            :     else if (detail::formatZeroIntegerWorkaround&lt;T&gt;::invoke(out, value)) /**/;
<span class="lineNum">     351 </span>            : #endif
<span class="lineNum">     352 </span><span class="lineCov">    7380743 :     else if (ntrunc &gt;= 0) {</span>
<span class="lineNum">     353 </span>            :         // Take care not to overread C strings in truncating conversions like
<span class="lineNum">     354 </span>            :         // &quot;%.4s&quot; where at most 4 characters may be read.
<span class="lineNum">     355 </span><span class="lineCov">      14051 :         detail::formatTruncated(out, value, ntrunc);</span>
<span class="lineNum">     356 </span><span class="lineCov">      14051 :     }</span>
<span class="lineNum">     357 </span>            :     else
<span class="lineNum">     358 </span><span class="lineCov">    7366692 :         out &lt;&lt; value;</span>
<span class="lineNum">     359 </span><span class="lineCov">    7383721 : }</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : // Overloaded version for char types to support printing as an integer
<span class="lineNum">     363 </span>            : #define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \
<span class="lineNum">     364 </span>            : inline void formatValue(std::ostream&amp; out, const char* /*fmtBegin*/,  \
<span class="lineNum">     365 </span>            :                         const char* fmtEnd, int /**/, charType value) \
<span class="lineNum">     366 </span>            : {                                                                     \
<span class="lineNum">     367 </span>            :     switch (*(fmtEnd-1)) {                                            \
<span class="lineNum">     368 </span>            :         case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \
<span class="lineNum">     369 </span>            :             out &lt;&lt; static_cast&lt;int&gt;(value); break;                    \
<span class="lineNum">     370 </span>            :         default:                                                      \
<span class="lineNum">     371 </span>            :             out &lt;&lt; value;                   break;                    \
<span class="lineNum">     372 </span>            :     }                                                                 \
<a name="373"><span class="lineNum">     373 </span>            : }</a>
<a name="374"><span class="lineNum">     374 </span>            : // per 3.9.1: char, signed char and unsigned char are all distinct types</a>
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">        585 : TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)</span></a>
<span class="lineNum">     376 </span><span class="lineCov">        674 : TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)</span>
<span class="lineNum">     377 </span><span class="lineCov">       2327 : TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)</span>
<span class="lineNum">     378 </span>            : #undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">     382 </span>            : // Tools for emulating variadic templates in C++98.  The basic idea here is
<span class="lineNum">     383 </span>            : // stolen from the boost preprocessor metaprogramming library and cut down to
<span class="lineNum">     384 </span>            : // be just general enough for what we need.
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : #define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n
<span class="lineNum">     387 </span>            : #define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n
<span class="lineNum">     388 </span>            : #define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n
<span class="lineNum">     389 </span>            : #define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : // To keep it as transparent as possible, the macros below have been generated
<span class="lineNum">     392 </span>            : // using python via the excellent cog.py code generation script.  This avoids
<span class="lineNum">     393 </span>            : // the need for a bunch of complex (but more general) preprocessor tricks as
<span class="lineNum">     394 </span>            : // used in boost.preprocessor.
<span class="lineNum">     395 </span>            : //
<span class="lineNum">     396 </span>            : // To rerun the code generation in place, use `cog.py -r tinyformat.h`
<span class="lineNum">     397 </span>            : // (see http://nedbatchelder.com/code/cog).  Alternatively you can just create
<span class="lineNum">     398 </span>            : // extra versions by hand.
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : /*[[[cog
<span class="lineNum">     401 </span>            : maxParams = 16
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
<span class="lineNum">     404 </span>            :     for j in range(startInd,maxParams+1):
<span class="lineNum">     405 </span>            :         list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
<span class="lineNum">     406 </span>            :         cog.outl(lineTemplate % {'j':j, 'list':list})
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
<span class="lineNum">     409 </span>            :                   'class T%(i)d')
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : cog.outl()
<span class="lineNum">     412 </span>            : makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
<span class="lineNum">     413 </span>            :                   'const T%(i)d&amp; v%(i)d')
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : cog.outl()
<span class="lineNum">     416 </span>            : makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : cog.outl()
<span class="lineNum">     419 </span>            : cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
<span class="lineNum">     420 </span>            : makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
<span class="lineNum">     421 </span>            :                   'v%(i)d', startInd = 2)
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : cog.outl()
<span class="lineNum">     424 </span>            : cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
<span class="lineNum">     425 </span>            :          ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
<span class="lineNum">     426 </span>            : ]]]*/
<span class="lineNum">     427 </span>            : #define TINYFORMAT_ARGTYPES_1 class T1
<span class="lineNum">     428 </span>            : #define TINYFORMAT_ARGTYPES_2 class T1, class T2
<span class="lineNum">     429 </span>            : #define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3
<span class="lineNum">     430 </span>            : #define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4
<span class="lineNum">     431 </span>            : #define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5
<span class="lineNum">     432 </span>            : #define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6
<span class="lineNum">     433 </span>            : #define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7
<span class="lineNum">     434 </span>            : #define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8
<span class="lineNum">     435 </span>            : #define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9
<span class="lineNum">     436 </span>            : #define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10
<span class="lineNum">     437 </span>            : #define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11
<span class="lineNum">     438 </span>            : #define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12
<span class="lineNum">     439 </span>            : #define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13
<span class="lineNum">     440 </span>            : #define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14
<span class="lineNum">     441 </span>            : #define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15
<span class="lineNum">     442 </span>            : #define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : #define TINYFORMAT_VARARGS_1 const T1&amp; v1
<span class="lineNum">     445 </span>            : #define TINYFORMAT_VARARGS_2 const T1&amp; v1, const T2&amp; v2
<span class="lineNum">     446 </span>            : #define TINYFORMAT_VARARGS_3 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3
<span class="lineNum">     447 </span>            : #define TINYFORMAT_VARARGS_4 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4
<span class="lineNum">     448 </span>            : #define TINYFORMAT_VARARGS_5 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5
<span class="lineNum">     449 </span>            : #define TINYFORMAT_VARARGS_6 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6
<span class="lineNum">     450 </span>            : #define TINYFORMAT_VARARGS_7 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7
<span class="lineNum">     451 </span>            : #define TINYFORMAT_VARARGS_8 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8
<span class="lineNum">     452 </span>            : #define TINYFORMAT_VARARGS_9 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9
<span class="lineNum">     453 </span>            : #define TINYFORMAT_VARARGS_10 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10
<span class="lineNum">     454 </span>            : #define TINYFORMAT_VARARGS_11 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11
<span class="lineNum">     455 </span>            : #define TINYFORMAT_VARARGS_12 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12
<span class="lineNum">     456 </span>            : #define TINYFORMAT_VARARGS_13 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13
<span class="lineNum">     457 </span>            : #define TINYFORMAT_VARARGS_14 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13, const T14&amp; v14
<span class="lineNum">     458 </span>            : #define TINYFORMAT_VARARGS_15 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13, const T14&amp; v14, const T15&amp; v15
<span class="lineNum">     459 </span>            : #define TINYFORMAT_VARARGS_16 const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13, const T14&amp; v14, const T15&amp; v15, const T16&amp; v16
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : #define TINYFORMAT_PASSARGS_1 v1
<span class="lineNum">     462 </span>            : #define TINYFORMAT_PASSARGS_2 v1, v2
<span class="lineNum">     463 </span>            : #define TINYFORMAT_PASSARGS_3 v1, v2, v3
<span class="lineNum">     464 </span>            : #define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4
<span class="lineNum">     465 </span>            : #define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5
<span class="lineNum">     466 </span>            : #define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6
<span class="lineNum">     467 </span>            : #define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7
<span class="lineNum">     468 </span>            : #define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8
<span class="lineNum">     469 </span>            : #define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9
<span class="lineNum">     470 </span>            : #define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10
<span class="lineNum">     471 </span>            : #define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
<span class="lineNum">     472 </span>            : #define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
<span class="lineNum">     473 </span>            : #define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
<span class="lineNum">     474 </span>            : #define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
<span class="lineNum">     475 </span>            : #define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
<span class="lineNum">     476 </span>            : #define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : #define TINYFORMAT_PASSARGS_TAIL_1
<span class="lineNum">     479 </span>            : #define TINYFORMAT_PASSARGS_TAIL_2 , v2
<span class="lineNum">     480 </span>            : #define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3
<span class="lineNum">     481 </span>            : #define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4
<span class="lineNum">     482 </span>            : #define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5
<span class="lineNum">     483 </span>            : #define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6
<span class="lineNum">     484 </span>            : #define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7
<span class="lineNum">     485 </span>            : #define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8
<span class="lineNum">     486 </span>            : #define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9
<span class="lineNum">     487 </span>            : #define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10
<span class="lineNum">     488 </span>            : #define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
<span class="lineNum">     489 </span>            : #define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
<span class="lineNum">     490 </span>            : #define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
<span class="lineNum">     491 </span>            : #define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
<span class="lineNum">     492 </span>            : #define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
<span class="lineNum">     493 </span>            : #define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : #define TINYFORMAT_FOREACH_ARGNUM(m) \
<span class="lineNum">     496 </span>            :     m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)
<span class="lineNum">     497 </span>            : //[[[end]]]
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : namespace detail {
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : // Type-opaque holder for an argument to format(), with associated actions on
<span class="lineNum">     504 </span>            : // the type held as explicit function pointers.  This allows FormatArg's for
<span class="lineNum">     505 </span>            : // each argument to be allocated as a homogeneous array inside FormatList
<span class="lineNum">     506 </span>            : // whereas a naive implementation based on inheritance does not.
<span class="lineNum">     507 </span>            : class FormatArg
<span class="lineNum">     508 </span>            : {
<span class="lineNum">     509 </span>            :     public:
<span class="lineNum">     510 </span>            :         FormatArg()
<span class="lineNum">     511 </span>            :             : m_value(NULL),
<span class="lineNum">     512 </span>            :             m_formatImpl(NULL),
<span class="lineNum">     513 </span>            :             m_toIntImpl(NULL)
<span class="lineNum">     514 </span>            :         { }
<a name="515"><span class="lineNum">     515 </span>            : </a>
<span class="lineNum">     516 </span>            :         template&lt;typename T&gt;
<span class="lineNum">     517 </span><span class="lineCov">    7364882 :         FormatArg(const T&amp; value)</span>
<span class="lineNum">     518 </span><span class="lineCov">    7364882 :             : m_value(static_cast&lt;const void*&gt;(&amp;value)),</span>
<span class="lineNum">     519 </span><span class="lineCov">    7364882 :             m_formatImpl(&amp;formatImpl&lt;T&gt;),</span>
<span class="lineNum">     520 </span><span class="lineCov">    7364882 :             m_toIntImpl(&amp;toIntImpl&lt;T&gt;)</span>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">    7364882 :         { }</span></a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineCov">    7387305 :         void format(std::ostream&amp; out, const char* fmtBegin,</span>
<span class="lineNum">     524 </span>            :                     const char* fmtEnd, int ntrunc) const
<span class="lineNum">     525 </span>            :         {
<span class="lineNum">     526 </span><span class="lineCov">    7387305 :             TINYFORMAT_ASSERT(m_value);</span>
<span class="lineNum">     527 </span><span class="lineCov">    7387305 :             TINYFORMAT_ASSERT(m_formatImpl);</span>
<span class="lineNum">     528 </span><span class="lineCov">    7387305 :             m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);</span>
<a name="529"><span class="lineNum">     529 </span><span class="lineCov">    7387305 :         }</span></a>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineCov">        819 :         int toInt() const</span>
<span class="lineNum">     532 </span>            :         {
<span class="lineNum">     533 </span><span class="lineCov">        819 :             TINYFORMAT_ASSERT(m_value);</span>
<span class="lineNum">     534 </span><span class="lineCov">        819 :             TINYFORMAT_ASSERT(m_toIntImpl);</span>
<span class="lineNum">     535 </span><span class="lineCov">        819 :             return m_toIntImpl(m_value);</span>
<span class="lineNum">     536 </span>            :         }
<span class="lineNum">     537 </span>            : 
<a name="538"><span class="lineNum">     538 </span>            :     private:</a>
<span class="lineNum">     539 </span>            :         template&lt;typename T&gt;
<span class="lineNum">     540 </span><span class="lineCov">    7387305 :         TINYFORMAT_HIDDEN static void formatImpl(std::ostream&amp; out, const char* fmtBegin,</span>
<span class="lineNum">     541 </span>            :                         const char* fmtEnd, int ntrunc, const void* value)
<span class="lineNum">     542 </span>            :         {
<span class="lineNum">     543 </span><span class="lineCov">    7387305 :             formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast&lt;const T*&gt;(value));</span>
<span class="lineNum">     544 </span><span class="lineCov">    7387305 :         }</span>
<a name="545"><span class="lineNum">     545 </span>            : </a>
<span class="lineNum">     546 </span>            :         template&lt;typename T&gt;
<span class="lineNum">     547 </span><span class="lineCov">        819 :         TINYFORMAT_HIDDEN static int toIntImpl(const void* value)</span>
<span class="lineNum">     548 </span>            :         {
<span class="lineNum">     549 </span><span class="lineCov">        819 :             return convertToInt&lt;T&gt;::invoke(*static_cast&lt;const T*&gt;(value));</span>
<span class="lineNum">     550 </span>            :         }
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :         const void* m_value;
<span class="lineNum">     553 </span>            :         void (*m_formatImpl)(std::ostream&amp; out, const char* fmtBegin,
<span class="lineNum">     554 </span>            :                              const char* fmtEnd, int ntrunc, const void* value);
<span class="lineNum">     555 </span>            :         int (*m_toIntImpl)(const void* value);
<span class="lineNum">     556 </span>            : };
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            : 
<a name="559"><span class="lineNum">     559 </span>            : // Parse and return an integer from the string c, as atoi()</a>
<span class="lineNum">     560 </span>            : // On return, c is set to one past the end of the integer.
<span class="lineNum">     561 </span><span class="lineCov">    1560875 : inline int parseIntAndAdvance(const char*&amp; c)</span>
<span class="lineNum">     562 </span>            : {
<span class="lineNum">     563 </span>            :     int i = 0;
<span class="lineNum">     564 </span><span class="lineCov">    4661926 :     for (;*c &gt;= '0' &amp;&amp; *c &lt;= '9'; ++c)</span>
<span class="lineNum">     565 </span><span class="lineCov">    3101051 :         i = 10*i + (*c - '0');</span>
<span class="lineNum">     566 </span><span class="lineCov">    1560875 :     return i;</span>
<span class="lineNum">     567 </span>            : }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : // Parse width or precision `n` from format string pointer `c`, and advance it
<span class="lineNum">     570 </span>            : // to the next character. If an indirection is requested with `*`, the argument
<span class="lineNum">     571 </span>            : // is read from `args[argIndex]` and `argIndex` is incremented (or read
<a name="572"><span class="lineNum">     572 </span>            : // from `args[n]` in positional mode). Returns true if one or more</a>
<span class="lineNum">     573 </span>            : // characters were read.
<span class="lineNum">     574 </span><span class="lineCov">    5880157 : inline bool parseWidthOrPrecision(int&amp; n, const char*&amp; c, bool positionalMode,</span>
<span class="lineNum">     575 </span>            :                                   const detail::FormatArg* args,
<span class="lineNum">     576 </span>            :                                   int&amp; argIndex, int numArgs)
<span class="lineNum">     577 </span>            : {
<span class="lineNum">     578 </span><span class="lineCov">    5880157 :     if (*c &gt;= '0' &amp;&amp; *c &lt;= '9') {</span>
<span class="lineNum">     579 </span><span class="lineCov">       7587 :         n = parseIntAndAdvance(c);</span>
<span class="lineNum">     580 </span><span class="lineCov">       7587 :     }</span>
<span class="lineNum">     581 </span><span class="lineCov">    5872570 :     else if (*c == '*') {</span>
<span class="lineNum">     582 </span><span class="lineCov">        833 :         ++c;</span>
<span class="lineNum">     583 </span><span class="lineCov">        833 :         n = 0;</span>
<span class="lineNum">     584 </span><span class="lineCov">        833 :         if (positionalMode) {</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :             int pos = parseIntAndAdvance(c) - 1;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :             if (*c != '$')</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 TINYFORMAT_ERROR(&quot;tinyformat: Non-positional argument used after a positional one&quot;);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :             if (pos &gt;= 0 &amp;&amp; pos &lt; numArgs)</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                 n = args[pos].toInt();</span>
<span class="lineNum">     590 </span>            :             else
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 TINYFORMAT_ERROR(&quot;tinyformat: Positional argument out of range&quot;);</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :             ++c;</span>
<span class="lineNum">     593 </span><span class="lineCov">         14 :         }</span>
<span class="lineNum">     594 </span>            :         else {
<span class="lineNum">     595 </span><span class="lineCov">        833 :             if (argIndex &lt; numArgs)</span>
<span class="lineNum">     596 </span><span class="lineCov">        819 :                 n = args[argIndex++].toInt();</span>
<span class="lineNum">     597 </span>            :             else
<span class="lineNum">     598 </span><span class="lineCov">         14 :                 TINYFORMAT_ERROR(&quot;tinyformat: Not enough arguments to read variable width or precision&quot;);</span>
<span class="lineNum">     599 </span>            :         }
<span class="lineNum">     600 </span>            :     }
<span class="lineNum">     601 </span>            :     else {
<span class="lineNum">     602 </span><span class="lineCov">    5871737 :         return false;</span>
<span class="lineNum">     603 </span>            :     }
<span class="lineNum">     604 </span><span class="lineCov">       7644 :     return true;</span>
<span class="lineNum">     605 </span><span class="lineCov">    5879395 : }</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            : // Print literal part of format string and return next format spec position.
<span class="lineNum">     608 </span>            : //
<span class="lineNum">     609 </span>            : // Skips over any occurrences of '%%', printing a literal '%' to the output.
<a name="610"><span class="lineNum">     610 </span>            : // The position of the first % character of the next nontrivial format spec is</a>
<span class="lineNum">     611 </span>            : // returned, or the end of string.
<span class="lineNum">     612 </span><span class="lineCov">   11806135 : inline const char* printFormatStringLiteral(std::ostream&amp; out, const char* fmt)</span>
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span>            :     const char* c = fmt;
<span class="lineNum">     615 </span><span class="lineCov">   79004258 :     for (;; ++c) {</span>
<span class="lineNum">     616 </span><span class="lineCov">   79004258 :         if (*c == '\0') {</span>
<span class="lineNum">     617 </span><span class="lineCov">    4414772 :             out.write(fmt, c - fmt);</span>
<span class="lineNum">     618 </span><span class="lineCov">    4414772 :             return c;</span>
<span class="lineNum">     619 </span>            :         }
<span class="lineNum">     620 </span><span class="lineCov">   74589486 :         else if (*c == '%') {</span>
<span class="lineNum">     621 </span><span class="lineCov">    7392420 :             out.write(fmt, c - fmt);</span>
<span class="lineNum">     622 </span><span class="lineCov">    7392420 :             if (*(c+1) != '%')</span>
<span class="lineNum">     623 </span><span class="lineCov">    7391365 :                 return c;</span>
<span class="lineNum">     624 </span>            :             // for &quot;%%&quot;, tack trailing % onto next literal section.
<span class="lineNum">     625 </span><span class="lineCov">       1057 :             fmt = ++c;</span>
<span class="lineNum">     626 </span><span class="lineCov">       1057 :         }</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span><span class="lineCov">   11806137 : }</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            : // Parse a format string and set the stream state accordingly.
<span class="lineNum">     632 </span>            : //
<span class="lineNum">     633 </span>            : // The format mini-language recognized here is meant to be the one from C99,
<span class="lineNum">     634 </span>            : // with the form &quot;%[flags][width][.precision][length]type&quot; with POSIX
<span class="lineNum">     635 </span>            : // positional arguments extension.
<span class="lineNum">     636 </span>            : //
<span class="lineNum">     637 </span>            : // POSIX positional arguments extension:
<span class="lineNum">     638 </span>            : // Conversions can be applied to the nth argument after the format in
<span class="lineNum">     639 </span>            : // the argument list, rather than to the next unused argument. In this case,
<span class="lineNum">     640 </span>            : // the conversion specifier character % (see below) is replaced by the sequence
<span class="lineNum">     641 </span>            : // &quot;%n$&quot;, where n is a decimal integer in the range [1,{NL_ARGMAX}],
<span class="lineNum">     642 </span>            : // giving the position of the argument in the argument list. This feature
<span class="lineNum">     643 </span>            : // provides for the definition of format strings that select arguments
<span class="lineNum">     644 </span>            : // in an order appropriate to specific languages.
<span class="lineNum">     645 </span>            : //
<span class="lineNum">     646 </span>            : // The format can contain either numbered argument conversion specifications
<span class="lineNum">     647 </span>            : // (that is, &quot;%n$&quot; and &quot;*m$&quot;), or unnumbered argument conversion specifications
<span class="lineNum">     648 </span>            : // (that is, % and * ), but not both. The only exception to this is that %%
<span class="lineNum">     649 </span>            : // can be mixed with the &quot;%n$&quot; form. The results of mixing numbered and
<span class="lineNum">     650 </span>            : // unnumbered argument specifications in a format string are undefined.
<span class="lineNum">     651 </span>            : // When numbered argument specifications are used, specifying the Nth argument
<span class="lineNum">     652 </span>            : // requires that all the leading arguments, from the first to the (N-1)th,
<span class="lineNum">     653 </span>            : // are specified in the format string.
<span class="lineNum">     654 </span>            : //
<span class="lineNum">     655 </span>            : // In format strings containing the &quot;%n$&quot; form of conversion specification,
<span class="lineNum">     656 </span>            : // numbered arguments in the argument list can be referenced from the format
<span class="lineNum">     657 </span>            : // string as many times as required.
<span class="lineNum">     658 </span>            : //
<span class="lineNum">     659 </span>            : // Formatting options which can't be natively represented using the ostream
<span class="lineNum">     660 </span>            : // state are returned in spacePadPositive (for space padded positive numbers)
<span class="lineNum">     661 </span>            : // and ntrunc (for truncating conversions).  argIndex is incremented if
<a name="662"><span class="lineNum">     662 </span>            : // necessary to pull out variable width and precision.  The function returns a</a>
<span class="lineNum">     663 </span>            : // pointer to the character after the end of the current format spec.
<span class="lineNum">     664 </span><span class="lineCov">    7391365 : inline const char* streamStateFromFormat(std::ostream&amp; out, bool&amp; positionalMode,</span>
<span class="lineNum">     665 </span>            :                                          bool&amp; spacePadPositive,
<span class="lineNum">     666 </span>            :                                          int&amp; ntrunc, const char* fmtStart,
<span class="lineNum">     667 </span>            :                                          const detail::FormatArg* args,
<span class="lineNum">     668 </span>            :                                          int&amp; argIndex, int numArgs)
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span><span class="lineCov">    7391365 :     TINYFORMAT_ASSERT(*fmtStart == '%');</span>
<span class="lineNum">     671 </span>            :     // Reset stream state to defaults.
<span class="lineNum">     672 </span><span class="lineCov">    7391364 :     out.width(0);</span>
<span class="lineNum">     673 </span><span class="lineCov">    7391364 :     out.precision(6);</span>
<span class="lineNum">     674 </span><span class="lineCov">    7391364 :     out.fill(' ');</span>
<span class="lineNum">     675 </span>            :     // Reset most flags; ignore irrelevant unitbuf &amp; skipws.
<span class="lineNum">     676 </span><span class="lineCov">   14782728 :     out.unsetf(std::ios::adjustfield | std::ios::basefield |</span>
<span class="lineNum">     677 </span><span class="lineCov">    7391364 :                std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |</span>
<span class="lineNum">     678 </span><span class="lineCov">    7391364 :                std::ios::showpoint | std::ios::showpos | std::ios::uppercase);</span>
<span class="lineNum">     679 </span>            :     bool precisionSet = false;
<span class="lineNum">     680 </span><span class="lineCov">    7390666 :     bool widthSet = false;</span>
<span class="lineNum">     681 </span><span class="lineCov">    7389915 :     int widthExtra = 0;</span>
<span class="lineNum">     682 </span><span class="lineCov">    7391364 :     const char* c = fmtStart + 1;</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :     // 1) Parse an argument index (if followed by '$') or a width possibly
<span class="lineNum">     685 </span>            :     // preceded with '0' flag.
<span class="lineNum">     686 </span><span class="lineCov">    7391364 :     if (*c &gt;= '0' &amp;&amp; *c &lt;= '9') {</span>
<span class="lineNum">     687 </span>            :         const char tmpc = *c;
<span class="lineNum">     688 </span><span class="lineCov">    1553288 :         int value = parseIntAndAdvance(c);</span>
<span class="lineNum">     689 </span><span class="lineCov">    1553288 :         if (*c == '$') {</span>
<span class="lineNum">     690 </span>            :             // value is an argument index
<span class="lineNum">     691 </span><span class="lineCov">      25893 :             if (value &gt; 0 &amp;&amp; value &lt;= numArgs)</span>
<span class="lineNum">     692 </span><span class="lineCov">      25865 :                 argIndex = value - 1;</span>
<span class="lineNum">     693 </span>            :             else
<span class="lineNum">     694 </span><span class="lineCov">         28 :                 TINYFORMAT_ERROR(&quot;tinyformat: Positional argument out of range&quot;);</span>
<span class="lineNum">     695 </span><span class="lineCov">      25865 :             ++c;</span>
<span class="lineNum">     696 </span><span class="lineCov">      25865 :             positionalMode = true;</span>
<span class="lineNum">     697 </span><span class="lineCov">      25865 :         }</span>
<span class="lineNum">     698 </span><span class="lineCov">    1527395 :         else if (positionalMode) {</span>
<span class="lineNum">     699 </span><span class="lineCov">         69 :             TINYFORMAT_ERROR(&quot;tinyformat: Non-positional argument used after a positional one&quot;);</span>
<span class="lineNum">     700 </span>            :         }
<span class="lineNum">     701 </span>            :         else {
<span class="lineNum">     702 </span><span class="lineCov">    1527326 :             if (tmpc == '0') {</span>
<span class="lineNum">     703 </span>            :                 // Use internal padding so that numeric values are
<span class="lineNum">     704 </span>            :                 // formatted correctly, eg -00010 rather than 000-10
<span class="lineNum">     705 </span><span class="lineCov">    1524627 :                 out.fill('0');</span>
<span class="lineNum">     706 </span><span class="lineCov">    1524627 :                 out.setf(std::ios::internal, std::ios::adjustfield);</span>
<span class="lineNum">     707 </span><span class="lineCov">    1524627 :             }</span>
<span class="lineNum">     708 </span><span class="lineCov">    1527326 :             if (value != 0) {</span>
<span class="lineNum">     709 </span>            :                 // Nonzero value means that we parsed width.
<span class="lineNum">     710 </span>            :                 widthSet = true;
<span class="lineNum">     711 </span><span class="lineCov">    1527228 :                 out.width(value);</span>
<span class="lineNum">     712 </span><span class="lineCov">    1527228 :             }</span>
<span class="lineNum">     713 </span>            :         }
<span class="lineNum">     714 </span><span class="lineCov">    1553288 :     }</span>
<span class="lineNum">     715 </span><span class="lineCov">    5838076 :     else if (positionalMode) {</span>
<span class="lineNum">     716 </span><span class="lineCov">        601 :         TINYFORMAT_ERROR(&quot;tinyformat: Non-positional argument used after a positional one&quot;);</span>
<span class="lineNum">     717 </span>            :     }
<span class="lineNum">     718 </span>            :     // 2) Parse flags and width if we did not do it in previous step.
<span class="lineNum">     719 </span><span class="lineCov">    7390666 :     if (!widthSet) {</span>
<span class="lineNum">     720 </span>            :         // Parse flags
<span class="lineNum">     721 </span><span class="lineCov">      19062 :         for (;; ++c) {</span>
<span class="lineNum">     722 </span><span class="lineCov">    5882500 :             switch (*c) {</span>
<span class="lineNum">     723 </span>            :                 case '#':
<span class="lineNum">     724 </span><span class="lineCov">       4412 :                     out.setf(std::ios::showpoint | std::ios::showbase);</span>
<span class="lineNum">     725 </span><span class="lineCov">       4412 :                     continue;</span>
<span class="lineNum">     726 </span>            :                 case '0':
<span class="lineNum">     727 </span>            :                     // overridden by left alignment ('-' flag)
<span class="lineNum">     728 </span><span class="lineCov">        480 :                     if (!(out.flags() &amp; std::ios::left)) {</span>
<span class="lineNum">     729 </span>            :                         // Use internal padding so that numeric values are
<span class="lineNum">     730 </span>            :                         // formatted correctly, eg -00010 rather than 000-10
<span class="lineNum">     731 </span><span class="lineCov">        240 :                         out.fill('0');</span>
<span class="lineNum">     732 </span><span class="lineCov">        240 :                         out.setf(std::ios::internal, std::ios::adjustfield);</span>
<span class="lineNum">     733 </span><span class="lineCov">        240 :                     }</span>
<span class="lineNum">     734 </span>            :                     continue;
<span class="lineNum">     735 </span>            :                 case '-':
<span class="lineNum">     736 </span><span class="lineCov">       1733 :                     out.fill(' ');</span>
<span class="lineNum">     737 </span><span class="lineCov">       1733 :                     out.setf(std::ios::left, std::ios::adjustfield);</span>
<span class="lineNum">     738 </span><span class="lineCov">       1733 :                     continue;</span>
<span class="lineNum">     739 </span>            :                 case ' ':
<span class="lineNum">     740 </span>            :                     // overridden by show positive sign, '+' flag.
<span class="lineNum">     741 </span><span class="lineCov">       8622 :                     if (!(out.flags() &amp; std::ios::showpos))</span>
<span class="lineNum">     742 </span><span class="lineCov">       6212 :                         spacePadPositive = true;</span>
<span class="lineNum">     743 </span>            :                     continue;
<span class="lineNum">     744 </span>            :                 case '+':
<span class="lineNum">     745 </span><span class="lineCov">       3815 :                     out.setf(std::ios::showpos);</span>
<span class="lineNum">     746 </span><span class="lineCov">       3815 :                     spacePadPositive = false;</span>
<span class="lineNum">     747 </span>            :                     widthExtra = 1;
<span class="lineNum">     748 </span><span class="lineCov">       3815 :                     continue;</span>
<span class="lineNum">     749 </span>            :                 default:
<span class="lineNum">     750 </span>            :                     break;
<span class="lineNum">     751 </span>            :             }
<span class="lineNum">     752 </span>            :             break;
<span class="lineNum">     753 </span>            :         }
<span class="lineNum">     754 </span>            :         // Parse width
<span class="lineNum">     755 </span><span class="lineCov">    5863438 :         int width = 0;</span>
<span class="lineNum">     756 </span><span class="lineCov">    5863438 :         widthSet = parseWidthOrPrecision(width, c, positionalMode,</span>
<span class="lineNum">     757 </span>            :                                          args, argIndex, numArgs);
<span class="lineNum">     758 </span><span class="lineCov">    5863438 :         if (widthSet) {</span>
<span class="lineNum">     759 </span><span class="lineCov">       1477 :             if (width &lt; 0) {</span>
<span class="lineNum">     760 </span>            :                 // negative widths correspond to '-' flag set
<span class="lineNum">     761 </span><span class="lineCov">         39 :                 out.fill(' ');</span>
<span class="lineNum">     762 </span><span class="lineCov">         39 :                 out.setf(std::ios::left, std::ios::adjustfield);</span>
<span class="lineNum">     763 </span><span class="lineCov">         39 :                 width = -width;</span>
<span class="lineNum">     764 </span><span class="lineCov">         39 :             }</span>
<span class="lineNum">     765 </span><span class="lineCov">       1477 :             out.width(width);</span>
<span class="lineNum">     766 </span><span class="lineCov">       1477 :         }</span>
<span class="lineNum">     767 </span><span class="lineCov">    5862687 :     }</span>
<span class="lineNum">     768 </span>            :     // 3) Parse precision
<span class="lineNum">     769 </span><span class="lineCov">    7389915 :     if (*c == '.') {</span>
<span class="lineNum">     770 </span><span class="lineCov">      16719 :         ++c;</span>
<span class="lineNum">     771 </span><span class="lineCov">      16719 :         int precision = 0;</span>
<span class="lineNum">     772 </span><span class="lineCov">      16719 :         parseWidthOrPrecision(precision, c, positionalMode,</span>
<span class="lineNum">     773 </span>            :                               args, argIndex, numArgs);
<span class="lineNum">     774 </span>            :         // Presence of `.` indicates precision set, unless the inferred value
<span class="lineNum">     775 </span>            :         // was negative in which case the default is used.
<span class="lineNum">     776 </span><span class="lineCov">      16719 :         precisionSet = precision &gt;= 0;</span>
<span class="lineNum">     777 </span><span class="lineCov">      16719 :         if (precisionSet)</span>
<span class="lineNum">     778 </span><span class="lineCov">      16693 :             out.precision(precision);</span>
<span class="lineNum">     779 </span><span class="lineCov">      16694 :     }</span>
<span class="lineNum">     780 </span>            :     // 4) Ignore any C99 length modifier
<span class="lineNum">     781 </span><span class="lineCov">   14782821 :     while (*c == 'l' || *c == 'h' || *c == 'L' ||</span>
<span class="lineNum">     782 </span><span class="lineCov">    7391435 :            *c == 'j' || *c == 'z' || *c == 't') {</span>
<span class="lineNum">     783 </span><span class="lineCov">       3041 :         ++c;</span>
<span class="lineNum">     784 </span>            :     }
<span class="lineNum">     785 </span>            :     // 5) We're up to the conversion specifier character.
<span class="lineNum">     786 </span>            :     // Set stream flags based on conversion specifier (thanks to the
<span class="lineNum">     787 </span>            :     // boost::format class for forging the way here).
<span class="lineNum">     788 </span>            :     bool intConversion = false;
<span class="lineNum">     789 </span><span class="lineCov">    7389890 :     switch (*c) {</span>
<span class="lineNum">     790 </span>            :         case 'u': case 'd': case 'i':
<span class="lineNum">     791 </span><span class="lineCov">    4224674 :             out.setf(std::ios::dec, std::ios::basefield);</span>
<span class="lineNum">     792 </span>            :             intConversion = true;
<span class="lineNum">     793 </span><span class="lineCov">    4224674 :             break;</span>
<span class="lineNum">     794 </span>            :         case 'o':
<span class="lineNum">     795 </span><span class="lineCov">       2269 :             out.setf(std::ios::oct, std::ios::basefield);</span>
<span class="lineNum">     796 </span>            :             intConversion = true;
<span class="lineNum">     797 </span><span class="lineCov">       2269 :             break;</span>
<span class="lineNum">     798 </span>            :         case 'X':
<span class="lineNum">     799 </span><span class="lineCov">       2410 :             out.setf(std::ios::uppercase);</span>
<span class="lineNum">     800 </span>            :             // Falls through
<span class="lineNum">     801 </span>            :         case 'x': case 'p':
<span class="lineNum">     802 </span><span class="lineCov">    1187797 :             out.setf(std::ios::hex, std::ios::basefield);</span>
<span class="lineNum">     803 </span>            :             intConversion = true;
<span class="lineNum">     804 </span><span class="lineCov">    1187797 :             break;</span>
<span class="lineNum">     805 </span>            :         case 'E':
<span class="lineNum">     806 </span><span class="lineCov">        211 :             out.setf(std::ios::uppercase);</span>
<span class="lineNum">     807 </span>            :             // Falls through
<span class="lineNum">     808 </span>            :         case 'e':
<span class="lineNum">     809 </span><span class="lineCov">        604 :             out.setf(std::ios::scientific, std::ios::floatfield);</span>
<span class="lineNum">     810 </span><span class="lineCov">        604 :             out.setf(std::ios::dec, std::ios::basefield);</span>
<span class="lineNum">     811 </span><span class="lineCov">        604 :             break;</span>
<span class="lineNum">     812 </span>            :         case 'F':
<span class="lineNum">     813 </span><span class="lineCov">        617 :             out.setf(std::ios::uppercase);</span>
<span class="lineNum">     814 </span>            :             // Falls through
<span class="lineNum">     815 </span>            :         case 'f':
<span class="lineNum">     816 </span><span class="lineCov">       1682 :             out.setf(std::ios::fixed, std::ios::floatfield);</span>
<span class="lineNum">     817 </span><span class="lineCov">       1682 :             break;</span>
<span class="lineNum">     818 </span>            :         case 'A':
<span class="lineNum">     819 </span><span class="lineCov">        225 :             out.setf(std::ios::uppercase);</span>
<span class="lineNum">     820 </span>            :             // Falls through
<span class="lineNum">     821 </span>            :         case 'a':
<span class="lineNum">     822 </span>            : #           ifdef _MSC_VER
<span class="lineNum">     823 </span>            :             // Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html
<span class="lineNum">     824 </span>            :             // by always setting maximum precision on MSVC to avoid precision
<span class="lineNum">     825 </span>            :             // loss for doubles.
<span class="lineNum">     826 </span>            :             out.precision(13);
<span class="lineNum">     827 </span>            : #           endif
<span class="lineNum">     828 </span><span class="lineCov">        478 :             out.setf(std::ios::fixed | std::ios::scientific, std::ios::floatfield);</span>
<span class="lineNum">     829 </span><span class="lineCov">        478 :             break;</span>
<span class="lineNum">     830 </span>            :         case 'G':
<span class="lineNum">     831 </span><span class="lineCov">        757 :             out.setf(std::ios::uppercase);</span>
<span class="lineNum">     832 </span>            :             // Falls through
<span class="lineNum">     833 </span>            :         case 'g':
<span class="lineNum">     834 </span><span class="lineCov">       1136 :             out.setf(std::ios::dec, std::ios::basefield);</span>
<span class="lineNum">     835 </span>            :             // As in boost::format, let stream decide float format.
<span class="lineNum">     836 </span><span class="lineCov">       1136 :             out.flags(out.flags() &amp; ~std::ios::floatfield);</span>
<span class="lineNum">     837 </span><span class="lineCov">       1136 :             break;</span>
<span class="lineNum">     838 </span>            :         case 'c':
<span class="lineNum">     839 </span>            :             // Handled as special case inside formatValue()
<span class="lineNum">     840 </span>            :             break;
<span class="lineNum">     841 </span>            :         case 's':
<span class="lineNum">     842 </span><span class="lineCov">    1959055 :             if (precisionSet)</span>
<span class="lineNum">     843 </span><span class="lineCov">      14655 :                 ntrunc = static_cast&lt;int&gt;(out.precision());</span>
<span class="lineNum">     844 </span>            :             // Make %s print Booleans as &quot;true&quot; and &quot;false&quot;
<span class="lineNum">     845 </span><span class="lineCov">    1959055 :             out.setf(std::ios::boolalpha);</span>
<span class="lineNum">     846 </span><span class="lineCov">    1959055 :             break;</span>
<span class="lineNum">     847 </span>            :         case 'n':
<span class="lineNum">     848 </span>            :             // Not supported - will cause problems!
<span class="lineNum">     849 </span><span class="lineCov">         15 :             TINYFORMAT_ERROR(&quot;tinyformat: %n conversion spec not supported&quot;);</span>
<span class="lineNum">     850 </span>            :             break;
<span class="lineNum">     851 </span>            :         case '\0':
<span class="lineNum">     852 </span><span class="lineCov">       2184 :             TINYFORMAT_ERROR(&quot;tinyformat: Conversion spec incorrectly &quot;</span>
<span class="lineNum">     853 </span>            :                              &quot;terminated by end of string&quot;);
<span class="lineNum">     854 </span>            :             return c;
<span class="lineNum">     855 </span>            :         default:
<span class="lineNum">     856 </span>            :             break;
<span class="lineNum">     857 </span>            :     }
<span class="lineNum">     858 </span><span class="lineCov">    7387690 :     if (intConversion &amp;&amp; precisionSet &amp;&amp; !widthSet) {</span>
<span class="lineNum">     859 </span>            :         // &quot;precision&quot; for integers gives the minimum number of digits (to be
<span class="lineNum">     860 </span>            :         // padded with zeros on the left).  This isn't really supported by the
<span class="lineNum">     861 </span>            :         // iostreams, but we can approximately simulate it with the width if
<span class="lineNum">     862 </span>            :         // the width isn't otherwise used.
<span class="lineNum">     863 </span><span class="lineCov">        715 :         out.width(out.precision() + widthExtra);</span>
<span class="lineNum">     864 </span><span class="lineCov">        715 :         out.setf(std::ios::internal, std::ios::adjustfield);</span>
<span class="lineNum">     865 </span><span class="lineCov">        715 :         out.fill('0');</span>
<span class="lineNum">     866 </span><span class="lineCov">        715 :     }</span>
<span class="lineNum">     867 </span><span class="lineCov">   14775380 :     return c+1;</span>
<span class="lineNum">     868 </span><span class="lineCov">    7390684 : }</span>
<span class="lineNum">     869 </span>            : 
<a name="870"><span class="lineNum">     870 </span>            : </a>
<span class="lineNum">     871 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">     872 </span><span class="lineCov">    4418828 : inline void formatImpl(std::ostream&amp; out, const char* fmt,</span>
<span class="lineNum">     873 </span>            :                        const detail::FormatArg* args,
<span class="lineNum">     874 </span>            :                        int numArgs)
<span class="lineNum">     875 </span>            : {
<span class="lineNum">     876 </span>            :     // Saved stream state
<span class="lineNum">     877 </span><span class="lineCov">    4418828 :     std::streamsize origWidth = out.width();</span>
<span class="lineNum">     878 </span><span class="lineCov">    4418828 :     std::streamsize origPrecision = out.precision();</span>
<span class="lineNum">     879 </span><span class="lineCov">    4418828 :     std::ios::fmtflags origFlags = out.flags();</span>
<span class="lineNum">     880 </span><span class="lineCov">    4418828 :     char origFill = out.fill();</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            :     // &quot;Positional mode&quot; means all format specs should be of the form &quot;%n$...&quot;
<span class="lineNum">     883 </span>            :     // with `n` an integer. We detect this in `streamStateFromFormat`.
<span class="lineNum">     884 </span><span class="lineCov">    4418828 :     bool positionalMode = false;</span>
<span class="lineNum">     885 </span><span class="lineCov">    4418828 :     int argIndex = 0;</span>
<span class="lineNum">     886 </span><span class="lineCov">   11806135 :     while (true) {</span>
<span class="lineNum">     887 </span><span class="lineCov">   11806135 :         fmt = printFormatStringLiteral(out, fmt);</span>
<span class="lineNum">     888 </span><span class="lineCov">   11806135 :         if (*fmt == '\0') {</span>
<span class="lineNum">     889 </span><span class="lineCov">    4414772 :             if (!positionalMode &amp;&amp; argIndex &lt; numArgs) {</span>
<span class="lineNum">     890 </span><span class="lineCov">       1104 :                 TINYFORMAT_ERROR(&quot;tinyformat: Not enough conversion specifiers in format string&quot;);</span>
<span class="lineNum">     891 </span>            :             }
<span class="lineNum">     892 </span>            :             break;
<span class="lineNum">     893 </span>            :         }
<span class="lineNum">     894 </span><span class="lineCov">    7391365 :         bool spacePadPositive = false;</span>
<span class="lineNum">     895 </span><span class="lineCov">    7391365 :         int ntrunc = -1;</span>
<span class="lineNum">     896 </span><span class="lineCov">    7391365 :         const char* fmtEnd = streamStateFromFormat(out, positionalMode, spacePadPositive, ntrunc, fmt,</span>
<span class="lineNum">     897 </span>            :                                                    args, argIndex, numArgs);
<span class="lineNum">     898 </span>            :         // NB: argIndex may be incremented by reading variable width/precision
<span class="lineNum">     899 </span>            :         // in `streamStateFromFormat`, so do the bounds check here.
<span class="lineNum">     900 </span><span class="lineCov">    7391365 :         if (argIndex &gt;= numArgs) {</span>
<span class="lineNum">     901 </span><span class="lineCov">        385 :             TINYFORMAT_ERROR(&quot;tinyformat: Too many conversion specifiers in format string&quot;);</span>
<span class="lineNum">     902 </span>            :             return;
<span class="lineNum">     903 </span>            :         }
<span class="lineNum">     904 </span><span class="lineCov">    7387305 :         const FormatArg&amp; arg = args[argIndex];</span>
<span class="lineNum">     905 </span>            :         // Format the arg into the stream.
<span class="lineNum">     906 </span><span class="lineCov">    7387305 :         if (!spacePadPositive) {</span>
<span class="lineNum">     907 </span><span class="lineCov">    7383677 :             arg.format(out, fmt, fmtEnd, ntrunc);</span>
<span class="lineNum">     908 </span><span class="lineCov">    7383677 :         }</span>
<span class="lineNum">     909 </span>            :         else {
<span class="lineNum">     910 </span>            :             // The following is a special case with no direct correspondence
<span class="lineNum">     911 </span>            :             // between stream formatting and the printf() behaviour.  Simulate
<span class="lineNum">     912 </span>            :             // it crudely by formatting into a temporary string stream and
<span class="lineNum">     913 </span>            :             // munging the resulting string.
<span class="lineNum">     914 </span><span class="lineCov">       3628 :             std::ostringstream tmpStream;</span>
<span class="lineNum">     915 </span><span class="lineCov">       3628 :             tmpStream.copyfmt(out);</span>
<span class="lineNum">     916 </span><span class="lineCov">       3628 :             tmpStream.setf(std::ios::showpos);</span>
<span class="lineNum">     917 </span><span class="lineCov">       3628 :             arg.format(tmpStream, fmt, fmtEnd, ntrunc);</span>
<span class="lineNum">     918 </span><span class="lineCov">       3628 :             std::string result = tmpStream.str(); // allocates... yuck.</span>
<span class="lineNum">     919 </span><span class="lineCov">  100181954 :             for (size_t i = 0, iend = result.size(); i &lt; iend; ++i) {</span>
<span class="lineNum">     920 </span><span class="lineCov">  100178326 :                 if (result[i] == '+')</span>
<span class="lineNum">     921 </span><span class="lineCov">        330 :                     result[i] = ' ';</span>
<span class="lineNum">     922 </span>            :             }
<span class="lineNum">     923 </span><span class="lineCov">       3628 :             out &lt;&lt; result;</span>
<span class="lineNum">     924 </span><span class="lineCov">       3628 :         }</span>
<span class="lineNum">     925 </span><span class="lineCov">    7387307 :         if (!positionalMode)</span>
<span class="lineNum">     926 </span><span class="lineCov">    7361526 :             ++argIndex;</span>
<span class="lineNum">     927 </span>            :         fmt = fmtEnd;
<span class="lineNum">     928 </span><span class="lineCov">    7387692 :     }</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     // Restore stream state
<span class="lineNum">     931 </span><span class="lineCov">    4413668 :     out.width(origWidth);</span>
<span class="lineNum">     932 </span><span class="lineCov">    4413668 :     out.precision(origPrecision);</span>
<span class="lineNum">     933 </span><span class="lineCov">    4413668 :     out.flags(origFlags);</span>
<span class="lineNum">     934 </span><span class="lineCov">    4413668 :     out.fill(origFill);</span>
<span class="lineNum">     935 </span><span class="lineCov">    4415542 : }</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            : } // namespace detail
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            : /// List of template arguments format(), held in a type-opaque way.
<span class="lineNum">     941 </span>            : ///
<span class="lineNum">     942 </span>            : /// A const reference to FormatList (typedef'd as FormatListRef) may be
<span class="lineNum">     943 </span>            : /// conveniently used to pass arguments to non-template functions: All type
<span class="lineNum">     944 </span>            : /// information has been stripped from the arguments, leaving just enough of a
<span class="lineNum">     945 </span>            : /// common interface to perform formatting as required.
<span class="lineNum">     946 </span>            : class FormatList
<a name="947"><span class="lineNum">     947 </span>            : {</a>
<span class="lineNum">     948 </span>            :     public:
<span class="lineNum">     949 </span><span class="lineCov">    4418829 :         FormatList(detail::FormatArg* args, int N)</span>
<span class="lineNum">     950 </span><span class="lineCov">    4418829 :             : m_args(args), m_N(N) { }</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :         friend void vformat(std::ostream&amp; out, const char* fmt,
<span class="lineNum">     953 </span>            :                             const FormatList&amp; list);
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :     private:
<span class="lineNum">     956 </span>            :         const detail::FormatArg* m_args;
<span class="lineNum">     957 </span>            :         int m_N;
<span class="lineNum">     958 </span>            : };
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            : /// Reference to type-opaque format list for passing to vformat()
<span class="lineNum">     961 </span>            : typedef const FormatList&amp; FormatListRef;
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            : namespace detail {
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            : // Format list subclass with fixed storage to avoid dynamic allocation
<span class="lineNum">     967 </span>            : template&lt;int N&gt;
<span class="lineNum">     968 </span>            : class FormatListN : public FormatList
<span class="lineNum">     969 </span>            : {
<span class="lineNum">     970 </span>            :     public:
<a name="971"><span class="lineNum">     971 </span>            : #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES</a>
<span class="lineNum">     972 </span>            :         template&lt;typename... Args&gt;
<span class="lineNum">     973 </span><span class="lineCov">    4418679 :         FormatListN(const Args&amp;... args)</span>
<span class="lineNum">     974 </span><span class="lineCov">    4418679 :             : FormatList(&amp;m_formatterStore[0], N),</span>
<span class="lineNum">     975 </span><span class="lineCov">    4418679 :             m_formatterStore { FormatArg(args)... }</span>
<span class="lineNum">     976 </span><span class="lineCov">    4418679 :         { static_assert(sizeof...(args) == N, &quot;Number of args must be N&quot;); }</span>
<span class="lineNum">     977 </span>            : #else // C++98 version
<span class="lineNum">     978 </span>            :         void init(int) {}
<span class="lineNum">     979 </span>            : #       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)                \
<span class="lineNum">     980 </span>            :                                                                         \
<span class="lineNum">     981 </span>            :         template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                \
<span class="lineNum">     982 </span>            :         FormatListN(TINYFORMAT_VARARGS(n))                              \
<span class="lineNum">     983 </span>            :             : FormatList(&amp;m_formatterStore[0], n)                       \
<span class="lineNum">     984 </span>            :         { TINYFORMAT_ASSERT(n == N); init(0, TINYFORMAT_PASSARGS(n)); } \
<span class="lineNum">     985 </span>            :                                                                         \
<span class="lineNum">     986 </span>            :         template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                \
<span class="lineNum">     987 </span>            :         void init(int i, TINYFORMAT_VARARGS(n))                         \
<span class="lineNum">     988 </span>            :         {                                                               \
<span class="lineNum">     989 </span>            :             m_formatterStore[i] = FormatArg(v1);                        \
<span class="lineNum">     990 </span>            :             init(i+1 TINYFORMAT_PASSARGS_TAIL(n));                      \
<span class="lineNum">     991 </span>            :         }
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :         TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)
<span class="lineNum">     994 </span>            : #       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR
<span class="lineNum">     995 </span>            : #endif
<span class="lineNum">     996 </span>            :         FormatListN(const FormatListN&amp; other)
<span class="lineNum">     997 </span>            :             : FormatList(&amp;m_formatterStore[0], N)
<span class="lineNum">     998 </span>            :         { std::copy(&amp;other.m_formatterStore[0], &amp;other.m_formatterStore[N],
<span class="lineNum">     999 </span>            :                     &amp;m_formatterStore[0]); }
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :     private:
<span class="lineNum">    1002 </span>            :         FormatArg m_formatterStore[N];
<span class="lineNum">    1003 </span>            : };
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : // Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard
<a name="1006"><span class="lineNum">    1006 </span>            : template&lt;&gt; class FormatListN&lt;0&gt; : public FormatList</a>
<span class="lineNum">    1007 </span>            : {
<span class="lineNum">    1008 </span><span class="lineCov">        149 :     public: FormatListN() : FormatList(0, 0) {}</span>
<span class="lineNum">    1009 </span>            : };
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : } // namespace detail
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            : //------------------------------------------------------------------------------
<span class="lineNum">    1015 </span>            : // Primary API functions
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : /// Make type-agnostic format list from list of template arguments.
<span class="lineNum">    1020 </span>            : ///
<span class="lineNum">    1021 </span>            : /// The exact return type of this function is an implementation detail and
<span class="lineNum">    1022 </span>            : /// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:
<span class="lineNum">    1023 </span>            : ///
<a name="1024"><span class="lineNum">    1024 </span>            : ///   FormatListRef formatList = makeFormatList( /*...*/ );</a>
<span class="lineNum">    1025 </span>            : template&lt;typename... Args&gt;
<span class="lineNum">    1026 </span><span class="lineCov">    4418828 : detail::FormatListN&lt;sizeof...(Args)&gt; makeFormatList(const Args&amp;... args)</span>
<span class="lineNum">    1027 </span>            : {
<span class="lineNum">    1028 </span><span class="lineCov">    4418828 :     return detail::FormatListN&lt;sizeof...(args)&gt;(args...);</span>
<span class="lineNum">    1029 </span>            : }
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            : #else // C++98 version
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            : inline detail::FormatListN&lt;0&gt; makeFormatList()
<span class="lineNum">    1034 </span>            : {
<span class="lineNum">    1035 </span>            :     return detail::FormatListN&lt;0&gt;();
<span class="lineNum">    1036 </span>            : }
<span class="lineNum">    1037 </span>            : #define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \
<span class="lineNum">    1038 </span>            : template&lt;TINYFORMAT_ARGTYPES(n)&gt;                              \
<span class="lineNum">    1039 </span>            : detail::FormatListN&lt;n&gt; makeFormatList(TINYFORMAT_VARARGS(n))  \
<span class="lineNum">    1040 </span>            : {                                                             \
<span class="lineNum">    1041 </span>            :     return detail::FormatListN&lt;n&gt;(TINYFORMAT_PASSARGS(n));    \
<span class="lineNum">    1042 </span>            : }
<span class="lineNum">    1043 </span>            : TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)
<span class="lineNum">    1044 </span>            : #undef TINYFORMAT_MAKE_MAKEFORMATLIST
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            : #endif
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /// Format list of arguments to the stream according to the given format string.
<span class="lineNum">    1049 </span>            : ///
<a name="1050"><span class="lineNum">    1050 </span>            : /// The name vformat() is chosen for the semantic similarity to vprintf(): the</a>
<span class="lineNum">    1051 </span>            : /// list of format arguments is held in a single function argument.
<span class="lineNum">    1052 </span><span class="lineCov">    4418829 : inline void vformat(std::ostream&amp; out, const char* fmt, FormatListRef list)</span>
<span class="lineNum">    1053 </span>            : {
<span class="lineNum">    1054 </span><span class="lineCov">    4418829 :     detail::formatImpl(out, fmt, list.m_args, list.m_N);</span>
<span class="lineNum">    1055 </span><span class="lineCov">    4418829 : }</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            : #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
<span class="lineNum">    1059 </span>            : 
<a name="1060"><span class="lineNum">    1060 </span>            : /// Format list of arguments to the stream according to given format string.</a>
<span class="lineNum">    1061 </span>            : template&lt;typename... Args&gt;
<span class="lineNum">    1062 </span><span class="lineCov">    4418829 : void format(std::ostream&amp; out, const char* fmt, const Args&amp;... args)</span>
<span class="lineNum">    1063 </span>            : {
<span class="lineNum">    1064 </span><span class="lineCov">    4418829 :     vformat(out, fmt, makeFormatList(args...));</span>
<span class="lineNum">    1065 </span><span class="lineCov">    4418829 : }</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            : /// Format list of arguments according to the given format string and return
<a name="1068"><span class="lineNum">    1068 </span>            : /// the result as a string.</a>
<span class="lineNum">    1069 </span>            : template&lt;typename... Args&gt;
<span class="lineNum">    1070 </span><span class="lineCov">    4388165 : std::string format(const char* fmt, const Args&amp;... args)</span>
<span class="lineNum">    1071 </span>            : {
<span class="lineNum">    1072 </span><span class="lineCov">    4388165 :     std::ostringstream oss;</span>
<span class="lineNum">    1073 </span><span class="lineCov">    4388165 :     format(oss, fmt, args...);</span>
<span class="lineNum">    1074 </span><span class="lineCov">    4388165 :     return oss.str();</span>
<span class="lineNum">    1075 </span><span class="lineCov">    4388164 : }</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            : /// Format list of arguments to std::cout, according to the given format string
<span class="lineNum">    1078 </span>            : template&lt;typename... Args&gt;
<span class="lineNum">    1079 </span>            : void printf(const char* fmt, const Args&amp;... args)
<span class="lineNum">    1080 </span>            : {
<span class="lineNum">    1081 </span>            :     format(std::cout, fmt, args...);
<span class="lineNum">    1082 </span>            : }
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : template&lt;typename... Args&gt;
<span class="lineNum">    1085 </span>            : void printfln(const char* fmt, const Args&amp;... args)
<span class="lineNum">    1086 </span>            : {
<span class="lineNum">    1087 </span>            :     format(std::cout, fmt, args...);
<span class="lineNum">    1088 </span>            :     std::cout &lt;&lt; '\n';
<span class="lineNum">    1089 </span>            : }
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            : #else // C++98 version
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : inline void format(std::ostream&amp; out, const char* fmt)
<span class="lineNum">    1095 </span>            : {
<span class="lineNum">    1096 </span>            :     vformat(out, fmt, makeFormatList());
<span class="lineNum">    1097 </span>            : }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            : inline std::string format(const char* fmt)
<span class="lineNum">    1100 </span>            : {
<span class="lineNum">    1101 </span>            :     std::ostringstream oss;
<span class="lineNum">    1102 </span>            :     format(oss, fmt);
<span class="lineNum">    1103 </span>            :     return oss.str();
<span class="lineNum">    1104 </span>            : }
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            : inline void printf(const char* fmt)
<span class="lineNum">    1107 </span>            : {
<span class="lineNum">    1108 </span>            :     format(std::cout, fmt);
<span class="lineNum">    1109 </span>            : }
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : inline void printfln(const char* fmt)
<span class="lineNum">    1112 </span>            : {
<span class="lineNum">    1113 </span>            :     format(std::cout, fmt);
<span class="lineNum">    1114 </span>            :     std::cout &lt;&lt; '\n';
<span class="lineNum">    1115 </span>            : }
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            : #define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \
<span class="lineNum">    1118 </span>            :                                                                           \
<span class="lineNum">    1119 </span>            : template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
<span class="lineNum">    1120 </span>            : void format(std::ostream&amp; out, const char* fmt, TINYFORMAT_VARARGS(n))    \
<span class="lineNum">    1121 </span>            : {                                                                         \
<span class="lineNum">    1122 </span>            :     vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \
<span class="lineNum">    1123 </span>            : }                                                                         \
<span class="lineNum">    1124 </span>            :                                                                           \
<span class="lineNum">    1125 </span>            : template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
<span class="lineNum">    1126 </span>            : std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \
<span class="lineNum">    1127 </span>            : {                                                                         \
<span class="lineNum">    1128 </span>            :     std::ostringstream oss;                                               \
<span class="lineNum">    1129 </span>            :     format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \
<span class="lineNum">    1130 </span>            :     return oss.str();                                                     \
<span class="lineNum">    1131 </span>            : }                                                                         \
<span class="lineNum">    1132 </span>            :                                                                           \
<span class="lineNum">    1133 </span>            : template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
<span class="lineNum">    1134 </span>            : void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \
<span class="lineNum">    1135 </span>            : {                                                                         \
<span class="lineNum">    1136 </span>            :     format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
<span class="lineNum">    1137 </span>            : }                                                                         \
<span class="lineNum">    1138 </span>            :                                                                           \
<span class="lineNum">    1139 </span>            : template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
<span class="lineNum">    1140 </span>            : void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \
<span class="lineNum">    1141 </span>            : {                                                                         \
<span class="lineNum">    1142 </span>            :     format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
<span class="lineNum">    1143 </span>            :     std::cout &lt;&lt; '\n';                                                    \
<span class="lineNum">    1144 </span>            : }
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            : TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)
<span class="lineNum">    1147 </span>            : #undef TINYFORMAT_MAKE_FORMAT_FUNCS
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span>            : #endif
<span class="lineNum">    1150 </span>            : 
<a name="1151"><span class="lineNum">    1151 </span>            : // Added for Bitcoin Core</a>
<span class="lineNum">    1152 </span>            : template&lt;typename... Args&gt;
<span class="lineNum">    1153 </span><span class="lineCov">      30665 : std::string format(const std::string &amp;fmt, const Args&amp;... args)</span>
<span class="lineNum">    1154 </span>            : {
<span class="lineNum">    1155 </span><span class="lineCov">      30665 :     std::ostringstream oss;</span>
<span class="lineNum">    1156 </span><span class="lineCov">      30665 :     format(oss, fmt.c_str(), args...);</span>
<span class="lineNum">    1157 </span><span class="lineCov">      25503 :     return oss.str();</span>
<span class="lineNum">    1158 </span><span class="lineCov">      30665 : }</span>
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            : } // namespace tinyformat
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            : // Added for Bitcoin Core:
<span class="lineNum">    1163 </span>            : /** Format arguments and return the string or write to given std::ostream (see tinyformat::format doc for details) */
<span class="lineNum">    1164 </span>            : #define strprintf tfm::format
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : #endif // TINYFORMAT_H_INCLUDED
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
