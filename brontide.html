<!DOCTYPE html>
<html><head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lightningnetwork/lnd/brontide/conn.go (0.0%)</option>
				
				<option value="file1">github.com/lightningnetwork/lnd/brontide/listener.go (0.0%)</option>
				
				<option value="file2" selected="selected">github.com/lightningnetwork/lnd/brontide/noise.go (87.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none;">package brontide

import (
        "bytes"
        "io"
        "math"
        "net"
        "time"

        "github.com/btcsuite/btcd/btcec"
        "github.com/lightningnetwork/lnd/lnwire"
)

// Conn is an implementation of net.Conn which enforces an authenticated key
// exchange and message encryption protocol dubbed "Brontide" after initial TCP
// connection establishment. In the case of a successful handshake, all
// messages sent via the .Write() method are encrypted with an AEAD cipher
// along with an encrypted length-prefix. See the Machine struct for
// additional details w.r.t to the handshake and encryption scheme.
type Conn struct {
        conn net.Conn

        noise *Machine

        readBuf bytes.Buffer
}

// A compile-time assertion to ensure that Conn meets the net.Conn interface.
var _ net.Conn = (*Conn)(nil)

// Dial attempts to establish an encrypted+authenticated connection with the
// remote peer located at address which has remotePub as its long-term static
// public key. In the case of a handshake failure, the connection is closed and
// a non-nil error is returned.
func Dial(localPriv *btcec.PrivateKey, netAddr *lnwire.NetAddress,
        dialer func(string, string) (net.Conn, error)) (*Conn, error) <span class="cov0" title="0">{
        ipAddr := netAddr.Address.String()
        var conn net.Conn
        var err error
        conn, err = dialer("tcp", ipAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">b := &amp;Conn{
                conn:  conn,
                noise: NewBrontideMachine(true, localPriv, netAddr.IdentityKey),
        }

        // Initiate the handshake by sending the first act to the receiver.
        actOne, err := b.noise.GenActOne()
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(actOne[:]); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // We'll ensure that we get ActTwo from the remote peer in a timely
        // manner. If they don't respond within 1s, then we'll kill the
        // connection.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // If the first act was successful (we know that address is actually
        // remotePub), then read the second act after which we'll be able to
        // send our static public key to the remote peer with strong forward
        // secrecy.
        <span class="cov0" title="0">var actTwo [ActTwoSize]byte
        if _, err := io.ReadFull(conn, actTwo[:]); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := b.noise.RecvActTwo(actTwo); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // Finally, complete the handshake by sending over our encrypted static
        // key and execute the final ECDH operation.
        <span class="cov0" title="0">actThree, err := b.noise.GenActThree()
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(actThree[:]); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // We'll reset the deadline as it's no longer critical beyond the
        // initial handshake.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Time{})
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return b, nil</span>
}

// ReadNextMessage uses the connection in a message-oriented manner, instructing
// it to read the next _full_ message with the brontide stream. This function
// will block until the read of the header and body succeeds.
//
// NOTE: This method SHOULD NOT be used in the case that the connection may be
// adversarial and induce long delays. If the caller needs to set read deadlines
// appropriately, it is preferred that they use the split ReadNextHeader and
// ReadNextBody methods so that the deadlines can be set appropriately on each.
func (c *Conn) ReadNextMessage() ([]byte, error) <span class="cov0" title="0">{
        return c.noise.ReadMessage(c.conn)
}</span>

// ReadNextHeader uses the connection to read the next header from the brontide
// stream. This function will block until the read of the header succeeds and
// return the packet length (including MAC overhead) that is expected from the
// subsequent call to ReadNextBody.
func (c *Conn) ReadNextHeader() (uint32, error) <span class="cov0" title="0">{
        return c.noise.ReadHeader(c.conn)
}</span>

// ReadNextBody uses the connection to read the next message body from the
// brontide stream. This function will block until the read of the body succeeds
// and return the decrypted payload. The provided buffer MUST be the packet
// length returned by the preceding call to ReadNextHeader.
func (c *Conn) ReadNextBody(buf []byte) ([]byte, error) <span class="cov0" title="0">{
        return c.noise.ReadBody(c.conn, buf)
}</span>

// Read reads data from the connection.  Read can be made to time out and
// return an Error with Timeout() == true after a fixed time limit; see
// SetDeadline and SetReadDeadline.
//
// Part of the net.Conn interface.
func (c *Conn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        // In order to reconcile the differences between the record abstraction
        // of our AEAD connection, and the stream abstraction of TCP, we
        // maintain an intermediate read buffer. If this buffer becomes
        // depleted, then we read the next record, and feed it into the
        // buffer. Otherwise, we read directly from the buffer.
        if c.readBuf.Len() == 0 </span><span class="cov0" title="0">{
                plaintext, err := c.noise.ReadMessage(c.conn)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">if _, err := c.readBuf.Write(plaintext); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">return c.readBuf.Read(b)</span>
}

// Write writes data to the connection.  Write can be made to time out and
// return an Error with Timeout() == true after a fixed time limit; see
// SetDeadline and SetWriteDeadline.
//
// Part of the net.Conn interface.
func (c *Conn) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        // If the message doesn't require any chunking, then we can go ahead
        // with a single write.
        if len(b) &lt;= math.MaxUint16 </span><span class="cov0" title="0">{
                err = c.noise.WriteMessage(b)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return c.noise.Flush(c.conn)</span>
        }

        // If we need to split the message into fragments, then we'll write
        // chunks which maximize usage of the available payload.
        <span class="cov0" title="0">chunkSize := math.MaxUint16

        bytesToWrite := len(b)
        bytesWritten := 0
        for bytesWritten &lt; bytesToWrite </span><span class="cov0" title="0">{
                // If we're on the last chunk, then truncate the chunk size as
                // necessary to avoid an out-of-bounds array memory access.
                if bytesWritten+chunkSize &gt; len(b) </span><span class="cov0" title="0">{
                        chunkSize = len(b) - bytesWritten
                }</span>

                // Slice off the next chunk to be written based on our running
                // counter and next chunk size.
                <span class="cov0" title="0">chunk := b[bytesWritten : bytesWritten+chunkSize]
                if err := c.noise.WriteMessage(chunk); err != nil </span><span class="cov0" title="0">{
                        return bytesWritten, err
                }</span>

                <span class="cov0" title="0">n, err := c.noise.Flush(c.conn)
                bytesWritten += n
                if err != nil </span><span class="cov0" title="0">{
                        return bytesWritten, err
                }</span>
        }

        <span class="cov0" title="0">return bytesWritten, nil</span>
}

// WriteMessage encrypts and buffers the next message p for the connection. The
// ciphertext of the message is prepended with an encrypt+auth'd length which
// must be used as the AD to the AEAD construction when being decrypted by the
// other side.
//
// NOTE: This DOES NOT write the message to the wire, it should be followed by a
// call to Flush to ensure the message is written.
func (c *Conn) WriteMessage(b []byte) error <span class="cov0" title="0">{
        return c.noise.WriteMessage(b)
}</span>

// Flush attempts to write a message buffered using WriteMessage to the
// underlying connection. If no buffered message exists, this will result in a
// NOP. Otherwise, it will continue to write the remaining bytes, picking up
// where the byte stream left off in the event of a partial write. The number of
// bytes returned reflects the number of plaintext bytes in the payload, and
// does not account for the overhead of the header or MACs.
//
// NOTE: It is safe to call this method again iff a timeout error is returned.
func (c *Conn) Flush() (int, error) <span class="cov0" title="0">{
        return c.noise.Flush(c.conn)
}</span>

// Close closes the connection.  Any blocked Read or Write operations will be
// unblocked and return errors.
//
// Part of the net.Conn interface.
func (c *Conn) Close() error <span class="cov0" title="0">{
        // TODO(roasbeef): reset brontide state?
        return c.conn.Close()
}</span>

// LocalAddr returns the local network address.
//
// Part of the net.Conn interface.
func (c *Conn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.LocalAddr()
}</span>

// RemoteAddr returns the remote network address.
//
// Part of the net.Conn interface.
func (c *Conn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.RemoteAddr()
}</span>

// SetDeadline sets the read and write deadlines associated with the
// connection. It is equivalent to calling both SetReadDeadline and
// SetWriteDeadline.
//
// Part of the net.Conn interface.
func (c *Conn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetDeadline(t)
}</span>

// SetReadDeadline sets the deadline for future Read calls.  A zero value for t
// means Read will not time out.
//
// Part of the net.Conn interface.
func (c *Conn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetReadDeadline(t)
}</span>

// SetWriteDeadline sets the deadline for future Write calls.  Even if write
// times out, it may return n &gt; 0, indicating that some of the data was
// successfully written.  A zero value for t means Write will not time out.
//
// Part of the net.Conn interface.
func (c *Conn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetWriteDeadline(t)
}</span>

// RemotePub returns the remote peer's static public key.
func (c *Conn) RemotePub() *btcec.PublicKey <span class="cov0" title="0">{
        return c.noise.remoteStatic
}</span>

// LocalPub returns the local peer's static public key.
func (c *Conn) LocalPub() *btcec.PublicKey <span class="cov0" title="0">{
        return c.noise.localStatic.PubKey()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package brontide

import (
        "errors"
        "fmt"
        "io"
        "net"
        "time"

        "github.com/btcsuite/btcd/btcec"
)

// defaultHandshakes is the maximum number of handshakes that can be done in
// parallel.
const defaultHandshakes = 1000

// Listener is an implementation of a net.Conn which executes an authenticated
// key exchange and message encryption protocol dubbed "Machine" after
// initial connection acceptance. See the Machine struct for additional
// details w.r.t the handshake and encryption scheme used within the
// connection.
type Listener struct {
        localStatic *btcec.PrivateKey

        tcp *net.TCPListener

        handshakeSema chan struct{}
        conns         chan maybeConn
        quit          chan struct{}
}

// A compile-time assertion to ensure that Conn meets the net.Listener interface.
var _ net.Listener = (*Listener)(nil)

// NewListener returns a new net.Listener which enforces the Brontide scheme
// during both initial connection establishment and data transfer.
func NewListener(localStatic *btcec.PrivateKey, listenAddr string) (*Listener,
        error) <span class="cov0" title="0">{
        addr, err := net.ResolveTCPAddr("tcp", listenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">l, err := net.ListenTCP("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">brontideListener := &amp;Listener{
                localStatic:   localStatic,
                tcp:           l,
                handshakeSema: make(chan struct{}, defaultHandshakes),
                conns:         make(chan maybeConn),
                quit:          make(chan struct{}),
        }

        for i := 0; i &lt; defaultHandshakes; i++ </span><span class="cov0" title="0">{
                brontideListener.handshakeSema &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">go brontideListener.listen()

        return brontideListener, nil</span>
}

// listen accepts connection from the underlying tcp conn, then performs
// the brontinde handshake procedure asynchronously. A maximum of
// defaultHandshakes will be active at any given time.
//
// NOTE: This method must be run as a goroutine.
func (l *Listener) listen() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.handshakeSema:<span class="cov0" title="0"></span>
                case &lt;-l.quit:<span class="cov0" title="0">
                        return</span>
                }

                <span class="cov0" title="0">conn, err := l.tcp.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        l.rejectConn(err)
                        l.handshakeSema &lt;- struct{}{}
                        continue</span>
                }

                <span class="cov0" title="0">go l.doHandshake(conn)</span>
        }
}

// rejectedConnErr is a helper function that prepends the remote address of the
// failed connection attempt to the original error message.
func rejectedConnErr(err error, remoteAddr string) error <span class="cov0" title="0">{
        return fmt.Errorf("unable to accept connection from %v: %v", remoteAddr,
                err)
}</span>

// doHandshake asynchronously performs the brontide handshake, so that it does
// not block the main accept loop. This prevents peers that delay writing to the
// connection from block other connection attempts.
func (l *Listener) doHandshake(conn net.Conn) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{ l.handshakeSema &lt;- struct{}{} }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-l.quit:<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">remoteAddr := conn.RemoteAddr().String()

        brontideConn := &amp;Conn{
                conn:  conn,
                noise: NewBrontideMachine(false, l.localStatic, nil),
        }

        // We'll ensure that we get ActOne from the remote peer in a timely
        // manner. If they don't respond within 1s, then we'll kill the
        // connection.
        err := conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Attempt to carry out the first act of the handshake protocol. If the
        // connecting node doesn't know our long-term static public key, then
        // this portion will fail with a non-nil error.
        <span class="cov0" title="0">var actOne [ActOneSize]byte
        if _, err := io.ReadFull(conn, actOne[:]); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>
        <span class="cov0" title="0">if err := brontideConn.noise.RecvActOne(actOne); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Next, progress the handshake processes by sending over our ephemeral
        // key for the session along with an authenticating tag.
        <span class="cov0" title="0">actTwo, err := brontideConn.noise.GenActTwo()
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(actTwo[:]); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-l.quit:<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        // We'll ensure that we get ActTwo from the remote peer in a timely
        // manner. If they don't respond within 1 second, then we'll kill the
        // connection.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Finally, finish the handshake processes by reading and decrypting
        // the connection peer's static public key. If this succeeds then both
        // sides have mutually authenticated each other.
        <span class="cov0" title="0">var actThree [ActThreeSize]byte
        if _, err := io.ReadFull(conn, actThree[:]); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>
        <span class="cov0" title="0">if err := brontideConn.noise.RecvActThree(actThree); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // We'll reset the deadline as it's no longer critical beyond the
        // initial handshake.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Time{})
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        <span class="cov0" title="0">l.acceptConn(brontideConn)</span>
}

// maybeConn holds either a brontide connection or an error returned from the
// handshake.
type maybeConn struct {
        conn *Conn
        err  error
}

// acceptConn returns a connection that successfully performed a handshake.
func (l *Listener) acceptConn(conn *Conn) <span class="cov0" title="0">{
        select </span>{
        case l.conns &lt;- maybeConn{conn: conn}:<span class="cov0" title="0"></span>
        case &lt;-l.quit:<span class="cov0" title="0"></span>
        }
}

// rejectConn returns any errors encountered during connection or handshake.
func (l *Listener) rejectConn(err error) <span class="cov0" title="0">{
        select </span>{
        case l.conns &lt;- maybeConn{err: err}:<span class="cov0" title="0"></span>
        case &lt;-l.quit:<span class="cov0" title="0"></span>
        }
}

// Accept waits for and returns the next connection to the listener. All
// incoming connections are authenticated via the three act Brontide
// key-exchange scheme. This function will fail with a non-nil error in the
// case that either the handshake breaks down, or the remote peer doesn't know
// our static public key.
//
// Part of the net.Listener interface.
func (l *Listener) Accept() (net.Conn, error) <span class="cov0" title="0">{
        select </span>{
        case result := &lt;-l.conns:<span class="cov0" title="0">
                return result.conn, result.err</span>
        case &lt;-l.quit:<span class="cov0" title="0">
                return nil, errors.New("brontide connection closed")</span>
        }
}

// Close closes the listener.  Any blocked Accept operations will be unblocked
// and return errors.
//
// Part of the net.Listener interface.
func (l *Listener) Close() error <span class="cov0" title="0">{
        select </span>{
        case &lt;-l.quit:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(l.quit)</span>
        }

        <span class="cov0" title="0">return l.tcp.Close()</span>
}

// Addr returns the listener's network address.
//
// Part of the net.Listener interface.
func (l *Listener) Addr() net.Addr <span class="cov0" title="0">{
        return l.tcp.Addr()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: block;">package brontide

import (
        "crypto/cipher"
        "crypto/sha256"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "math"
        "time"

        "golang.org/x/crypto/chacha20poly1305"
        "golang.org/x/crypto/hkdf"

        "github.com/btcsuite/btcd/btcec"
)

const (
        // protocolName is the precise instantiation of the Noise protocol
        // handshake at the center of Brontide. This value will be used as part
        // of the prologue. If the initiator and responder aren't using the
        // exact same string for this value, along with prologue of the Bitcoin
        // network, then the initial handshake will fail.
        protocolName = "Noise_XK_secp256k1_ChaChaPoly_SHA256"

        // macSize is the length in bytes of the tags generated by poly1305.
        macSize = 16

        // lengthHeaderSize is the number of bytes used to prefix encode the
        // length of a message payload.
        lengthHeaderSize = 2

        // encHeaderSize is the number of bytes required to hold an encrypted
        // header and it's MAC.
        encHeaderSize = lengthHeaderSize + macSize

        // keyRotationInterval is the number of messages sent on a single
        // cipher stream before the keys are rotated forwards.
        keyRotationInterval = 1000

        // handshakeReadTimeout is a read timeout that will be enforced when
        // waiting for data payloads during the various acts of Brontide. If
        // the remote party fails to deliver the proper payload within this
        // time frame, then we'll fail the connection.
        handshakeReadTimeout = time.Second * 5
)

var (
        // ErrMaxMessageLengthExceeded is returned a message to be written to
        // the cipher session exceeds the maximum allowed message payload.
        ErrMaxMessageLengthExceeded = errors.New("the generated payload exceeds " +
                "the max allowed message length of (2^16)-1")

        // ErrMessageNotFlushed signals that the connection cannot accept a new
        // message because the prior message has not been fully flushed.
        ErrMessageNotFlushed = errors.New("prior message not flushed")

        // lightningPrologue is the noise prologue that is used to initialize
        // the brontide noise handshake.
        lightningPrologue = []byte("lightning")

        // ephemeralGen is the default ephemeral key generator, used to derive a
        // unique ephemeral key for each brontide handshake.
        ephemeralGen = func() (*btcec.PrivateKey, error) <span class="cov7" title="245">{
                return btcec.NewPrivateKey(btcec.S256())
        }</span>
)

// TODO(roasbeef): free buffer pool?

// ecdh performs an ECDH operation between pub and priv. The returned value is
// the sha256 of the compressed shared point.
func ecdh(pub *btcec.PublicKey, priv *btcec.PrivateKey) []byte <span class="cov8" title="870">{
        s := &amp;btcec.PublicKey{}
        x, y := btcec.S256().ScalarMult(pub.X, pub.Y, priv.D.Bytes())
        s.X = x
        s.Y = y

        h := sha256.Sum256(s.SerializeCompressed())
        return h[:]
}</span>

// cipherState encapsulates the state for the AEAD which will be used to
// encrypt+authenticate any payloads sent during the handshake, and messages
// sent once the handshake has completed.
type cipherState struct {
        // nonce is the nonce passed into the chacha20-poly1305 instance for
        // encryption+decryption. The nonce is incremented after each successful
        // encryption/decryption.
        //
        // TODO(roasbeef): this should actually be 96 bit
        nonce uint64

        // secretKey is the shared symmetric key which will be used to
        // instantiate the cipher.
        //
        // TODO(roasbeef): m-lock??
        secretKey [32]byte

        // salt is an additional secret which is used during key rotation to
        // generate new keys.
        salt [32]byte

        // cipher is an instance of the ChaCha20-Poly1305 AEAD construction
        // created using the secretKey above.
        cipher cipher.AEAD
}

// Encrypt returns a ciphertext which is the encryption of the plainText
// observing the passed associatedData within the AEAD construction.
func (c *cipherState) Encrypt(associatedData, cipherText, plainText []byte) []byte <span class="cov8" title="710">{
        defer func() </span><span class="cov8" title="710">{
                c.nonce++

                if c.nonce == keyRotationInterval </span><span class="cov0" title="0">{
                        c.rotateKey()
                }</span>
        }()

        <span class="cov8" title="710">var nonce [12]byte
        binary.LittleEndian.PutUint64(nonce[4:], c.nonce)

        return c.cipher.Seal(cipherText, nonce[:], plainText, associatedData)</span>
}

// Decrypt attempts to decrypt the passed ciphertext observing the specified
// associatedData within the AEAD construction. In the case that the final MAC
// check fails, then a non-nil error will be returned.
func (c *cipherState) Decrypt(associatedData, plainText, cipherText []byte) ([]byte, error) <span class="cov8" title="660">{
        defer func() </span><span class="cov8" title="660">{
                c.nonce++

                if c.nonce == keyRotationInterval </span><span class="cov0" title="0">{
                        c.rotateKey()
                }</span>
        }()

        <span class="cov8" title="660">var nonce [12]byte
        binary.LittleEndian.PutUint64(nonce[4:], c.nonce)

        return c.cipher.Open(plainText, nonce[:], cipherText, associatedData)</span>
}

// InitializeKey initializes the secret key and AEAD cipher scheme based off of
// the passed key.
func (c *cipherState) InitializeKey(key [32]byte) <span class="cov9" title="1790">{
        c.secretKey = key
        c.nonce = 0

        // Safe to ignore the error here as our key is properly sized
        // (32-bytes).
        c.cipher, _ = chacha20poly1305.New(c.secretKey[:])
}</span>

// InitializeKeyWithSalt is identical to InitializeKey however it also sets the
// cipherState's salt field which is used for key rotation.
func (c *cipherState) InitializeKeyWithSalt(salt, key [32]byte) <span class="cov8" title="468">{
        c.salt = salt
        c.InitializeKey(key)
}</span>

// rotateKey rotates the current encryption/decryption key for this cipherState
// instance. Key rotation is performed by ratcheting the current key forward
// using an HKDF invocation with the cipherState's salt as the salt, and the
// current key as the input.
func (c *cipherState) rotateKey() <span class="cov0" title="0">{
        var (
                info    []byte
                nextKey [32]byte
        )

        oldKey := c.secretKey
        h := hkdf.New(sha256.New, oldKey[:], c.salt[:], info)

        // hkdf(ck, k, zero)
        // |
        // | \
        // |  \
        // ck  k'
        h.Read(c.salt[:])
        h.Read(nextKey[:])

        c.InitializeKey(nextKey)
}</span>

// symmetricState encapsulates a cipherState object and houses the ephemeral
// handshake digest state. This struct is used during the handshake to derive
// new shared secrets based off of the result of ECDH operations. Ultimately,
// the final key yielded by this struct is the result of an incremental
// Triple-DH operation.
type symmetricState struct {
        cipherState

        // chainingKey is used as the salt to the HKDF function to derive a new
        // chaining key as well as a new tempKey which is used for
        // encryption/decryption.
        chainingKey [32]byte

        // tempKey is the latter 32 bytes resulted from the latest HKDF
        // iteration. This key is used to encrypt/decrypt any handshake
        // messages or payloads sent until the next DH operation is executed.
        tempKey [32]byte

        // handshakeDigest is the cumulative hash digest of all handshake
        // messages sent from start to finish. This value is never transmitted
        // to the other side, but will be used as the AD when
        // encrypting/decrypting messages using our AEAD construction.
        handshakeDigest [32]byte
}

// mixKey is implements a basic HKDF-based key ratchet. This method is called
// with the result of each DH output generated during the handshake process.
// The first 32 bytes extract from the HKDF reader is the next chaining key,
// then latter 32 bytes become the temp secret key using within any future AEAD
// operations until another DH operation is performed.
func (s *symmetricState) mixKey(input []byte) <span class="cov8" title="870">{
        var info []byte

        secret := input
        salt := s.chainingKey
        h := hkdf.New(sha256.New, secret, salt[:], info)

        // hkdf(ck, input, zero)
        // |
        // | \
        // |  \
        // ck  k
        h.Read(s.chainingKey[:])
        h.Read(s.tempKey[:])

        // cipher.k = temp_key
        s.InitializeKey(s.tempKey)
}</span>

// mixHash hashes the passed input data into the cumulative handshake digest.
// The running result of this value (h) is used as the associated data in all
// decryption/encryption operations.
func (s *symmetricState) mixHash(data []byte) <span class="cov10" title="2567">{
        h := sha256.New()
        h.Write(s.handshakeDigest[:])
        h.Write(data)

        copy(s.handshakeDigest[:], h.Sum(nil))
}</span>

// EncryptAndHash returns the authenticated encryption of the passed plaintext.
// When encrypting the handshake digest (h) is used as the associated data to
// the AEAD cipher.
func (s *symmetricState) EncryptAndHash(plaintext []byte) []byte <span class="cov8" title="544">{
        ciphertext := s.Encrypt(s.handshakeDigest[:], nil, plaintext)

        s.mixHash(ciphertext)

        return ciphertext
}</span>

// DecryptAndHash returns the authenticated decryption of the passed
// ciphertext.  When encrypting the handshake digest (h) is used as the
// associated data to the AEAD cipher.
func (s *symmetricState) DecryptAndHash(ciphertext []byte) ([]byte, error) <span class="cov8" title="573">{
        plaintext, err := s.Decrypt(s.handshakeDigest[:], nil, ciphertext)
        if err != nil </span><span class="cov6" title="90">{
                return nil, err
        }</span>

        <span class="cov8" title="483">s.mixHash(ciphertext)

        return plaintext, nil</span>
}

// InitializeSymmetric initializes the symmetric state by setting the handshake
// digest (h) and the chaining key (ck) to protocol name.
func (s *symmetricState) InitializeSymmetric(protocolName []byte) <span class="cov8" title="452">{
        var empty [32]byte

        s.handshakeDigest = sha256.Sum256(protocolName)
        s.chainingKey = s.handshakeDigest
        s.InitializeKey(empty)
}</span>

// handshakeState encapsulates the symmetricState and keeps track of all the
// public keys (static and ephemeral) for both sides during the handshake
// transcript. If the handshake completes successfully, then two instances of a
// cipherState are emitted: one to encrypt messages from initiator to
// responder, and the other for the opposite direction.
type handshakeState struct {
        symmetricState

        initiator bool

        localStatic    *btcec.PrivateKey
        localEphemeral *btcec.PrivateKey

        remoteStatic    *btcec.PublicKey
        remoteEphemeral *btcec.PublicKey
}

// newHandshakeState returns a new instance of the handshake state initialized
// with the prologue and protocol name. If this is the responder's handshake
// state, then the remotePub can be nil.
func newHandshakeState(initiator bool, prologue []byte,
        localPub *btcec.PrivateKey, remotePub *btcec.PublicKey) handshakeState <span class="cov8" title="452">{

        h := handshakeState{
                initiator:    initiator,
                localStatic:  localPub,
                remoteStatic: remotePub,
        }

        // Set the current chaining key and handshake digest to the hash of the
        // protocol name, and additionally mix in the prologue. If either sides
        // disagree about the prologue or protocol name, then the handshake
        // will fail.
        h.InitializeSymmetric([]byte(protocolName))
        h.mixHash(prologue)

        // In Noise_XK, then initiator should know the responder's static
        // public key, therefore we include the responder's static key in the
        // handshake digest. If the initiator gets this value wrong, then the
        // handshake will fail.
        if initiator </span><span class="cov7" title="226">{
                h.mixHash(remotePub.SerializeCompressed())
        }</span> else<span class="cov7" title="226"> {
                h.mixHash(localPub.PubKey().SerializeCompressed())
        }</span>

        <span class="cov8" title="452">return h</span>
}

// EphemeralGenerator is a functional option that allows callers to substitute
// a custom function for use when generating ephemeral keys for ActOne or
// ActTwo.  The function closure return by this function can be passed into
// NewBrontideMachine as a function option parameter.
func EphemeralGenerator(gen func() (*btcec.PrivateKey, error)) func(*Machine) <span class="cov5" title="36">{
        return func(m *Machine) </span><span class="cov6" title="132">{
                m.ephemeralGen = gen
        }</span>
}

// Machine is a state-machine which implements Brontide: an
// Authenticated-key Exchange in Three Acts. Brontide is derived from the Noise
// framework, specifically implementing the Noise_XK handshake. Once the
// initial 3-act handshake has completed all messages are encrypted with a
// chacha20 AEAD cipher. On the wire, all messages are prefixed with an
// authenticated+encrypted length field. Additionally, the encrypted+auth'd
// length prefix is used as the AD when encrypting+decryption messages. This
// construction provides confidentiality of packet length, avoids introducing
// a padding-oracle, and binds the encrypted packet length to the packet
// itself.
//
// The acts proceeds the following order (initiator on the left):
//  GenActOne()   -&gt;
//                    RecvActOne()
//                &lt;-  GenActTwo()
//  RecvActTwo()
//  GenActThree() -&gt;
//                    RecvActThree()
//
// This exchange corresponds to the following Noise handshake:
//   &lt;- s
//   ...
//   -&gt; e, es
//   &lt;- e, ee
//   -&gt; s, se
type Machine struct {
        sendCipher cipherState
        recvCipher cipherState

        ephemeralGen func() (*btcec.PrivateKey, error)

        handshakeState

        // nextCipherHeader is a static buffer that we'll use to read in the
        // next ciphertext header from the wire. The header is a 2 byte length
        // (of the next ciphertext), followed by a 16 byte MAC.
        nextCipherHeader [encHeaderSize]byte

        // nextHeaderSend holds a reference to the remaining header bytes to
        // write out for a pending message. This allows us to tolerate timeout
        // errors that cause partial writes.
        nextHeaderSend []byte

        // nextHeaderBody holds a reference to the remaining body bytes to write
        // out for a pending message. This allows us to tolerate timeout errors
        // that cause partial writes.
        nextBodySend []byte
}

// NewBrontideMachine creates a new instance of the brontide state-machine. If
// the responder (listener) is creating the object, then the remotePub should
// be nil. The handshake state within brontide is initialized using the ascii
// string "lightning" as the prologue. The last parameter is a set of variadic
// arguments for adding additional options to the brontide Machine
// initialization.
func NewBrontideMachine(initiator bool, localPub *btcec.PrivateKey,
        remotePub *btcec.PublicKey, options ...func(*Machine)) *Machine <span class="cov8" title="452">{

        handshake := newHandshakeState(
                initiator, lightningPrologue, localPub, remotePub,
        )

        m := &amp;Machine{
                handshakeState: handshake,
                ephemeralGen:   ephemeralGen,
        }

        // With the default options established, we'll now process all the
        // options passed in as parameters.
        for _, option := range options </span><span class="cov6" title="132">{
                option(m)
        }</span>

        <span class="cov8" title="452">return m</span>
}

const (
        // HandshakeVersion is the expected version of the brontide handshake.
        // Any messages that carry a different version will cause the handshake
        // to abort immediately.
        HandshakeVersion = byte(0)

        // ActOneSize is the size of the packet sent from initiator to
        // responder in ActOne. The packet consists of a handshake version, an
        // ephemeral key in compressed format, and a 16-byte poly1305 tag.
        //
        // 1 + 33 + 16
        ActOneSize = 50

        // ActTwoSize is the size the packet sent from responder to initiator
        // in ActTwo. The packet consists of a handshake version, an ephemeral
        // key in compressed format and a 16-byte poly1305 tag.
        //
        // 1 + 33 + 16
        ActTwoSize = 50

        // ActThreeSize is the size of the packet sent from initiator to
        // responder in ActThree. The packet consists of a handshake version,
        // the initiators static key encrypted with strong forward secrecy and
        // a 16-byte poly1035
        // tag.
        //
        // 1 + 33 + 16 + 16
        ActThreeSize = 66
)

// GenActOne generates the initial packet (act one) to be sent from initiator
// to responder. During act one the initiator generates a fresh ephemeral key,
// hashes it into the handshake digest, and performs an ECDH between this key
// and the responder's static key. Future payloads are encrypted with a key
// derived from this result.
//
//    -&gt; e, es
func (b *Machine) GenActOne() ([ActOneSize]byte, error) <span class="cov6" title="178">{
        var (
                err    error
                actOne [ActOneSize]byte
        )

        // e
        b.localEphemeral, err = b.ephemeralGen()
        if err != nil </span><span class="cov0" title="0">{
                return actOne, err
        }</span>

        <span class="cov6" title="178">ephemeral := b.localEphemeral.PubKey().SerializeCompressed()
        b.mixHash(ephemeral)

        // es
        s := ecdh(b.remoteStatic, b.localEphemeral)
        b.mixKey(s[:])

        authPayload := b.EncryptAndHash([]byte{})

        actOne[0] = HandshakeVersion
        copy(actOne[1:34], ephemeral)
        copy(actOne[34:], authPayload)

        return actOne, nil</span>
}

// RecvActOne processes the act one packet sent by the initiator. The responder
// executes the mirrored actions to that of the initiator extending the
// handshake digest and deriving a new shared secret based on an ECDH with the
// initiator's ephemeral key and responder's static key.
func (b *Machine) RecvActOne(actOne [ActOneSize]byte) error <span class="cov6" title="180">{
        var (
                err error
                e   [33]byte
                p   [16]byte
        )

        // If the handshake version is unknown, then the handshake fails
        // immediately.
        if actOne[0] != HandshakeVersion </span><span class="cov1" title="2">{
                return fmt.Errorf("Act One: invalid handshake version: %v, "+
                        "only %v is valid, msg=%x", actOne[0], HandshakeVersion,
                        actOne[:])
        }</span>

        <span class="cov6" title="178">copy(e[:], actOne[1:34])
        copy(p[:], actOne[34:])

        // e
        b.remoteEphemeral, err = btcec.ParsePubKey(e[:], btcec.S256())
        if err != nil </span><span class="cov2" title="5">{
                return err
        }</span>
        <span class="cov6" title="173">b.mixHash(b.remoteEphemeral.SerializeCompressed())

        // es
        s := ecdh(b.remoteEphemeral, b.localStatic)
        b.mixKey(s)

        // If the initiator doesn't know our static key, then this operation
        // will fail.
        _, err = b.DecryptAndHash(p[:])
        return err</span>
}

// GenActTwo generates the second packet (act two) to be sent from the
// responder to the initiator. The packet for act two is identify to that of
// act one, but then results in a different ECDH operation between the
// initiator's and responder's ephemeral keys.
//
//    &lt;- e, ee
func (b *Machine) GenActTwo() ([ActTwoSize]byte, error) <span class="cov6" title="132">{
        var (
                err    error
                actTwo [ActTwoSize]byte
        )

        // e
        b.localEphemeral, err = b.ephemeralGen()
        if err != nil </span><span class="cov0" title="0">{
                return actTwo, err
        }</span>

        <span class="cov6" title="132">ephemeral := b.localEphemeral.PubKey().SerializeCompressed()
        b.mixHash(b.localEphemeral.PubKey().SerializeCompressed())

        // ee
        s := ecdh(b.remoteEphemeral, b.localEphemeral)
        b.mixKey(s)

        authPayload := b.EncryptAndHash([]byte{})

        actTwo[0] = HandshakeVersion
        copy(actTwo[1:34], ephemeral)
        copy(actTwo[34:], authPayload)

        return actTwo, nil</span>
}

// RecvActTwo processes the second packet (act two) sent from the responder to
// the initiator. A successful processing of this packet authenticates the
// initiator to the responder.
func (b *Machine) RecvActTwo(actTwo [ActTwoSize]byte) error <span class="cov6" title="163">{
        var (
                err error
                e   [33]byte
                p   [16]byte
        )

        // If the handshake version is unknown, then the handshake fails
        // immediately.
        if actTwo[0] != HandshakeVersion </span><span class="cov2" title="3">{
                return fmt.Errorf("Act Two: invalid handshake version: %v, "+
                        "only %v is valid, msg=%x", actTwo[0], HandshakeVersion,
                        actTwo[:])
        }</span>

        <span class="cov6" title="160">copy(e[:], actTwo[1:34])
        copy(p[:], actTwo[34:])

        // e
        b.remoteEphemeral, err = btcec.ParsePubKey(e[:], btcec.S256())
        if err != nil </span><span class="cov3" title="7">{
                return err
        }</span>
        <span class="cov6" title="153">b.mixHash(b.remoteEphemeral.SerializeCompressed())

        // ee
        s := ecdh(b.remoteEphemeral, b.localEphemeral)
        b.mixKey(s)

        _, err = b.DecryptAndHash(p[:])
        return err</span>
}

// GenActThree creates the final (act three) packet of the handshake. Act three
// is to be sent from the initiator to the responder. The purpose of act three
// is to transmit the initiator's public key under strong forward secrecy to
// the responder. This act also includes the final ECDH operation which yields
// the final session.
//
//    -&gt; s, se
func (b *Machine) GenActThree() ([ActThreeSize]byte, error) <span class="cov6" title="117">{
        var actThree [ActThreeSize]byte

        ourPubkey := b.localStatic.PubKey().SerializeCompressed()
        ciphertext := b.EncryptAndHash(ourPubkey)

        s := ecdh(b.remoteEphemeral, b.localStatic)
        b.mixKey(s)

        authPayload := b.EncryptAndHash([]byte{})

        actThree[0] = HandshakeVersion
        copy(actThree[1:50], ciphertext)
        copy(actThree[50:], authPayload)

        // With the final ECDH operation complete, derive the session sending
        // and receiving keys.
        b.split()

        return actThree, nil
}</span>

// RecvActThree processes the final act (act three) sent from the initiator to
// the responder. After processing this act, the responder learns of the
// initiator's static public key. Decryption of the static key serves to
// authenticate the initiator to the responder.
func (b *Machine) RecvActThree(actThree [ActThreeSize]byte) error <span class="cov6" title="132">{
        var (
                err error
                s   [33 + 16]byte
                p   [16]byte
        )

        // If the handshake version is unknown, then the handshake fails
        // immediately.
        if actThree[0] != HandshakeVersion </span><span class="cov1" title="2">{
                return fmt.Errorf("Act Three: invalid handshake version: %v, "+
                        "only %v is valid, msg=%x", actThree[0], HandshakeVersion,
                        actThree[:])
        }</span>

        <span class="cov6" title="130">copy(s[:], actThree[1:33+16+1])
        copy(p[:], actThree[33+16+1:])

        // s
        remotePub, err := b.DecryptAndHash(s[:])
        if err != nil </span><span class="cov3" title="13">{
                return err
        }</span>
        <span class="cov6" title="117">b.remoteStatic, err = btcec.ParsePubKey(remotePub, btcec.S256())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // se
        <span class="cov6" title="117">se := ecdh(b.remoteStatic, b.localEphemeral)
        b.mixKey(se)

        if _, err := b.DecryptAndHash(p[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the final ECDH operation complete, derive the session sending
        // and receiving keys.
        <span class="cov6" title="117">b.split()

        return nil</span>
}

// split is the final wrap-up act to be executed at the end of a successful
// three act handshake. This function creates two internal cipherState
// instances: one which is used to encrypt messages from the initiator to the
// responder, and another which is used to encrypt message for the opposite
// direction.
func (b *Machine) split() <span class="cov7" title="234">{
        var (
                empty   []byte
                sendKey [32]byte
                recvKey [32]byte
        )

        h := hkdf.New(sha256.New, empty, b.chainingKey[:], empty)

        // If we're the initiator the first 32 bytes are used to encrypt our
        // messages and the second 32-bytes to decrypt their messages. For the
        // responder the opposite is true.
        if b.initiator </span><span class="cov6" title="117">{
                h.Read(sendKey[:])
                b.sendCipher = cipherState{}
                b.sendCipher.InitializeKeyWithSalt(b.chainingKey, sendKey)

                h.Read(recvKey[:])
                b.recvCipher = cipherState{}
                b.recvCipher.InitializeKeyWithSalt(b.chainingKey, recvKey)
        }</span> else<span class="cov6" title="117"> {
                h.Read(recvKey[:])
                b.recvCipher = cipherState{}
                b.recvCipher.InitializeKeyWithSalt(b.chainingKey, recvKey)

                h.Read(sendKey[:])
                b.sendCipher = cipherState{}
                b.sendCipher.InitializeKeyWithSalt(b.chainingKey, sendKey)
        }</span>
}

// WriteMessage encrypts and buffers the next message p. The ciphertext of the
// message is prepended with an encrypt+auth'd length which must be used as the
// AD to the AEAD construction when being decrypted by the other side.
//
// NOTE: This DOES NOT write the message to the wire, it should be followed by a
// call to Flush to ensure the message is written.
func (b *Machine) WriteMessage(p []byte) error <span class="cov6" title="83">{
        // The total length of each message payload including the MAC size
        // payload exceed the largest number encodable within a 16-bit unsigned
        // integer.
        if len(p) &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                return ErrMaxMessageLengthExceeded
        }</span>

        // If a prior message was written but it hasn't been fully flushed,
        // return an error as we only support buffering of one message at a
        // time.
        <span class="cov6" title="83">if len(b.nextHeaderSend) &gt; 0 || len(b.nextBodySend) &gt; 0 </span><span class="cov0" title="0">{
                return ErrMessageNotFlushed
        }</span>

        // The full length of the packet is only the packet length, and does
        // NOT include the MAC.
        <span class="cov6" title="83">fullLength := uint16(len(p))

        var pktLen [2]byte
        binary.BigEndian.PutUint16(pktLen[:], fullLength)

        // First, generate the encrypted+MAC'd length prefix for the packet.
        b.nextHeaderSend = b.sendCipher.Encrypt(nil, nil, pktLen[:])

        // Finally, generate the encrypted packet itself.
        b.nextBodySend = b.sendCipher.Encrypt(nil, nil, p)

        return nil</span>
}

// Flush attempts to write a message buffered using WriteMessage to the provided
// io.Writer. If no buffered message exists, this will result in a NOP.
// Otherwise, it will continue to write the remaining bytes, picking up where
// the byte stream left off in the event of a partial write. The number of bytes
// returned reflects the number of plaintext bytes in the payload, and does not
// account for the overhead of the header or MACs.
//
// NOTE: It is safe to call this method again iff a timeout error is returned.
func (b *Machine) Flush(w io.Writer) (int, error) <span class="cov6" title="83">{
        // First, write out the pending header bytes, if any exist. Any header
        // bytes written will not count towards the total amount flushed.
        if len(b.nextHeaderSend) &gt; 0 </span><span class="cov6" title="83">{
                // Write any remaining header bytes and shift the slice to point
                // to the next segment of unwritten bytes. If an error is
                // encountered, we can continue to write the header from where
                // we left off on a subsequent call to Flush.
                n, err := w.Write(b.nextHeaderSend)
                b.nextHeaderSend = b.nextHeaderSend[n:]
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Next, write the pending body bytes, if any exist. Only the number of
        // bytes written that correspond to the ciphertext will be included in
        // the total bytes written, bytes written as part of the MAC will not be
        // counted.
        <span class="cov6" title="83">var nn int
        if len(b.nextBodySend) &gt; 0 </span><span class="cov6" title="83">{
                // Write out all bytes excluding the mac and shift the body
                // slice depending on the number of actual bytes written.
                n, err := w.Write(b.nextBodySend)
                b.nextBodySend = b.nextBodySend[n:]

                // If we partially or fully wrote any of the body's MAC, we'll
                // subtract that contribution from the total amount flushed to
                // preserve the abstraction of returning the number of plaintext
                // bytes written by the connection.
                //
                // There are three possible scenarios we must handle to ensure
                // the returned value is correct. In the first case, the write
                // straddles both payload and MAC bytes, and we must subtract
                // the number of MAC bytes written from n. In the second, only
                // payload bytes are written, thus we can return n unmodified.
                // The final scenario pertains to the case where only MAC bytes
                // are written, none of which count towards the total.
                //
                //                 |-----------Payload------------|----MAC----|
                // Straddle:       S---------------------------------E--------0
                // Payload-only:   S------------------------E-----------------0
                // MAC-only:                                        S-------E-0
                start, end := n+len(b.nextBodySend), len(b.nextBodySend)
                switch </span>{

                // Straddles payload and MAC bytes, subtract number of MAC bytes
                // written from the actual number written.
                case start &gt; macSize &amp;&amp; end &lt;= macSize:<span class="cov5" title="75">
                        nn = n - (macSize - end)</span>

                // Only payload bytes are written, return n directly.
                case start &gt; macSize &amp;&amp; end &gt; macSize:<span class="cov0" title="0">
                        nn = n</span>

                // Only MAC bytes are written, return 0 bytes written.
                default:<span class="cov3" title="8"></span>
                }

                <span class="cov6" title="83">if err != nil </span><span class="cov0" title="0">{
                        return nn, err
                }</span>
        }

        <span class="cov6" title="83">return nn, nil</span>
}

// ReadMessage attempts to read the next message from the passed io.Reader. In
// the case of an authentication error, a non-nil error is returned.
func (b *Machine) ReadMessage(r io.Reader) ([]byte, error) <span class="cov5" title="75">{
        pktLen, err := b.ReadHeader(r)
        if err != nil </span><span class="cov5" title="34">{
                return nil, err
        }</span>

        <span class="cov5" title="41">buf := make([]byte, pktLen)
        return b.ReadBody(r, buf)</span>
}

// ReadHeader attempts to read the next message header from the passed
// io.Reader. The header contains the length of the next body including
// additional overhead of the MAC. In the case of an authentication error, a
// non-nil error is returned.
//
// NOTE: This method SHOULD NOT be used in the case that the io.Reader may be
// adversarial and induce long delays. If the caller needs to set read deadlines
// appropriately, it is preferred that they use the split ReadHeader and
// ReadBody methods so that the deadlines can be set appropriately on each.
func (b *Machine) ReadHeader(r io.Reader) (uint32, error) <span class="cov5" title="75">{
        _, err := io.ReadFull(r, b.nextCipherHeader[:])
        if err != nil </span><span class="cov4" title="29">{
                return 0, err
        }</span>

        // Attempt to decrypt+auth the packet length present in the stream.
        <span class="cov5" title="46">pktLenBytes, err := b.recvCipher.Decrypt(
                nil, nil, b.nextCipherHeader[:],
        )
        if err != nil </span><span class="cov2" title="5">{
                return 0, err
        }</span>

        // Compute the packet length that we will need to read off the wire.
        <span class="cov5" title="41">pktLen := uint32(binary.BigEndian.Uint16(pktLenBytes)) + macSize

        return pktLen, nil</span>
}

// ReadBody attempts to ready the next message body from the passed io.Reader.
// The provided buffer MUST be the length indicated by the packet length
// returned by the preceding call to ReadHeader. In the case of an
// authentication eerror, a non-nil error is returned.
func (b *Machine) ReadBody(r io.Reader, buf []byte) ([]byte, error) <span class="cov5" title="41">{
        // Next, using the length read from the packet header, read the
        // encrypted packet itself into the buffer allocated by the read
        // pool.
        _, err := io.ReadFull(r, buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Finally, decrypt the message held in the buffer, and return a
        // new byte slice containing the plaintext.
        // TODO(roasbeef): modify to let pass in slice
        <span class="cov5" title="41">return b.recvCipher.Decrypt(nil, nil, buf)</span>
}

// SetCurveToNil sets the 'Curve' parameter to nil on the handshakeState keys.
// This allows us to log the Machine object without spammy log messages.
func (b *Machine) SetCurveToNil() <span class="cov0" title="0">{
        if b.localStatic != nil </span><span class="cov0" title="0">{
                b.localStatic.Curve = nil
        }</span>

        <span class="cov0" title="0">if b.localEphemeral != nil </span><span class="cov0" title="0">{
                b.localEphemeral.Curve = nil
        }</span>

        <span class="cov0" title="0">if b.remoteStatic != nil </span><span class="cov0" title="0">{
                b.remoteStatic.Curve = nil
        }</span>

        <span class="cov0" title="0">if b.remoteEphemeral != nil </span><span class="cov0" title="0">{
                b.remoteEphemeral.Curve = nil
        }</span>
}
</pre>
		
		</div>
	
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>

</body></html>